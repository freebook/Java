<?xml version="1.0" encoding="UTF-8"?>
<section id="index"><?dbhtml dir="thread" ?>
	<title>Java 线程</title>
	<para></para>
	<section>
		<title>多线程 Lambda 表达式</title>
		<programlisting>
		<![CDATA[
	new Thread(() -> {
		Thread.sleep(millis);
	});		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
new Thread(() -> System.out.println("多线程")).start();
		]]>
		</programlisting>
	</section>

	<section>
		<title>实现异步执行</title>
		<programlisting>
		<![CDATA[
	public void testThread() throws Exception {
		try {
			Thread sendmail = new Thread(new Runnable() {
				@Override
				public void run() {
					// Sendmail
					log.info("Sendmail OK");
				}
			});
			sendmail.setName("sendmail");
			sendmail.start();
		} catch (Exception e) {
			e.printStackTrace();
		}	
	}				
		]]>
		</programlisting>
		<para></para>
	</section>
	<section id="Thread">
		<title>继承 Thread 类实现多线程</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.ipo.test;

public class MyThread extends Thread {

	private String name;

	public MyThread(String name) {
		super();
		this.name = name;
	}

	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println("Thread:" + this.name + ",i=" + i);
		}
	}

	public static void main(String[] args) {
		MyThread mt1 = new MyThread("A");
		MyThread mt2 = new MyThread("B");
		mt1.start();
		mt2.start();
	}
}
		]]>
		</programlisting>

		<section>
			<title>设置线程名称</title>
			<para></para>
			<programlisting>
			<![CDATA[

    public static void setThreadName1() {
        new Thread("thread-name-1") {
            public void run() {
                try {
                    Thread.sleep(1000 * 15);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("threadName1: " + this.getName());

            }
        }.start();
    }

    public static void setThreadName2() {
        new Thread() {
            @SneakyThrows
            public void run() {
                this.setName("thread-name-2");
                Thread.sleep(1000 * 15);
                System.out.println("threadName2: " + this.getName());

            }
        }.start();
    }

    public static void setThreadName3() {
        Thread thread = new Thread() {
            public void run() {
                try {
                    Thread.sleep(1000 * 15);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("threadName3: " + this.getName());

            }
        };

        thread.setName("thread-name-3");
        thread.start();
    }

    public static void setThreadName4() {
        new Thread("测试线程-1") {
            public void run() {
                try {
                    Thread.sleep(1000 * 15);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("threadName1: " + this.getName());

            }
        }.start();
    }			
			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
public class MyThread extends Thread {
    public MyThread(){

    }
    public MyThread(String name){
        super(name);
    }
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName());
    }
}

public class DemoThreadName {

    public static void main(String[] args) {

        MyThread mt = new MyThread();
        mt.setName("景峰");
        mt.start();

        new MyThread("netkiller").start();

    }
}

			]]>
			</programlisting>
		</section>
	</section>
	<section id="Runnable">
		<title>实现 Runnable 接口</title>
		<programlisting>
		<![CDATA[
		
package cn.netkiller.ipo.test;

public class MyRunnable implements Runnable {

	private String name;

	public MyRunnable(String name) {
		this.name = name;
	}

	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
			System.out.println("Thread:" + this.name + ",i=" + i);
		}

	}

	public static void main(String[] args) {

		MyRunnable mr1 = new MyRunnable("A");
		MyRunnable mr2 = new MyRunnable("B");

		new Thread(mr1).start();
		new Thread(mr2).start();
		new Thread(new MyRunnable("C")).start();
	}
}
		]]>
		</programlisting>
	</section>
	<section id="synchronized">
		<title>线程同步</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.thread;

public class SynchronizedThread extends Thread {
	private int count = 0;

	@Override
	public /*synchronized*/ void run() {
		count++;
		System.out.println(Thread.currentThread().getName() + " count:" + count);
	}

	public static void main(String[] args) {
		SynchronizedThread myThread = new SynchronizedThread();
		Thread thread1 = new Thread(myThread, "thread1");
		Thread thread2 = new Thread(myThread, "thread2");
		Thread thread3 = new Thread(myThread, "thread3");
		Thread thread4 = new Thread(myThread, "thread4");
		Thread thread5 = new Thread(myThread, "thread5");
		thread1.start();
		thread2.start();
		thread3.start();
		thread4.start();
		thread5.start();
	}
}		
		]]>
		</programlisting>
		<para>线程运行不分先后</para>
		<screen>
		<![CDATA[
thread2 count:3
thread4 count:4
thread1 count:3
thread3 count:3
thread5 count:5
		]]>
		</screen>
		<programlisting>
		<![CDATA[
package cn.netkiller.thread;

public class SynchronizedThread extends Thread {
	private int count = 0;

	@Override
	public synchronized void run() {
		count++;
		System.out.println(Thread.currentThread().getName() + " count:" + count);
	}

	public static void main(String[] args) {
		SynchronizedThread myThread = new SynchronizedThread();
		Thread thread1 = new Thread(myThread, "thread1");
		Thread thread2 = new Thread(myThread, "thread2");
		Thread thread3 = new Thread(myThread, "thread3");
		Thread thread4 = new Thread(myThread, "thread4");
		Thread thread5 = new Thread(myThread, "thread5");
		thread1.start();
		thread2.start();
		thread3.start();
		thread4.start();
		thread5.start();
	}
}		
		]]>
		</programlisting>
		<screen>
		<![CDATA[
thread1 count:1
thread5 count:2
thread4 count:3
thread2 count:4
thread3 count:5
		]]>
		</screen>
		<programlisting>
		<![CDATA[
package cn.netkiller.thread;

public class MultiThread {
	private static int count = 0;

	public synchronized void add() {
		count++;
		System.out.println(Thread.currentThread().getName() + " count:" + count);
	}

	public static void main(String[] args) throws InterruptedException {

		final MultiThread multiThread1 = new MultiThread();
		final MultiThread multiThread2 = new MultiThread();
		final MultiThread multiThread3 = new MultiThread();
		final MultiThread multiThread4 = new MultiThread();
		final MultiThread multiThread5 = new MultiThread();

		new Thread(new Runnable() {
			public void run() {
				multiThread1.add();
			}
		}).start();

		new Thread(new Runnable() {
			public void run() {
				multiThread2.add();
			}
		}).start();

		new Thread(new Runnable() {
			public void run() {
				multiThread3.add();
			}
		}).start();

		new Thread(new Runnable() {
			public void run() {
				multiThread4.add();
			}
		}).start();

		new Thread(new Runnable() {
			public void run() {
				multiThread5.add();
			}
		}).start();
	}
}
		]]>
		</programlisting>
	</section>
	<section id="ThreadPool">
		<title>java 线程池</title>
		<section id="Executors.newCachedThreadPool">
			<title>newCachedThreadPool</title>
			<programlisting>
			<![CDATA[
	private void startTask(List<String> usersList){
        ExecutorService executor = Executors.newCachedThreadPool();
        executor.submit(()->{
			//do someting
        });
    }
			
			]]>
			</programlisting>
		</section>
		<section>
			<title>固定线程池(newFixedThreadPool)</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test.grey;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class GreyTest {

	public GreyTest() {
		// TODO Auto-generated constructor stub
	}

	static class MyThread implements Runnable {
		public void run() {
			System.out.println("Thread Name:" + Thread.currentThread().getName());
		}
	}

	public static void main(String[] args) {
		// 创建五个线程池
		int nThreads = 5;
		ExecutorService pool = Executors.newFixedThreadPool(nThreads);
		// 创建实现了Runnable接口对象
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();
		MyThread t3 = new MyThread();
		MyThread t4 = new MyThread();
		MyThread t5 = new MyThread();
		// 将线程放入池中进行执行
		pool.execute(t1);
		pool.execute(t2);
		pool.execute(t3);
		pool.execute(t4);
		pool.execute(t5);
		// 关闭线程池
		pool.shutdown();
	}

}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Executors.newScheduledThreadPool</title>
			<programlisting>
			<![CDATA[

@Configuration
public class ScheduleConfig implements SchedulingConfigurer {

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        //当然了，这里设置的线程池是corePoolSize也是很关键了，自己根据业务需求设定
        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));
    }

}			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="ThreadLocal">
		<title>ThreadLocal</title>
		<programlisting>
		<![CDATA[
    public static void threadLocal() {
        ThreadLocal<String> local = new ThreadLocal<>();

        IntStream.range(0, 10).forEach(i -> new Thread(() -> {
            local.set(Thread.currentThread().getName() + ":" + i);
            System.out.println("线程：" + Thread.currentThread().getName() + ",local:" + local.get());
        }).start());
    }		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
package cn.netkiller.thread;

public class ThreadLocaTest {

    private static ThreadLocal<String> local = new ThreadLocal<String>();
    public static void main(String[] args) throws InterruptedException {

        new Thread(new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread().getName() + "：" + local.get());
                ThreadLocaTest.local.set("thread_A");
                System.out.println(Thread.currentThread().getName() + "：" + local.get());
            }
        }, "A").start();

        Thread.sleep(1000);

        new Thread(new Runnable() {
            public void run() {
                System.out.println(Thread.currentThread().getName() + "：" + local.get());
                ThreadLocaTest.local.set("thread_B");
                System.out.println(Thread.currentThread().getName() + "：" + local.get());
                local.remove();
                System.out.println("remove: " + local.get());
            }
        }, "B").start();
    }
}		
		]]>
		</programlisting>
	</section>
	<section id="InheritableThreadLocal">
		<title>InheritableThreadLocal</title>
		<programlisting>
		<![CDATA[
    public static void inheritableThreadLocal() {
        InheritableThreadLocal threadLocal = new InheritableThreadLocal();
        IntStream.range(0, 10).forEach(i -> {
            //每个线程的序列号，希望在子线程中能够拿到
            threadLocal.set(i);
            //这里来了一个子线程，我们希望可以访问上面的threadLocal
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + ":" + threadLocal.get());
            }).start();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
    }
		]]>
		</programlisting>
	</section>
	<section id="CompletableFuture">
		<title>CompletableFuture</title>
		<section id="runAsync">
			<title>runAsync 创建没有返回值的异步任务</title>
			<para>runAsync 创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是自定义线程池的重载方法</para>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture.runAsync(() -> {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture.runAsync(() -> {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }, executorService);

        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
            System.out.println("do something....");
//            Thread.currentThread().setName("测试有返回值的异步执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("Result ->" + completableFuture.isDone());


    }
}
			]]>
			</programlisting>
			<para></para>
			<screen>
			<![CDATA[
do something...
do something...
do something....

=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
|   22 |                  pool-1-thread-1 |  main |  false | TIMED_WAITING |        5 |
|   23 | ForkJoinPool.commonPool-worker-2 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================

Result ->true
			]]>
			</screen>
		</section>
		<section id="supplyAsync">
			<title>supplyAsync 创建带有返回值的异步任务。</title>
			<para>supplyAsync 创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法</para>
			<screen>
			<![CDATA[
// 带返回值异步请求，默认线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
 
// 带返回值的异步请求，可以自定义线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)			
			]]>
			</screen>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            return "done";
        });

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================		
			]]>
			</screen>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {


        ExecutorService executorService = Executors.newSingleThreadExecutor();

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "done";
        }, executorService);

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
======================================================================
|   ID |            Name | Group | Daemon |         State | Priority |
----------------------------------------------------------------------
|    1 |            main |  main |  false |      RUNNABLE |        5 |
|   21 | pool-1-thread-1 |  main |  false |       WAITING |        5 |
======================================================================			
			]]>
			</screen>
			<para>设置线程名称</para>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            Thread.currentThread().setName("测试有返回值的异步执行");
            return "done";
        });

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
==================================================================
|   ID |        Name | Group | Daemon |         State | Priority |
------------------------------------------------------------------
|    1 |        main |  main |  false |      RUNNABLE |        5 |
|   21 | 测试有返回值的异步执行 |  main |   true | TIMED_WAITING | 5 |
==================================================================	
			]]>
			</screen>
		</section>
		
		<section id="Run">
			<title>thenRun / thenRunAsync</title>
			<para>thenRun/thenRunAsync 功能是什么？完成前置任务之后，自己在执行。</para>
			<para>thenRun/thenRunAsync 区别是什么？thenRun 使用同一个线程执行任务，thenRunAsync 会再开一个新线程执行任务。</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureRun")
    public String completableFutureRun() {
        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
            System.out.println(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        CompletableFuture thenRun = completableFuture.thenRun(() -> {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRun 任务");
        });
        CompletableFuture thenRunAsync = completableFuture.thenRunAsync(() -> {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRunAsync 任务");
        });
        return "Done";
    }			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenRun 任务
ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenRunAsync 任务
			]]>
			</screen>
			<para>这里可以看到 thenRunAsync 的线程变化，开启新线程 ForkJoinPool.commonPool-worker-2 处理任务</para>
		</section>
		<section id="Accept">
			<title>thenAccept / thenAcceptAsync</title>
			<para>thenAccept/thenAcceptAsync 的功能是，前置任务执行完毕之后，将返回值给到 thenAccept/thenAcceptAsync，再执行接下来的任务。</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureAccept")
    public String completableFutureAccept() {
        CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "前置任务执行完成";
        });
        CompletableFuture<Void> thenAccept = supplyAsync.thenAccept((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAccept 任务");
            log.info("前置任务返回值：" + rev);
        });
        CompletableFuture<Void> thenAcceptAsync = supplyAsync.thenAcceptAsync((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAcceptAsync 任务");
            log.info("前置任务返回值：" + rev);
        });
        return "Done";
    }			
			]]>
			</programlisting>
			<para>输出结果</para>
			<screen>
			<![CDATA[
2023-05-10T10:38:48.008+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenAcceptAsync 任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenAccept 任务
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成			
			]]>
			</screen>
		</section>
		<section id="Apply">
			<title>thenApply / thenApplyAsync</title>
			<para>thenApply/thenApplyAsync 前置任务执行完毕之后，结果作为入参，thenApply/thenApplyAsync 执行完毕之后再返回执行结果</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureApply")
    public String completableFutureApply() throws ExecutionException, InterruptedException {
        CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "第一步";
        });

        CompletableFuture<String> thenApply = supplyAsync.thenApply((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApply 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });

        CompletableFuture<String> thenApplyAsync = supplyAsync.thenApplyAsync((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApplyAsync 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });
        log.info("supplyAsync：{}", supplyAsync.get());
        log.info("thenApply：{}", thenApply.get());
        log.info("thenApplyAsync：{}", thenApplyAsync.get());
        return "Done";
    }			
			]]>
			</programlisting>
			<para></para>
			<screen>
			<![CDATA[
2023-05-10T10:39:57.913+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - CompletableFuture 前置任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : XNIO-1 task-2 - 接着执行第二个 thenApply 任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenApplyAsync 任务
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : supplyAsync：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApply：第二步
2023-05-10T10:40:02.919+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApplyAsync：第二步
			]]>
			</screen>
		</section>
		<section>
			<title>runAsync / thenAccept / thenApply 区别</title>
			<para>runAsync 配合 thenRun/thenRunAsync 使用</para>
			<para>supplyAsync 配合 thenAccept/thenAcceptAsync 使用</para>
			<screen>
			<![CDATA[
supplyAsync -- 返回值 --> thenAccept/thenAcceptAsync --> 无返回值
			]]>
			</screen>
			<para>supplyAsync 配合 thenApply/thenApplyAsync 使用</para>
			<screen>
			<![CDATA[
supplyAsync -- 返回值 --> thenApply/thenApplyAsync -- 返回值 -->			
			]]>
			</screen>
		</section>
		<section>
			<title>whenComplete</title>
			<para>whenComplete 与 runAsync / thenAccept / thenApply 区别是能处理 Throwable</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureWhenComplete")
    public String completableFutureWhenComplete() throws ExecutionException, InterruptedException {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            return "前置任务完成";
        }).whenComplete((result, throwable) -> {
            System.out.println("前置任务返回值：" + result);
        });
        System.out.println(completableFuture.get());
        return "Done";
    }			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
当前线程名称：ForkJoinPool.commonPool-worker-1
前置任务返回值：前置任务完成
前置任务完成			
			]]>
			</screen>
		</section>
		
		<section>
			<title>异常处理</title>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureExceptionally")
    public String completableFutureExceptionally() throws ExecutionException, InterruptedException {

        CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            throw new RuntimeException();
        }).exceptionally((e) -> {
            System.out.println(e.getMessage());
            return "程序出现异常";
        });

//        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
////            throw new RuntimeException();
//            return "程序出现异常";
//        }).exceptionally((e) -> {
//            System.out.println("程序出现异常");
//            return "程序出现异常";
//        });
//        System.out.println(completableFuture.get());

        return "Done";
    }			
			]]>
			</programlisting>
			<para>输出结果</para>
			<screen>
			<![CDATA[
当前线程名称：ForkJoinPool.commonPool-worker-1
java.lang.RuntimeException			
			]]>
			</screen>
		</section>
		
	</section>
</section>
