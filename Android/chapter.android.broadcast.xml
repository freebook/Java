<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="broadcast" ?>
	<title>消息广播</title>
	<para>安卓中有两种广播，一种是系统发出的广播信息，例如网络改变，电池的电量低等等，另一种是用户发出的广播信息。</para>
	<para>Android 中的广播类型可以分为两种类型，标准广播和有序广播。</para>
	<para>标准广播（Normal
		broadcasts）：标准广播是一种完全异步执行的广播，在广播发出之后，所有的广播接收器几乎会在同一时刻接收到这条广播消息。这种广播效率比较高，但同时也意味着它是无法被截断的。
	</para>
	<para>有序广播（Ordered
		broadcasts）：有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个广播接收器能够收到这条广播消息，当这个广播接收器中的逻辑执行完毕之后，广播才会继续传递。
	</para>
	<screen>
	<![CDATA[
android.intent.action.BATTERY_CHANGED	持久广播含充电状态，级别，以及其他相关的电池信息。
android.intent.action.BATTERY_LOW		显示设备的电池电量低。
android.intent.action.BATTERY_OKAY		指示电池正在低点后但没有问题。
android.intent.action.BOOT_COMPLETED	一次播出后，系统已完成启动。
android.intent.action.BUG_REPORT		显示活动报告的错误。
android.intent.action.CALL				执行呼叫由数据指定某人。
android.intent.action.CALL_BUTTON		用户按下“呼叫”按钮进入拨号器或其他适当的用户界面发出呼叫。
android.intent.action.DATE_CHANGED		日期改变。
android.intent.action.REBOOT			有设备重启。	
	]]>
	</screen>
	<section id="broadcast.registerReceiver">
		<title>动态注册</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private MyBroadcastReceiver myBroadcastReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        intentFilter = new IntentFilter();
        //为过滤器添加处理规则
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        myBroadcastReceiver = new MyBroadcastReceiver();
        //注册广播接收器
        registerReceiver(myBroadcastReceiver, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销动态的广播接收器
        unregisterReceiver(myBroadcastReceiver);
    }

    //自定义内部类，继承 BroadcastReceiver
    public class MyBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            Toast.makeText(context, "网络状态已改变", Toast.LENGTH_SHORT).show();
        }
    }
}
		
		]]>
		</programlisting>
		<para>现在尝试改变网络状态，例如开启或关闭飞行模式，程序会弹出 "网络状态已改变"。</para>
		<para>我的测试环境是 Android 9 Pie 没有加入下面的权限仍然能工作</para>
		<programlisting>
		<![CDATA[
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />		
		]]>
		</programlisting>
		<para>优化程序</para>
		<programlisting>
		<![CDATA[
package cn.netkiller.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.os.BatteryManager;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private MyBroadcastReceiver myBroadcastReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        intentFilter = new IntentFilter();
        //为过滤器添加处理规则
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);
        intentFilter.addAction(Intent.ACTION_BATTERY_CHANGED);
        intentFilter.addAction(Intent.ACTION_BATTERY_LOW);

        myBroadcastReceiver = new MyBroadcastReceiver();
        //注册广播接收器
        registerReceiver(myBroadcastReceiver, intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销动态的广播接收器
        unregisterReceiver(myBroadcastReceiver);
    }

    //自定义内部类，继承 BroadcastReceiver
    public class MyBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
            //判断是否联网
            if (networkInfo != null && networkInfo.isConnected()) {
                Toast.makeText(context, "网络已连接", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "网络不可用", Toast.LENGTH_SHORT).show();
            }

            int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
            boolean isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING ||
                    status == BatteryManager.BATTERY_STATUS_FULL;

            if (isCharging) {
                Toast.makeText(context, "正在充电", Toast.LENGTH_SHORT).show();
            } else {
                Toast.makeText(context, "电池已经充满", Toast.LENGTH_SHORT).show();
            }

            int chargePlug = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
            boolean usbCharge = chargePlug == BatteryManager.BATTERY_PLUGGED_USB;
            boolean acCharge = chargePlug == BatteryManager.BATTERY_PLUGGED_AC;
            if (usbCharge) {
                Toast.makeText(context, "USB 充电", Toast.LENGTH_SHORT).show();
            }

        }
    }
}		
		]]>
		</programlisting>
	</section>
	<section id="broadcast.static">
		<title>静态注册</title>
		<para>Android Studio 选择 File - New - Other - Broadcast Receiver</para>
		<programlisting>
		<![CDATA[
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="cn.netkiller.broadcast">

    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">
        <activity android:name=".MainActivity">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".MyReceiver"
            android:enabled="true"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.BOOT_COMPLETED" />
            </intent-filter>

        </receiver>
    </application>

</manifest>		
		]]>
		</programlisting>
		<para>MyReceiver 集成 BroadcastReceiver 在 onReceive 中写入你的业务逻辑。</para>
		<programlisting>
		<![CDATA[
package cn.netkiller.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.widget.Toast;

public class MyReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, "程序已启动，接收到系统启动广播", Toast.LENGTH_SHORT).show();
    }
}
		
		]]>
		</programlisting>
		<para>现在重启 Android 模拟器，启动后虽然 App 并没有进入，但是屏幕底部会看到 "程序已启动，接收到系统启动广播"
		</para>
		<section id="电源管理">
			<title>电源管理</title>
			<para>静态注册</para>
			<programlisting>
		<![CDATA[
        <receiver
            android:name=".receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.ACTION_BATTERY_CHANGED" />
                <action android:name="android.intent.action.ACTION_BATTERY_LOW" />
                <action android:name="android.intent.action.ACTION_BATTERY_OKAY" />
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>		
		]]>
			</programlisting>
			<para>动态注册</para>
			<programlisting>
		<![CDATA[
            IntentFilter filter = new IntentFilter();
            filter.addAction(Intent.ACTION_BATTERY_CHANGED);
            filter.addAction(Intent.ACTION_BATTERY_LOW);
            filter.addAction(Intent.ACTION_BATTERY_OKAY);
            filter.addAction(Intent.ACTION_POWER_CONNECTED);
            filter.addAction(Intent.ACTION_POWER_DISCONNECTED);		
		]]>
			</programlisting>
		</section>
		<section>
			<title>接收不到消息</title>
			<para>Android 8 以上，静态广播必须指定包名 intent.setPackage(context.getPackageName());</para>
			<programlisting>
			<![CDATA[
    public static void broadcastTest(String message) {
        Log.d(TAG, "发送广播: " + message);
        Context context = ContextHolder.getContext();
        Intent intent = new Intent();
        intent.setAction("test.broadcast");
        intent.setPackage(context.getPackageName());
        intent.putExtra("message", message);
        context.sendBroadcast(intent);
    }
			]]>
			</programlisting>
		</section>
		<section>
			<title>StaticBroadcastReceiver 完整的例子</title>
			<programlisting>
			<![CDATA[
        <receiver
            android:name="com.netkiller.conference.receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.ACTION_BATTERY_CHANGED" />
                <action android:name="android.intent.action.ACTION_BATTERY_LOW" />
                <action android:name="android.intent.action.ACTION_BATTERY_OKAY" />
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
                <action android:name="android.intent.action.DOWNLOAD_COMPLETE" />
                <action android:name="android.intent.action.ACTION_CLOSE_SYSTEM_DIALOGS" />
                <action android:name="android.intent.action" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>
			]]>
			</programlisting>
			
			<programlisting>
			<![CDATA[
package com.netkiller.conference.receiver;

import android.app.DownloadManager;
import android.bluetooth.BluetoothDevice;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.util.Log;

import com.netkiller.conference.MainActivity;
import com.netkiller.conference.ai.aigc.AigcSpeech;
import com.netkiller.conference.ai.aigc.Cache;
//import cn.aigcsst.aigc.education.skill.PictureSkillComponent;

public class StaticBroadcastReceiver extends BroadcastReceiver {
    private static final String TAG = StaticBroadcastReceiver.class.getSimpleName();
    private final Cache cache = new Cache();
    private final AigcSpeech aigcSpeech = AigcSpeech.getInstance();

    @Override
    public void onReceive(Context context, Intent intent) {

        String action = intent.getAction();
        Log.d(TAG, "Static broadcast Action: " + intent.getAction());

        try {
            switch (action) {
                case Intent.ACTION_BOOT_COMPLETED:
                    Log.d(TAG, "自启动了 ！！！！！");
                    intent = new Intent(context, MainActivity.class);  // 要启动的Activity
                    //1.如果自启动APP，参数为需要自动启动的应用包名
                    //Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);
                    //这句话必须加上才能开机自动运行app的界面
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    //2.如果自启动Activity
                    context.startActivity(intent);
                    //3.如果自启动服务
                    //context.startService(newIntent);
                case Intent.ACTION_BATTERY_CHANGED://电量发生改变
//                    aigcSpeech.say("电量发生改变");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_CHANGED");
                    break;
                case Intent.ACTION_BATTERY_LOW://电量低
//                    aigcSpeech.say("电量低");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_LOW");
                    break;
                case Intent.ACTION_BATTERY_OKAY://电量充满
//                    aigcSpeech.say("电量充满");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_OKAY");
                    break;
                case Intent.ACTION_POWER_CONNECTED://接通电源
//                    aigcSpeech.say("接通电源");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_POWER_CONNECTED");
                    break;
                case Intent.ACTION_POWER_DISCONNECTED://拔出电源
//                    aigcSpeech.say("拔出电源");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_POWER_DISCONNECTED");
                    break;
                case DownloadManager.ACTION_DOWNLOAD_COMPLETE:
//                    aigcSpeech.say("文件下载完成");
                    long id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0);
                    cache.setDownloadCache(id);
//                    Log.d(TAG, "文件下载：" + id);
                    break;
                case Intent.ACTION_CLOSE_SYSTEM_DIALOGS:
                    // 监听home键
//                    String reason = intent.getStringExtra(SYSTEM_REASON);
                    Log.d(TAG, "Home");
                    // 表示按了home键,程序到了后台
                    break;
                case BluetoothDevice.ACTION_ACL_CONNECTED:
                    Log.d(TAG, "Bluetooth connected");
                    break;
                case BluetoothDevice.ACTION_ACL_DISCONNECTED:
                    Log.d(TAG, "Bluetooth disconnected");
                    break;
                case "main.screen":
                    context.startActivity(new Intent(context, MainActivity.class).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
                    break;
            }
        } catch (Exception e) {
            Log.d(TAG, e.toString());
        }

    }
}
			]]>
			</programlisting>
		</section>
		
	</section>
	
	<section id="broadcast.user">
		<title>自定义用户消息广播</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private TextView textView;
    private MyBroadcastReceiver myBroadcastReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        intentFilter = new IntentFilter();
        intentFilter.addAction("cn.netkiller.broadcast.MESSAGE");
        myBroadcastReceiver = new MyBroadcastReceiver();
        //注册广播接收器
        registerReceiver(myBroadcastReceiver, intentFilter);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //把要发送的广播值传入Intent对象
                Intent intent = new Intent("cn.netkiller.broadcast.MESSAGE");
                intent.putExtra("msg", "Helloworld");
                //调用Context的 sendBroadcast()方法发送广播
                sendBroadcast(intent);
                textView.setText("Send");

            }
        });
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销动态的广播接收器
        unregisterReceiver(myBroadcastReceiver);
    }

    //自定义内部类，继承 BroadcastReceiver
    public class MyBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {

            String data = intent.getStringExtra("msg");
            Toast.makeText(context, data, Toast.LENGTH_SHORT).show();

        }
    }
}		
		]]>
		</programlisting>
	</section>
	<section id="broadcast.local">
		<title>本地广播</title>
		<para>注意：LocalBroadcastManager 已经被废弃</para>
		<para>上面讲的系统广播是全局的，任何APP都能接收到你的广播，这样就很容易引起APP的安全性问题。很多时候我们只想接收来自本应用程序发出的广播。
		</para>
		<programlisting>
		<![CDATA[
package cn.netkiller.broadcast;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.support.v4.content.LocalBroadcastManager;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

public class MainActivity extends AppCompatActivity {

    private TextView textView;
    private IntentFilter intentFilter;
    private LocalBroadcastManager localBroadcastManager;
    private MyBroadcastReceiver myBroadcastReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //获取LocalBroadcastManger 单li实例
        localBroadcastManager = localBroadcastManager.getInstance(this);

        intentFilter = new IntentFilter();
        intentFilter.addAction("cn.netkiller.broadcast.MESSAGE");
        myBroadcastReceiver = new MyBroadcastReceiver();
        //注册本地广播接收器
        localBroadcastManager.registerReceiver(myBroadcastReceiver, intentFilter);

        textView = (TextView) findViewById(R.id.textView);

        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                textView.setText("Send");

                Intent intent = new Intent();
                intent.setAction("cn.netkiller.broadcast.MESSAGE");
                intent.putExtra("msg", "http://www.netkiller.cn");
                //发送本地广播
                localBroadcastManager.sendBroadcast(intent);
            }
        });
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销本地广播接收器
        localBroadcastManager.unregisterReceiver(myBroadcastReceiver);
    }

    //自定义内部类，继承 BroadcastReceiver
    public class MyBroadcastReceiver extends BroadcastReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {

            String data = intent.getStringExtra("msg");
            Toast.makeText(context, data, Toast.LENGTH_SHORT).show();

        }
    }
}
		
		]]>
		</programlisting>
	</section>
	<section id="动态监听广播">
		<title>动态监听广播</title>
		<programlisting>
		<![CDATA[
	private void broadcast(final long Id) {
 
		// 注册广播监听系统的下载完成事件。
		IntentFilter intentFilter = new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE);
		broadcastReceiver = new BroadcastReceiver() {
			@Override
			public void onReceive(Context context, Intent intent) {
				long ID = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, -1);
				if (ID == Id) {
					Toast.makeText(getApplicationContext(), "任务:" + Id + " 下载完成!", Toast.LENGTH_LONG).show();
				}
			}
		};
 
		registerReceiver(broadcastReceiver, intentFilter);
	}		
		]]>
		</programlisting>
		<para>Kotlin 例子</para>
		<programlisting>
		<![CDATA[
	private val bluetoothBroadcastReceiver: BroadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            Log.d(TAG, "bluetoothBroadcastReceiver Action: " + action)
            val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)
            when (action) {

                BluetoothDevice.ACTION_ACL_CONNECTED -> {
                    device?.let {
                        Toast.makeText(context, "蓝牙已连接: ${it.name}", Toast.LENGTH_SHORT).show()
                    }
//                    if(会议开始){
                    startMeeting()
//                    }

                    Log.d(TAG, "bluetoothBroadcastReceiver startMeeting")
                }

                BluetoothDevice.ACTION_ACL_DISCONNECTED -> {
                    device?.let {
                        Toast.makeText(context, "蓝牙已断开: ${it.name}", Toast.LENGTH_SHORT).show()
                    }
                    closeMeeting()
                    Log.d(TAG, "bluetoothBroadcastReceiver closeMeeting")
                }


//                BluetoothAdapter.ACTION_STATE_CHANGED -> {
//                    val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)
//                    when (state) {
//                        BluetoothAdapter.STATE_ON -> {
//                            Log.d(TAG, "蓝牙已开启")
//                            BlueManager.startScan()
//                        }
//
//                        BluetoothAdapter.STATE_OFF -> {
//                            Log.d(TAG, "蓝牙已关闭")
//                        }
//                    }
//                }
            }

        }
    }		
	private fun broadcast() {

 		val filter = IntentFilter()
        filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED)
        filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED)
        filter.addAction(BluetoothDevice.ACTION_FOUND)
        filter.addAction(BluetoothAdapter.ACTION_CONNECTION_STATE_CHANGED)
        activity?.registerReceiver(bluetoothBroadcastReceiver, filter)
 
	}		
		]]>
		</programlisting>
	</section>
	<section id="广播重复接收">
		<title>广播重复接收</title>
		<para>广播重复接收，解决方案，编辑 AndroidManifest.xml 文件，在所有 activity 中加入
			singleTask
		</para>
		<programlisting>
		<![CDATA[
android:launchMode="singleTask"		
		]]>
		</programlisting>
	</section>
	<section id="指定静态广播接收者">
		<title>指定静态广播接收者</title>
		<para>系统中注册了多个广播，需要发送给指定接收者。</para>
		<programlisting>
		<![CDATA[
    private void broadcastStory(String id, String image, String story) {
        Intent intent = new Intent();
        intent.setAction("story");
        intent.putExtra("id", id);
        intent.putExtra("image", image);
        intent.putExtra("story", story);
        intent.setClassName(context.getPackageName(), MainBroadcastReceiver.class.getName());
        context.sendBroadcast(intent);
    }

    private void broadcastShare(String id, String image, String story) {
        Intent intent = new Intent();
        intent.setAction("share");
        intent.putExtra("id", id);
        intent.putExtra("image", image);
        intent.putExtra("story", story);
        intent.setClassName(context.getPackageName(), ShareBroadcastReceiver.class.getName());
        context.sendBroadcast(intent);
    }
		]]>
		</programlisting>
	</section>
	<section id="异步执行广播">
		<title>异步执行广播</title>
		<programlisting>
		<![CDATA[
public class MyBroadcastReceiver extends BroadcastReceiver {
        private static final String TAG = "MyBroadcastReceiver";

        @Override
        public void onReceive(Context context, Intent intent) {
            final PendingResult pendingResult = goAsync();
            Task asyncTask = new Task(pendingResult, intent);
            asyncTask.execute();
        }

        private static class Task extends AsyncTask<String, Integer, String> {

            private final PendingResult pendingResult;
            private final Intent intent;

            private Task(PendingResult pendingResult, Intent intent) {
                this.pendingResult = pendingResult;
                this.intent = intent;
            }

            @Override
            protected String doInBackground(String... strings) {
                StringBuilder sb = new StringBuilder();
                sb.append("Action: " + intent.getAction() + "\n");
                sb.append("URI: " + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + "\n");
                String log = sb.toString();
                Log.d(TAG, log);
                return log;
            }

            @Override
            protected void onPostExecute(String s) {
                super.onPostExecute(s);
                // Must call finish() so the BroadcastReceiver can be recycled.
                pendingResult.finish();
            }
        }
    }		
		]]>
		</programlisting>
	</section>
	<section id="静态广播接收不到信息">
		<title>静态广播接收不到信息</title>
		<para>StaticBroadcastReceiver 接收不到消息</para>
		<programlisting>
		<![CDATA[
 		<receiver
            android:name=".receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.ACTION_BATTERY_CHANGED" />
                <action android:name="android.intent.action.ACTION_BATTERY_LOW" />
                <action android:name="android.intent.action.ACTION_BATTERY_OKAY" />
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
                <action android:name="android.intent.action.ACTION_DOWNLOAD_COMPLETE" />
                <action android:name="main.story" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>		
		]]>
		</programlisting>
		<para>解决系统广播 android.intent.action.ACTION_DOWNLOAD_COMPLETE 接收不到问题，经过调试发现 android.intent.action.ACTION_DOWNLOAD_COMPLETE 的值是 android.intent.action.DOWNLOAD_COMPLETE，所以我们要订阅 android.intent.action.DOWNLOAD_COMPLETE。</para>
		<programlisting>
		<![CDATA[
        <receiver
            android:name=".receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.ACTION_BATTERY_CHANGED" />
                <action android:name="android.intent.action.ACTION_BATTERY_LOW" />
                <action android:name="android.intent.action.ACTION_BATTERY_OKAY" />
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
                <action android:name="android.intent.action.DOWNLOAD_COMPLETE" />
                <action android:name="main.story" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>		
		]]>
		</programlisting>
		<para>解决 main.story 自定义广播接收不到的问题，解决方法设置包 setPackage 即可</para>
		<programlisting>
		<![CDATA[
intent.setPackage(context.getPackageName());
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
	public static void broadcastStoryPageable(Integer page, String image, String audio, String story) {
        Context context = ContextHolder.getContext();
        Intent intent = new Intent();
        intent.setAction("main.story");
        intent.putExtra("page", page);
        intent.putExtra("image", image);
        intent.putExtra("audio", audio);
        intent.putExtra("story", story);
        intent.setPackage(context.getPackageName());
        context.sendBroadcast(intent);
    }
		]]>
		</programlisting>
	</section>
	<section id="接受蓝牙广播">
		<title>接受蓝牙广播</title>
		<para>设置 filter</para>
		<programlisting>
		<![CDATA[
		<receiver
            android:name="com.netkiller.conference.receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">
                <action android:name="android.intent.action.BOOT_COMPLETED" />
                <action android:name="android.intent.action.ACTION_BATTERY_CHANGED" />
                <action android:name="android.intent.action.ACTION_BATTERY_LOW" />
                <action android:name="android.intent.action.ACTION_BATTERY_OKAY" />
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
                <action android:name="android.intent.action.DOWNLOAD_COMPLETE" />
                <action android:name="android.intent.action.ACTION_CLOSE_SYSTEM_DIALOGS" />
                <action android:name="android.bluetooth.device.action.ACL_CONNECTED" />
                <action android:name="android.bluetooth.device.action.ACL_DISCONNECTED" />
                <action android:name="android.bluetooth.device.action.STATE_CHANGED" />
                <action android:name="android.bluetooth.device.action.BOND_STATE_CHANGED" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>
		]]>
		</programlisting>
		<para>处理蓝牙事件</para>
		<programlisting>
		<![CDATA[
package com.netkiller.conference.receiver

import android.app.DownloadManager
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.util.Log
import android.widget.Toast
import com.netkiller.conference.ai.aigc.AigcSpeech

class StaticBroadcastReceiver : BroadcastReceiver() {
    //    private val cache = Cache()
    private val aigcSpeech: AigcSpeech = AigcSpeech.getInstance()
    private val TAG: String = StaticBroadcastReceiver::class.java.simpleName

    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        Log.d(TAG, "Static broadcast Action: " + action)
        val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)

        try {
            when (action) {
                Intent.ACTION_BOOT_COMPLETED -> {
                    Log.d(TAG, "自启动了 ！！！！！")
//                    intent = Intent(context, MainActivity::class.java) // 要启动的Activity
//                    //1.如果自启动APP，参数为需要自动启动的应用包名
//                    //Intent intent = getPackageManager().getLaunchIntentForPackage(packageName);
//                    //这句话必须加上才能开机自动运行app的界面
//                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
//                    //2.如果自启动Activity
//                    context.startActivity(intent)
                    //                    aigcSpeech.say("电量发生改变");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_CHANGED")
                }

                Intent.ACTION_BATTERY_CHANGED ->
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_CHANGED")

                Intent.ACTION_BATTERY_LOW -> //                    aigcSpeech.say("电量低");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_LOW")

                Intent.ACTION_BATTERY_OKAY -> //                    aigcSpeech.say("电量充满");
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_BATTERY_OKAY")

                Intent.ACTION_POWER_CONNECTED -> {
                    aigcSpeech.speaking("接通电源")
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_POWER_CONNECTED")
                }

                Intent.ACTION_POWER_DISCONNECTED -> {
                    aigcSpeech.speaking("拔出电源")
                    Log.e(TAG, "BatteryBroadcastReceiver --> ACTION_POWER_DISCONNECTED")
                }

                DownloadManager.ACTION_DOWNLOAD_COMPLETE -> {
                    //                    aigcSpeech.say("文件下载完成");
                    val id = intent.getLongExtra(DownloadManager.EXTRA_DOWNLOAD_ID, 0)
//                    cache.setDownloadCache(id)
                }

//                Intent.ACTION_CLOSE_SYSTEM_DIALOGS ->                     // 监听home键
////                    String reason = intent.getStringExtra(SYSTEM_REASON);
//                    Log.d(TAG, "Home")

                BluetoothDevice.ACTION_ACL_CONNECTED -> {
                    device?.let {
                        Toast.makeText(context, "蓝牙已连接: ${it.name}", Toast.LENGTH_SHORT).show()
                    }
                    aigcSpeech.speaking("蓝牙麦克风连接")
                    Log.d(TAG, "Bluetooth connected")
                }

                BluetoothDevice.ACTION_ACL_DISCONNECTED -> {
                    device?.let {
                        Toast.makeText(context, "蓝牙已断开: ${it.name}", Toast.LENGTH_SHORT).show()
                    }
                    aigcSpeech.speaking("蓝牙麦克风断开")
                    Log.d(TAG, "Bluetooth disconnected")
                }

                BluetoothDevice.ACTION_BOND_STATE_CHANGED -> {
                    val state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.ERROR)
                    val previousState = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.ERROR)

                    if (state == BluetoothDevice.BOND_BONDED) {
                        Toast.makeText(context, "设备已配对", Toast.LENGTH_SHORT).show()
                    } else if (state == BluetoothDevice.BOND_NONE) {
                        Toast.makeText(context, "设备取消配对", Toast.LENGTH_SHORT).show()
                    }
                }

                BluetoothAdapter.ACTION_STATE_CHANGED -> {
                    val state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR)
                    when (state) {
                        BluetoothAdapter.STATE_ON -> Log.d(TAG, "蓝牙已开启")
                        BluetoothAdapter.STATE_OFF -> Log.d(TAG, "蓝牙已关闭")
                    }
                }

//                "main.screen" -> context.startActivity(Intent(context, MainActivity::class.java).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK))
            }
        } catch (e: Exception) {
            Log.d(TAG, e.toString())
        }
    }


}
		]]>
		</programlisting>
		<para>解决 main.story 自定义广播接收不到的问题，解决方法设置包 setPackage 即可</para>
		<programlisting>
		<![CDATA[
intent.setPackage(context.getPackageName());
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
	public static void broadcastStoryPageable(Integer page, String image, String audio, String story) {
        Context context = ContextHolder.getContext();
        Intent intent = new Intent();
        intent.setAction("main.story");
        intent.putExtra("page", page);
        intent.putExtra("image", image);
        intent.putExtra("audio", audio);
        intent.putExtra("story", story);
        intent.setPackage(context.getPackageName());
        context.sendBroadcast(intent);
    }
		]]>
		</programlisting>
	</section>
	<section id="broadcast.usb">
		<title>接收 USB 设备广播</title>
		<programlisting>
		<![CDATA[
private final BroadcastReceiver usbReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action)) {
            // 设备连接
        } else if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
            // 设备断开
        }
    }
};

// 注册receiver
IntentFilter filter = new IntentFilter();
filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);
filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
registerReceiver(usbReceiver, filter);		
		]]>
		</programlisting>
		<section>
			<title></title>
			<programlisting>
			<![CDATA[
package com.netkiller.conference.receiver

import android.Manifest
import android.app.DownloadManager
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.usb.UsbManager
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.net.wifi.WifiInfo
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.telephony.TelephonyManager
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import com.blankj.utilcode.util.Utils


class StaticBroadcastReceiver : BroadcastReceiver() {
    //    private val cache = Cache()
    private val aigcSpeech: AigcSpeech = AigcSpeech.getInstance()
    private val TAG: String = StaticBroadcastReceiver::class.java.simpleName

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        Log.d(TAG, "Static broadcast Action: " + action)
        val device = intent.getParcelableExtra<BluetoothDevice>(BluetoothDevice.EXTRA_DEVICE)
//        var device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE, BluetoothDevice::class.java)

        try {
            when (action) {

                UsbManager.ACTION_USB_DEVICE_ATTACHED -> {
                    if (AndroidManager.Device.usbAudio(context)) {
                        AndroidManager.Device.scanMicrophone()
                        aigcSpeech.speaking("USB麦克风连接")
                    }
                }

                UsbManager.ACTION_USB_DEVICE_DETACHED -> {
                    AndroidManager.Device.resetMicrophone()
                    aigcSpeech.speaking("USB麦克风断开")
                    Handler(Looper.getMainLooper()).postDelayed({
                        if (AndroidManager.Device.scanMicrophone()) {
                            aigcSpeech.speaking("切换到蓝牙麦克风")
                        }
                        Log.d(TAG, "Bluetooth connected")
                    }, 1000)
                }

            }

        } catch (e: Exception) {
            Log.d(TAG, e.toString())
        }
    }


}			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="broadcast.wifi">
		<title>Wifi 广播</title>
		<programlisting>
		<![CDATA[
		<receiver
            android:name="com.netkiller.conference.receiver.StaticBroadcastReceiver"
            android:enabled="true"
            android:exported="true">
            <intent-filter android:priority="1000">

                <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
                <action android:name="android.net.wifi.WIFI_STATE_CHANGED" />
                <action android:name="android.net.wifi.STATE_CHANGE" />

                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </receiver>		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
package com.netkiller.conference.receiver

import android.Manifest
import android.app.DownloadManager
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.usb.UsbManager
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.net.wifi.WifiInfo
import android.net.wifi.WifiManager
import android.os.Build
import android.os.Handler
import android.os.Looper
import android.telephony.TelephonyManager
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.app.ActivityCompat
import com.blankj.utilcode.util.Utils
import com.netkiller.conference.ai.State
import com.netkiller.conference.ai.aigc.AigcSpeech
import com.netkiller.conference.bluetooth.BlueManager
import com.netkiller.conference.utils.AndroidManager


class StaticBroadcastReceiver : BroadcastReceiver() {
    //    private val cache = Cache()
    private val aigcSpeech: AigcSpeech = AigcSpeech.getInstance()
    private val TAG: String = StaticBroadcastReceiver::class.java.simpleName

    @RequiresApi(Build.VERSION_CODES.TIRAMISU)
    override fun onReceive(context: Context, intent: Intent) {
        val action = intent.action
        Log.d(TAG, "Static broadcast Action: " + action)

        try {
            when (action) {

                WifiManager.WIFI_STATE_CHANGED_ACTION -> {
                    // 监听wifi的打开与关闭，与wifi的连接无关
                    var wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, 0)
                    Log.e(TAG, "wifiState:" + wifiState)

                    when (wifiState) {
                        WifiManager.WIFI_STATE_ENABLED -> Log.d(TAG, "WiFi 已启用")
                        WifiManager.WIFI_STATE_DISABLED -> Log.d(TAG, "WiFi 已禁用")
                        WifiManager.WIFI_STATE_ENABLING -> Log.d(TAG, "WiFi 正在启用")
                        WifiManager.WIFI_STATE_DISABLING -> Log.d(TAG, "WiFi 正在禁用")
                        WifiManager.WIFI_STATE_UNKNOWN -> Log.d(TAG, "WiFi 状态未知")
                    }
                }

                WifiManager.NETWORK_STATE_CHANGED_ACTION -> {
                    var wifiManager = context.getSystemService(Context.WIFI_SERVICE) as WifiManager
                    val networkInfo: NetworkInfo? = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO)
                    if (networkInfo != null) {
                        if (networkInfo.isConnected) {
                            val wifiInfo: WifiInfo = wifiManager.connectionInfo
                            val ssid = wifiInfo.ssid
                            val rssi = wifiInfo.rssi
                            val linkSpeed = wifiInfo.linkSpeed
                            Log.d(TAG, "已连接到 WiFi: $ssid")
                            Log.d(TAG, "信号强度: $rssi dBm")
                            Log.d(TAG, "连接速度: $linkSpeed Mbps")
                        } else {
                            Log.d(TAG, "已断开 WiFi 连接")
                        }
                    }

                }

                ConnectivityManager.CONNECTIVITY_ACTION -> {
                    // 监听wifi的连接状态即是否连上了一个有效无线路由
                    var connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
                    var activeNetwork = connectivityManager.activeNetworkInfo
                    var isWiFiConnected = activeNetwork != null &&
                            activeNetwork.type == ConnectivityManager.TYPE_WIFI &&
                            activeNetwork.isConnected

                    if (isWiFiConnected) {
                        Log.d(TAG, "WiFi 已连接且可用")
                    } else {
                        Log.d(TAG, "WiFi 不可用")
                    }
                }


            }

        } catch (e: Exception) {
            Log.d(TAG, e.toString())
        }
    }

}		
		]]>
		</programlisting>
	</section>
	<section id="LiveDataBus">
		<title>LiveDataBus - 官方 AndroidX jetpack</title>
		
	</section>
</chapter>