<chapter id="index"><?dbhtml dir="concurrent" ?>
	<title>Java 并发编程</title>
	<para>包位置 java.util.concurrent</para>
	<section id="TimeUnit">
		<title>TimeUnit</title>
		<programlisting>
		<![CDATA[
	try {
		TimeUnit.SECONDS.sleep(5);
	} catch (InterruptedException e) {
	}		
		]]>
		</programlisting>
	</section>
	<section id="AtomicInteger">
		<title>AtomicInteger / AtomicLong / AtomicBoolean</title>
		<programlisting>
		<![CDATA[
AtomicInteger sequence = new AtomicInteger(1);
sequence.getAndIncrement(); // 加1操作
		]]>
		</programlisting>
	</section>
	<section id="AtomicReference">
		<title>AtomicReference</title>
		<programlisting>
		<![CDATA[
private static AtomicReference<BankCard> bankCardRef = new AtomicReference<>(new BankCard("Neo",100));		
		]]>
		</programlisting>
	</section>
	<section id="ConcurrentHashMap">
		<title>线程安全的 HashMap(ConcurrentHashMap)</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.test;

import java.util.concurrent.ConcurrentHashMap;

public class Test {
    private final ConcurrentHashMap<String, Boolean> isComplated = new ConcurrentHashMap<String, Boolean>();

    public static void main(String[] args) {
        Test test = new Test();
        test.isComplated.putIfAbsent("create", true);
        test.isComplated.putIfAbsent("story", false);
        test.isComplated.putIfAbsent("picture", true);

        boolean isDone = test.isComplated.values().stream().allMatch(status -> status);
        System.out.println(test.isComplated);
        System.out.println(isDone);

        test.isComplated.put("story", true);
        isDone = test.isComplated.values().stream().allMatch(status -> status);
        System.out.println(test.isComplated);
        System.out.println(isDone);
    }
}
		]]>
		</programlisting>
		<section>
			<title>设置键与值</title>
			<para>putIfAbsent 当 key 不存在时可以设置值</para>
			<programlisting>
			<![CDATA[
test.isComplated.putIfAbsent("create", true);	
			]]>
			</programlisting>
			<para>put 可以覆盖已存在的值</para>
			<programlisting>
		<![CDATA[
test.isComplated.put("story", true);
		]]>
			</programlisting>
		</section>
	</section>
	<section id="ArrayBlockingQueue">
		<title>ArrayBlockingQueue</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.test;

import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class QueueTest {
	/**
	 * 定义装苹果的篮子
	 */
	public static class Basket {
		// 篮子，能够容纳10个苹果
		BlockingQueue<String> basket = new ArrayBlockingQueue<String>(10);

		// 生产苹果，放入篮子
		public void produce() throws InterruptedException {
			// put方法放入一个苹果，若basket满了，等到basket有位置
			basket.put("An apple");
		}

		// 消费苹果，从篮子中取走
		public String consume() throws InterruptedException {
			// get方法取出一个苹果，若basket为空，等到basket有苹果为止
			return basket.take();
		}

		public int size() {
			return basket.size();
		}

	}

	// 测试方法
	public static void testBasket() throws InterruptedException {
		// 建立一个装苹果的篮子
		final Basket basket = new Basket();
		// 定义苹果生产者
		class Producer implements Runnable {
			public void run() {
				try {
					while (true) {
						int n = random(1, 5);
						for (int i = 0; i < n; i++) {
							basket.produce();
						}
						System.out.println(System.currentTimeMillis() + " 放入" + n + "个，当前总数：" + basket.size() + "个");
						Thread.sleep(random(450, 1000));
					}
				} catch (InterruptedException ex) {
				}
			}
		}
		// 定义苹果消费者
		class Consumer implements Runnable {
			public void run() {
				try {
					while (true) {
						// 消费苹果
						int n = random(1, 5);
						for (int i = 0; i < n; i++) {
							basket.consume();
						}
						System.out.println(System.currentTimeMillis() + " 取出" + n + "个，剩余数量：" + basket.size() + "个");
						Thread.sleep(random(400, 1000));
					}
				} catch (InterruptedException ex) {
				}
			}
		}

		ExecutorService service = Executors.newCachedThreadPool();
		Producer producer = new Producer();
		Consumer consumer = new Consumer();
		service.submit(producer);
		// 延迟消费
		Thread.sleep(5000);
		service.submit(consumer);
		// 程序运行10s后，所有任务停止
		try {
			Thread.sleep(20000);
		} catch (InterruptedException e) {
		}
		service.shutdownNow();
	}

	public static int random(int min, int max) {
		var value = new Random().ints(min, (max + 1)).limit(1).findFirst().getAsInt();
		return value;
	}

	public static void main(String[] args) throws InterruptedException {
		QueueTest.testBasket();
	}
}

		]]>
		</programlisting>
	</section>
	<section id="Future">
		<title>Future</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.test;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class Test {

    private final ExecutorService executor = Executors.newSingleThreadExecutor();

    public Future<Integer> calculate(Integer input) {
        return executor.submit(() -> {
            System.out.println("Calculating..." + input);
            Thread.sleep(1000);
            return input * input;
        });
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {

        Test test = new Test();
        Future<Integer> future = test.calculate(12);
        Integer value = future.get();

        System.out.println(value);
    }
}
		
		]]>
		</programlisting>
		<para>设置超时时间</para>
		<programlisting>
		<![CDATA[
value = future.get(500, TimeUnit.MILLISECONDS);
		]]>
		</programlisting>
		<para>设置超时时间</para>
		<programlisting>
		<![CDATA[
value = future.get(500, TimeUnit.MILLISECONDS);
		]]>
		</programlisting>
		<para>取消运行</para>
		<programlisting>
		<![CDATA[
boolean canceled = future.cancel(true);
		]]>
		</programlisting>
		<para>判断是否完成</para>
		<programlisting>
		<![CDATA[
while(!future.isDone()) {
    System.out.println("Calculating...");
    Thread.sleep(300);
}		
		]]>
		</programlisting>
		<section>
			<title>Future + Stream 管理一组线程</title>
			<programlisting>
			<![CDATA[
		ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future1 = executor.submit(() -> "AAA");
        Future<String> future2 = executor.submit(() -> "BBB");
        Future<String> future3 = executor.submit(() -> "CCC");

        Stream<String> stream = Stream.of(future1, future2, future3)
                .map(func -> {
//                    System.out.println(Thread.currentThread().getName());
                    try {
                        return func.get(5L, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    } catch (ExecutionException e) {
                        throw new RuntimeException(e);
                    } catch (TimeoutException e) {
                        throw new RuntimeException(e);
                    }

                }).filter(Objects::nonNull);
        stream.forEach(System.out::println);			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="FutureTask">
		<title>FutureTask</title>
		<programlisting>
	<![CDATA[
package cn.netkiller.welcome;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class Future {

	public static void main(String[] args) throws InterruptedException, ExecutionException {
		// TODO Auto-generated method stub
		FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
			@Override
			public String call() throws Exception {
				String status = null;
				System.out.println(Thread.currentThread().getName() + ":" + "Send SMS ...");
				Thread.sleep(2000);
				System.out.println(Thread.currentThread().getName() + ":" + "Sent");
				status = "OK";
				return status;
			}
		});

//		开启了一个线程执行future的逻辑
		Thread thread = new Thread(futureTask);
		thread.start();

		// 主业务逻辑
		System.out.println(Thread.currentThread().getName() + ":" + "Begin");
		Thread.sleep(3000);
		System.out.println(Thread.currentThread().getName() + ":" + "End");

		String sent = futureTask.get();

		System.out.println(Thread.currentThread().getName() + ":" + "Status：" + sent + " done!");
	}

}
	
	]]>
		</programlisting>
	</section>

	<section id="CompletableFuture">
		<title>CompletableFuture</title>
		<section id="runAsync">
			<title>runAsync 创建没有返回值的异步任务</title>
			<para>runAsync
				创建没有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是自定义线程池的重载方法
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture.runAsync(() -> {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ExecutorService executorService = Executors.newSingleThreadExecutor();
        CompletableFuture.runAsync(() -> {
            System.out.println("do something...");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }, executorService);

        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
            System.out.println("do something....");
//            Thread.currentThread().setName("测试有返回值的异步执行");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());

        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("Result ->" + completableFuture.isDone());


    }
}
			]]>
			</programlisting>
			<para></para>
			<screen>
			<![CDATA[
do something...
do something...
do something....

=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
|   22 |                  pool-1-thread-1 |  main |  false | TIMED_WAITING |        5 |
|   23 | ForkJoinPool.commonPool-worker-2 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================

Result ->true
			]]>
			</screen>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicInteger;

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread());

        AtomicInteger variable = new AtomicInteger(0);
        CompletableFuture<Void> runAsync = CompletableFuture.runAsync(() -> process(variable));
        runAsync.join();
        System.out.println(variable.get());

    }

    public static void process(AtomicInteger variable) {
        System.out.println(Thread.currentThread().getName() + " Process...");
        variable.set(1024);
    }
}
			]]>
			</programlisting>
		</section>
		<section id="supplyAsync">
			<title>supplyAsync 创建带有返回值的异步任务。</title>
			<para>supplyAsync
				创建带有返回值的异步任务。它有如下两个方法，一个是使用默认线程池（ForkJoinPool.commonPool()）的方法，一个是带有自定义线程池的重载方法
			</para>
			<screen>
			<![CDATA[
// 带返回值异步请求，默认线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
 
// 带返回值的异步请求，可以自定义线程池
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)			
			]]>
			</screen>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            return "done";
        });

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
=======================================================================================
|   ID |                             Name | Group | Daemon |         State | Priority |
---------------------------------------------------------------------------------------
|    1 |                             main |  main |  false |      RUNNABLE |        5 |
|   21 | ForkJoinPool.commonPool-worker-1 |  main |   true | TIMED_WAITING |        5 |
=======================================================================================		
			]]>
			</screen>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {


        ExecutorService executorService = Executors.newSingleThreadExecutor();

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            try {
                Thread.sleep(30000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "done";
        }, executorService);

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
======================================================================
|   ID |            Name | Group | Daemon |         State | Priority |
----------------------------------------------------------------------
|    1 |            main |  main |  false |      RUNNABLE |        5 |
|   21 | pool-1-thread-1 |  main |  false |       WAITING |        5 |
======================================================================			
			]]>
			</screen>
			<para>设置线程名称</para>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import cn.netkiller.thread.ThreadManager;
import lombok.SneakyThrows;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Main {
    @SneakyThrows
    public static void main(String[] args) {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("do something....");
            Thread.currentThread().setName("测试有返回值的异步执行");
            return "done";
        });

        System.out.println("Result ->" + completableFuture.get());

        ThreadManager tm = new ThreadManager();
        System.out.println(tm.show());
    }
}			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
do something....
Result ->done
==================================================================
|   ID |        Name | Group | Daemon |         State | Priority |
------------------------------------------------------------------
|    1 |        main |  main |  false |      RUNNABLE |        5 |
|   21 | 测试有返回值的异步执行 |  main |   true | TIMED_WAITING | 5 |
==================================================================	
			]]>
			</screen>
		</section>
		<section id="get">
			<title>获取结果</title>
			<programlisting>
			<![CDATA[
        CompletableFuture<String> completableFuture = CompletableFuture.completedFuture("Hello netkiller");
        if (completableFuture.isDone()) {
            System.out.println(completableFuture.get());
        }			
			]]>
			</programlisting>
			<para>Spring Service 用法</para>
			<programlisting>
			<![CDATA[
@Service
public class MyService {

    @Async
    public CompletableFuture<String> asyncMethod() {
        // 异步方法逻辑...
        return CompletableFuture.completedFuture("Result");
    }
}

// 调用异步方法并获取结果
CompletableFuture<String> future = myService.asyncMethod();
String result = future.get(); // 阻塞等待结果			
			]]>
			</programlisting>
		</section>
		<section id="thenRun / thenRunAsync">
			<title>thenRun / thenRunAsync</title>
			<para>thenRun/thenRunAsync 功能是什么？完成前置任务之后，自己在执行。</para>
			<para>thenRun/thenRunAsync 区别是什么？thenRun 使用同一个线程执行任务，thenRunAsync
				会再开一个新线程执行任务。
			</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureRun")
    public String completableFutureRun() {
        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {
            System.out.println(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        CompletableFuture thenRun = completableFuture.thenRun(() -> {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRun 任务");
        });
        CompletableFuture thenRunAsync = completableFuture.thenRunAsync(() -> {
            System.out.println(Thread.currentThread().getName() + " - 接着执行第二个 thenRunAsync 任务");
        });
        return "Done";
    }			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenRun 任务
ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenRunAsync 任务
			]]>
			</screen>
			<para>这里可以看到 thenRunAsync 的线程变化，开启新线程
				ForkJoinPool.commonPool-worker-2 处理任务
			</para>
		</section>
		<section id="thenAccept / thenAcceptAsync">
			<title>thenAccept / thenAcceptAsync</title>
			<para>thenAccept/thenAcceptAsync 的功能是，前置任务执行完毕之后，将返回值给到
				thenAccept/thenAcceptAsync，再执行接下来的任务。
			</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureAccept")
    public String completableFutureAccept() {
        CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "前置任务执行完成";
        });
        CompletableFuture<Void> thenAccept = supplyAsync.thenAccept((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAccept 任务");
            log.info("前置任务返回值：" + rev);
        });
        CompletableFuture<Void> thenAcceptAsync = supplyAsync.thenAcceptAsync((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenAcceptAsync 任务");
            log.info("前置任务返回值：" + rev);
        });
        return "Done";
    }			
			]]>
			</programlisting>
			<para>输出结果</para>
			<screen>
			<![CDATA[
2023-05-10T10:38:48.008+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - CompletableFuture 前置任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenAcceptAsync 任务
2023-05-10T10:38:53.015+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-1 - 接着执行第二个 thenAccept 任务
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成
2023-05-10T10:38:53.016+08:00  INFO 96282 --- [onPool-worker-1] c.n.c.test.TestThreadController          : 前置任务返回值：前置任务执行完成			
			]]>
			</screen>
		</section>
		<section id="Apply">
			<title>thenApply / thenApplyAsync</title>
			<para>thenApply/thenApplyAsync
				前置任务执行完毕之后，结果作为入参，thenApply/thenApplyAsync 执行完毕之后再返回执行结果
			</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureApply")
    public String completableFutureApply() throws ExecutionException, InterruptedException {
        CompletableFuture<String> supplyAsync = CompletableFuture.supplyAsync(() -> {
            log.info(Thread.currentThread().getName() + " - CompletableFuture 前置任务");
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return "第一步";
        });

        CompletableFuture<String> thenApply = supplyAsync.thenApply((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApply 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });

        CompletableFuture<String> thenApplyAsync = supplyAsync.thenApplyAsync((rev) -> {
            log.info(Thread.currentThread().getName() + " - 接着执行第二个 thenApplyAsync 任务");
            log.info("前置任务返回值：" + rev);
            return "第二步";
        });
        log.info("supplyAsync：{}", supplyAsync.get());
        log.info("thenApply：{}", thenApply.get());
        log.info("thenApplyAsync：{}", thenApplyAsync.get());
        return "Done";
    }			
			]]>
			</programlisting>
			<para></para>
			<screen>
			<![CDATA[
2023-05-10T10:39:57.913+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - CompletableFuture 前置任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : XNIO-1 task-2 - 接着执行第二个 thenApply 任务
2023-05-10T10:40:02.917+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : ForkJoinPool.commonPool-worker-2 - 接着执行第二个 thenApplyAsync 任务
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [onPool-worker-2] c.n.c.test.TestThreadController          : 前置任务返回值：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : supplyAsync：第一步
2023-05-10T10:40:02.918+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApply：第二步
2023-05-10T10:40:02.919+08:00  INFO 96282 --- [  XNIO-1 task-2] c.n.c.test.TestThreadController          : thenApplyAsync：第二步
			]]>
			</screen>
		</section>
		<section id="runAsync / thenAccept / thenApply 区别">
			<title>runAsync / thenAccept / thenApply 区别</title>
			<para>runAsync 配合 thenRun/thenRunAsync 使用</para>
			<screen>
			<![CDATA[
runAsync --> thenRun/thenRunAsync 无返回值			
			]]>
			</screen>
			<para>supplyAsync 配合 thenAccept/thenAcceptAsync 使用</para>
			<screen>
			<![CDATA[
supplyAsync -- 返回值 --> thenAccept/thenAcceptAsync --> 无返回值
			]]>
			</screen>
			<para>supplyAsync 配合 thenApply/thenApplyAsync 使用</para>
			<screen>
			<![CDATA[
supplyAsync -- 返回值 --> thenApply/thenApplyAsync -- 返回值 -->			
			]]>
			</screen>
		</section>
		<section id="whenComplete">
			<title>whenComplete 任务完成时执行，并且返回结果和异常</title>
			<para>whenComplete 与 runAsync / thenAccept / thenApply 区别是能处理
				Throwable
			</para>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureWhenComplete")
    public String completableFutureWhenComplete() throws ExecutionException, InterruptedException {

        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            return "前置任务完成";
        }).whenComplete((result, throwable) -> {
            System.out.println("前置任务返回值：" + result);
        });
        System.out.println(completableFuture.get());
        return "Done";
    }			
			]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
			<![CDATA[
当前线程名称：ForkJoinPool.commonPool-worker-1
前置任务返回值：前置任务完成
前置任务完成			
			]]>
			</screen>
		</section>
		<section id="completeOnTimeout">
			<title>超时处理</title>
			<programlisting>
			<![CDATA[
		CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(5 * 1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "hello";
        });

        future.completeOnTimeout("default timeout result", 3 * 1000, TimeUnit.MILLISECONDS);			
			]]>
			</programlisting>
		</section>
		<section id="thenCompose">
			<title>按顺序执行</title>
			<programlisting>
			<![CDATA[
@Service
public class MyService {

    @Async("threadPoolTaskExecutor")
    public CompletableFuture<String> asyncMethod1() {
        // 异步方法1逻辑...
        return CompletableFuture.completedFuture("Result1");
    }

    @Async("threadPoolTaskExecutor")
    public CompletableFuture<String> asyncMethod2() {
        // 异步方法2逻辑...
        return CompletableFuture.completedFuture("Result2");
    }
}

// 调用异步方法并处理结果顺序 
CompletableFuture<String> future1 = myService.asyncMethod1(); 
CompletableFuture<String> future2 = future1.thenCompose(result1 -> myService.asyncMethod2());

String finalResult = future2.get(); // 阻塞等待最终结果	
			]]>
			</programlisting>
		</section>

		<section id="thenCombine">
			<title>thenCombine、thenAcceptBoth 和runAfterBoth</title>

			<para>thenCombine会将两个任务的执行结果作为所提供函数的参数，且该方法有返回值。</para>
			<para>thenAcceptBoth同样将两个任务的执行结果作为方法入参，但是无返回值。</para>
			<para>runAfterBoth没有入参，也没有返回值。注意两个任务中只要有一个执行异常，则将该异常信息作为指定任务的执行结果。
			</para>
			<programlisting>
			<![CDATA[
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture1 do something....");
            return 1;
        });

        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture2 do something....");
            return 2;
        });

        CompletableFuture<Integer> completableFuture3 = completableFuture1.thenCombine(completableFuture2, (a, b) -> {
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
            return a + b;
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}

 public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture1 do something....");
            return 1;
        });

        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture2 do something....");
            return 2;
        });
        
        CompletableFuture<Void> completableFuture3 = completableFuture1.thenAcceptBoth(completableFuture2, (a, b) -> {
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
            System.out.println(a + b);
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture1 do something....");
            return 1;
        });

        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread() + " completableFuture2 do something....");
            return 2;
        });

        CompletableFuture<Void> completableFuture3 = completableFuture1.runAfterBoth(completableFuture2, () -> {
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}
			]]>
			</programlisting>
		</section>
		<section id="applyToEither">
			<title>applyToEither、acceptEither和runAfterEither</title>
			<para>这三个方法和上面一样也是将两个CompletableFuture组合起来处理，当有一个任务正常完成时，就会进行下阶段任务。
			</para>
			<para>applyToEither会将已经完成任务的执行结果作为所提供函数的参数，且该方法有返回值；</para>
			<para>acceptEither同样将已经完成任务的执行结果作为方法入参，但是无返回值；</para>
			<para>runAfterEither没有入参，也没有返回值。</para>
			<programlisting>
				<![CDATA[
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "completableFuture1 任务完成";
        });

        CompletableFuture<String> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "completableFuture2 任务完成";
        });

        CompletableFuture<String> completableFuture3 = completableFuture1.applyToEither(completableFuture2, (result) -> {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
            return "completableFuture3 任务完成";
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}
public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "completableFuture1 任务完成";
        });

        CompletableFuture<String> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "completableFuture2 任务完成";
        });

        CompletableFuture<Void> completableFuture3 = completableFuture1.acceptEither(completableFuture2, (result) -> {
            System.out.println("接收到" + result);
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}

public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> completableFuture1 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture1 do something....");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("completableFuture1 任务完成");
            return "completableFuture1 任务完成";
        });

        CompletableFuture<String> completableFuture2 = CompletableFuture.supplyAsync(() -> {
            try {
                System.out.println(Thread.currentThread() + " completableFuture2 do something....");
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("completableFuture2 任务完成");
            return "completableFuture2 任务完成";
        });

        CompletableFuture<Void> completableFuture3 = completableFuture1.runAfterEither(completableFuture2, () -> {
            System.out.println(Thread.currentThread() + " completableFuture3 do something....");
            System.out.println("completableFuture3 任务完成");
        });

        System.out.println("completableFuture3结果->" + completableFuture3.get());
}
				]]>
			</programlisting>
		</section>
		<section id="allOf">
			<title>allOf / anyOf</title>
			<para>allOf：CompletableFuture是多个任务都执行完成后才会执行，只有有一个任务执行异常，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回null。
			</para>
			<programlisting>
			<![CDATA[
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "AAA").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "BBB").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> "CCC").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture.allOf(new CompletableFuture[]{future1, future2, future3}).join();			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "AAA").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "BBB").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> "CCC").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture.allOf(future1, future2, future3).join();			
			]]>
			</programlisting>
			<programlisting>
				<![CDATA[
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "AAA").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "BBB").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> "CCC").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        List<CompletableFuture<String>> completableFutures = Stream.of(future1, future2, future3).toList();
        var completableFutureArray = completableFutures.toArray(CompletableFuture[]::new);
        CompletableFuture.allOf(completableFutureArray).join();
				]]>
			</programlisting>
			<para>anyOf：CompletableFuture是多个任务只要有一个任务执行完成，则返回的CompletableFuture执行get方法时会抛出异常，如果都是正常执行，则get返回执行完成任务的结果。
			</para>

			<programlisting>
			<![CDATA[
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "AAA").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "BBB").whenComplete((value, throwable) -> {
            System.out.println(value);
        });
        CompletableFuture<String> future3 = CompletableFuture.supplyAsync(() -> "CCC").whenComplete((value, throwable) -> {
            System.out.println(value);
        });

        CompletableFuture<Object> completableFuture = CompletableFuture.anyOf(future1, future2, future3);
        System.out.println(completableFuture.get());
			]]>
			</programlisting>
		</section>
		<section id="CompletableFuture.Parallel">
			<title>并行执行 CompletableFuture</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread());


        Parallel parallel = new Parallel();

        parallel.addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task1";
                })
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task2";
                })
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task3";
                })
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    return "finally";
                }).join();

        List<CompletableFuture<String>> futures = parallel.get();

        futures.stream().forEach(item -> {
            System.out.println(item.getNow("no result"));
        });

    }

    public static class Parallel<T> {

        private final List<CompletableFuture<T>> futures;

        Parallel() {
            this(10);
        }

        Parallel(int size) {
            futures = new ArrayList<>(size);
        }

        public Parallel addAsyncTask(Supplier<T> supplier) {
            futures.add(CompletableFuture.supplyAsync(supplier));
            return this;
        }

        public List<CompletableFuture<T>> get() {
            return futures;
        }

        public void join() {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[]{})).join();
        }

        public void clear() {
            futures.clear();
        }
    }
}

			
			]]>
			</programlisting>
		</section>

		<section id="exceptionally">
			<title>异常处理</title>
			<programlisting>
			<![CDATA[
@Service
public class MyService {

    @Async
    public CompletableFuture<String> asyncMethod() {
        try {
            // 异步方法逻辑...
            return CompletableFuture.completedFuture("Success");
        } catch (Exception e) {
            // 处理异常...
            return CompletableFuture.failedFuture(e);
        }
    }
}

// 调用异步方法并处理异常
CompletableFuture<String> future = myService.asyncMethod();
future.exceptionally(e -> {
    // 异常处理逻辑...
    return "Error";
});

			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
    @GetMapping("/completableFutureExceptionally")
    public String completableFutureExceptionally() throws ExecutionException, InterruptedException {

        CompletableFuture.supplyAsync(() -> {
            System.out.println("当前线程名称：" + Thread.currentThread().getName());
            throw new RuntimeException();
        }).exceptionally((e) -> {
            System.out.println(e.getMessage());
            return "程序出现异常";
        });

//        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(() -> {
////            throw new RuntimeException();
//            return "程序出现异常";
//        }).exceptionally((e) -> {
//            System.out.println("程序出现异常");
//            return "程序出现异常";
//        });
//        System.out.println(completableFuture.get());

        return "Done";
    }			
			]]>
			</programlisting>
			<para>输出结果</para>
			<screen>
			<![CDATA[
当前线程名称：ForkJoinPool.commonPool-worker-1
java.lang.RuntimeException			
			]]>
			</screen>
		</section>
		<section id="CompletableFuturePipeline">
			<title>CompletableFuture 实现 Pipeline 流水线</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import lombok.SneakyThrows;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.function.Supplier;

public class CompletableFuturePipeline {

    private final Parallel parallel = new Parallel();

    public CompletableFuturePipeline() {

    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread().getName());

        CompletableFuturePipeline test = new CompletableFuturePipeline();
        test.begin().batch().run().end();
        test.parallel().supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName() + ": parallel1");
            return "parallel1";
        }).supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName() + ": parallel2");
            return "parallel2";
        }).join();


    }

    @SneakyThrows
    public CompletableFuturePipeline begin() {
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();

        parallel.runAsync(() -> {
            String thread = Thread.currentThread().getName();
            System.out.printf("%s - %s\n", thread, method);
        });
        return this;
    }

    public CompletableFuturePipeline run() throws ExecutionException, InterruptedException {
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();
        parallel.supplyAsync(() -> {
            System.out.printf("%s - %s\n", Thread.currentThread().getName(), method);
            return "OK";
        });
        System.out.println(this.asyncMethod1().get());
        return this;
    }

    public CompletableFuturePipeline batch() {
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();
        Parallel batchs = this.parallel();

        batchs.runAsync(() -> {
                    String thread = Thread.currentThread().getName();
                    System.out.printf("%s - %s - task1\n", thread, method);
                })
                .runAsync(() -> {
                    try {
                        TimeUnit.SECONDS.sleep(5);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    String thread = Thread.currentThread().getName();
                    System.out.printf("%s - %s - task2\n", thread, method);

                })
                .runAsync(() -> {
                    String thread = Thread.currentThread().getName();
                    System.out.printf("%s - %s - task3\n", thread, method);
                })
                .supplyAsync(() -> {
                    String thread = Thread.currentThread().getName();
                    System.out.printf("%s - %s - finally\n", thread, method);
                    return "finally";
                }).join();
        System.out.println(batchs.futures.size());

        return this;
    }

    @SneakyThrows
    public CompletableFuturePipeline end() {
        String method = Thread.currentThread().getStackTrace()[1].getMethodName();
        parallel.supplyAsync(() -> {
            System.out.printf("%s - %s\n", Thread.currentThread().getName(), method);
            return "End";
        });

        parallel.join();

        List<CompletableFuture<String>> futures = parallel.get();

        futures.stream().forEach(item -> {
            System.out.println(item.getNow("no result"));
        });

        System.out.println(parallel.futures.size());
        return this;
    }

    public Parallel parallel() {
        return new Parallel();
    }

    public Parallel parallel(int size) {
        return new Parallel(size);
    }

    public CompletableFuture<String> asyncMethod1() {
//        Thread.currentThread().setName(Thread.currentThread().getName() + "-" + this.getClass().getSimpleName());
        System.out.println(Thread.currentThread().getName() + ": asyncMethod1");
        return CompletableFuture.completedFuture("Result1");
    }

    public static class Parallel<T> {

        private final List<CompletableFuture> futures;
//        private final List<CompletableFuture<Void>> voids = new ArrayList<>();

        Parallel() {
            this(10);
        }

        Parallel(int size) {
            futures = new ArrayList<>(size);
        }

        public Parallel runAsync(Runnable runnable) {
            futures.add(CompletableFuture.runAsync(runnable));
            return this;
        }

        public Parallel runAsync(Runnable runnable, Executor executor) {
            futures.add(CompletableFuture.runAsync(runnable, executor));
            return this;
        }

        public Parallel supplyAsync(Supplier<T> supplier) {
            futures.add(CompletableFuture.supplyAsync(supplier));
            return this;
        }

        public Parallel supplyAsync(Supplier<T> supplier, Executor executor) {
            futures.add(CompletableFuture.supplyAsync(supplier, executor));
            return this;
        }

        public List<CompletableFuture> get() {
            return futures;
        }

        public void join() {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[]{})).join();
        }

        public void clear() {
            futures.clear();
        }
    }
}
			
			]]>
			</programlisting>
		</section>

	</section>
	<section id="ThreadPool">
		<title>java 线程池</title>
		<section id="Executors.newCachedThreadPool">
			<title>newCachedThreadPool</title>
			<para>newCachedThreadPool 线程池尺寸没有固定上线</para>
			<programlisting>
			<![CDATA[
	private void startTask(List<String> usersList){
        ExecutorService executor = Executors.newCachedThreadPool();
        executor.submit(()->{
			//do someting
        });
    }
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i < 100; i++) {
            executor.execute(() -> {
                try {
                    TimeUnit.SECONDS.sleep(5);
                    System.out.println(Thread.currentThread().getName());

                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
        executor.shutdown();			
			]]>
			</programlisting>
		</section>
		<section id="newFixedThreadPool">
			<title>固定线程池(newFixedThreadPool)</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test.grey;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class GreyTest {

	public GreyTest() {
		// TODO Auto-generated constructor stub
	}

	static class MyThread implements Runnable {
		public void run() {
			System.out.println("Thread Name:" + Thread.currentThread().getName());
		}
	}

	public static void main(String[] args) {
		// 创建五个线程池
		int nThreads = 5;
		ExecutorService pool = Executors.newFixedThreadPool(nThreads);
		// 创建实现了Runnable接口对象
		MyThread t1 = new MyThread();
		MyThread t2 = new MyThread();
		MyThread t3 = new MyThread();
		MyThread t4 = new MyThread();
		MyThread t5 = new MyThread();
		// 将线程放入池中进行执行
		pool.execute(t1);
		pool.execute(t2);
		pool.execute(t3);
		pool.execute(t4);
		pool.execute(t5);
		// 关闭线程池
		pool.shutdown();
	}

}
			]]>
			</programlisting>
			<para>提交线程数大于线程池尺寸时会同步等待，然后复用已经处理完的空间线程。</para>
			<programlisting>
			<![CDATA[
        System.out.println(Thread.currentThread());
        AtomicInteger count = new AtomicInteger(1);
        int nThread = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newFixedThreadPool(nThread);
        for (int i = 0; i < 100; i++) {
            executor.execute(() -> {
                try {
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(count.getAndIncrement() + " [" + Thread.currentThread().getName() + "] " + System.currentTimeMillis());

                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
        executor.shutdown();			
			]]>
			</programlisting>
			<para>CompletableFuture 线程池</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread());
        ExecutorService executor = Executors.newFixedThreadPool(10);


        Parallel parallel = new Parallel();

        parallel.addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task1";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task2";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task3";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    return "finally";
                }, executor);
        parallel.join();
        List<CompletableFuture<String>> futures = parallel.get();

        futures.stream().forEach(item -> {
            System.out.println(item.getNow("no result"));
        });

        executor.shutdown();
    }

    public static class Parallel<T> {

        private final List<CompletableFuture<T>> futures;

        Parallel() {
            this(10);
        }

        Parallel(int size) {
            futures = new ArrayList<>(size);
        }

        public Parallel addAsyncTask(Supplier<T> supplier) {
            futures.add(CompletableFuture.supplyAsync(supplier));
            return this;
        }

        public Parallel addAsyncTask(Supplier<T> supplier, Executor executor) {
            futures.add(CompletableFuture.supplyAsync(supplier, executor));
            return this;
        }

        public List<CompletableFuture<T>> get() {
            return futures;
        }

        public void join() {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[]{})).join();
        }

        public void clear() {
            futures.clear();
        }
    }
}


			]]>
			</programlisting>
		</section>

		<section id="newScheduledThreadPool">
			<title>Executors.newScheduledThreadPool</title>
			<programlisting>
			<![CDATA[

@Configuration
public class ScheduleConfig implements SchedulingConfigurer {

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        //当然了，这里设置的线程池是corePoolSize也是很关键了，自己根据业务需求设定
        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));
    }

}			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
ScheduledExecutorService service = Executors.newScheduledThreadPool(10);

service.schedule(new Task(), 10, TimeUnit.SECONDS);

service.scheduleAtFixedRate(new Task(), 10, 10, TimeUnit.SECONDS);

service.scheduleWithFixedDelay(new Task(), 10, 10, TimeUnit.SECONDS);
			
			]]>
			</programlisting>
		</section>
		<section id="SingleThreadExecutor">
			<title>SingleThreadExecutor</title>
			<para>可以理解为 SingleThreadExecutor = Executors.newFixedThreadPool(1);
			</para>
			<programlisting>
			<![CDATA[
ExecutorService executor = Executors.newSingleThreadExecutor();
ExecutorService executor = Executors.newSingleThreadScheduledExecutor();			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
        System.out.println(Thread.currentThread());
        AtomicInteger count = new AtomicInteger(1);
        int nThread = Runtime.getRuntime().availableProcessors();
        ExecutorService executor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 100; i++) {
            executor.execute(() -> {
                try {
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(count.getAndIncrement() + " [" + Thread.currentThread().getName() + "] " + System.currentTimeMillis());

                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            });
        }
        executor.shutdown();			
			]]>
			</programlisting>
		</section>
		<section id="ExecutorService">
			<title>ExecutorService 正确关闭方法</title>
			<para>ExecutorService 功能包括，提交任务、执行任务、关闭线程池。</para>
			<para>首先通过 executor.shutdown(); 发送关闭信号，然后再通过
				executor.awaitTermination(10, TimeUnit.SECONDS) 设置超时时间，超时抛出异常，最后通过
				executor.shutdownNow(); 强制关闭。
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.function.Supplier;

public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread());
        ExecutorService executor = Executors.newFixedThreadPool(10);


        Parallel parallel = new Parallel();

        parallel.addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task1";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task2";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    return "task3";
                }, executor)
                .addAsyncTask(() -> {
                    System.out.println(Thread.currentThread().getName());
                    try {
                        TimeUnit.SECONDS.sleep(2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    return "finally";
                }, executor);
        parallel.join();
        List<CompletableFuture<String>> futures = parallel.get();

        futures.stream().forEach(item -> {
            System.out.println(item.getNow("no result"));
        });

        executor.shutdown();

        try {
            executor.shutdown();
            if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                // 超时的时候向线程池中所有的线程发出中断(interrupted)。
                executor.shutdownNow();
            }
        } catch (InterruptedException e) {
            // awaitTermination方法被中断的时候也中止线程池中全部的线程的执行。
            System.out.println("awaitTermination interrupted: " + e);
            executor.shutdownNow();
        }
    }

    public static class Parallel<T> {

        private final List<CompletableFuture<T>> futures;

        Parallel() {
            this(10);
        }

        Parallel(int size) {
            futures = new ArrayList<>(size);
        }

        public Parallel addAsyncTask(Supplier<T> supplier) {
            futures.add(CompletableFuture.supplyAsync(supplier));
            return this;
        }

        public Parallel addAsyncTask(Supplier<T> supplier, Executor executor) {
            futures.add(CompletableFuture.supplyAsync(supplier, executor));
            return this;
        }

        public List<CompletableFuture<T>> get() {
            return futures;
        }

        public void join() {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[]{})).join();
        }

        public void clear() {
            futures.clear();
        }
    }
}

			
			]]>
			</programlisting>
		</section>
		<section id="ForkJoinPool">
			<title>ForkJoinPool / ForkJoinTask</title>
		</section>
	</section>
	<section id="Flow">
		<title>Flow</title>
		<section>
			<title>自定义 Publisher / Subscriber</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;

import java.util.concurrent.Flow;

public class Test {
    public static void main(String[] args) {

        IntPublisher intPublisher = new IntPublisher();
        IntSubscriber intSubscriber = new IntSubscriber();
        intPublisher.subscribe(intSubscriber);
    }

    public static class IntPublisher implements Flow.Publisher<Integer> {

        @Override
        public void subscribe(Flow.Subscriber<? super Integer> subscriber) {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Publishing = " + i);
                // 将数据发给订阅者
                subscriber.onNext(i);
            }
            // 发出完成信号
            subscriber.onComplete();
        }
    }

    public static class IntSubscriber implements Flow.Subscriber<Integer> {
        private Flow.Subscription subscription;

        @Override
        public void onSubscribe(Flow.Subscription subscription) {
            System.out.println("onSubscribe");
        }

        @Override
        public void onNext(Integer item) {
            System.out.println("onNext: " + item);
        }

        @Override
        public void onError(Throwable throwable) {
            System.out.println("onError：" + throwable);
        }

        @Override
        public void onComplete() {
            System.out.println("onComplete");
        }
    }
}			
			]]>
			</programlisting>
		</section>
		<section id="SubmissionPublisher">
			<title>SubmissionPublisher</title>
			<programlisting>
		<![CDATA[
package cn.netkiller.test;

import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;
import java.util.stream.IntStream;

public class SubmissionPublisherTest {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(Thread.currentThread().getName());

        // 1. 定义 String 类型的数据发布者，SubmissionPublisher 实现了 Publisher
        SubmissionPublisher<String> publisher = new SubmissionPublisher<>();

        // 2. 创建一个订阅者，用于接收发布者的消息
        Flow.Subscriber<String> subscriber = new Flow.Subscriber<>() {
            private Flow.Subscription subscription;

            @Override
            public void onSubscribe(Flow.Subscription subscription) {
                this.subscription = subscription;
                System.out.println("onSubscribe");
                this.subscription.request(1);
            }

            @Override
            public void onNext(String item) {
                System.out.println("onNext: " + item);
                this.subscription.request(1);
            }

            @Override
            public void onError(Throwable throwable) {
                System.out.println("Throwable: " + throwable.getMessage());
                this.subscription.cancel();
            }

            @Override
            public void onComplete() {
                System.out.println("onComplete");
            }
        };

        // 3. 发布者和订阅者需要建立关系
        publisher.subscribe(subscriber);
        publisher.submit("https://www.netkiller.cn");

        // 4. 发布者开始发布数据
        IntStream.range(0, 11).mapToObj(i -> "publisher -----> message " + i).peek(message -> publisher.submit(message)).forEach(System.out::println);

        // 5. 发布结束后，关闭发布者
        publisher.close();

        // main线程延迟关闭，不然订阅者还没接收完消息，线程就被关闭了
        Thread.currentThread().join(1000);
    }

}
		]]>
			</programlisting>
			<screen>
			<![CDATA[
main
onSubscribe
onNext: https://www.netkiller.cn
publisher -----> message 0
publisher -----> message 1
publisher -----> message 2
publisher -----> message 3
publisher -----> message 4
onNext: publisher -----> message 0
onNext: publisher -----> message 1
onNext: publisher -----> message 2
onNext: publisher -----> message 3
onNext: publisher -----> message 4
onNext: publisher -----> message 5
publisher -----> message 5
publisher -----> message 6
publisher -----> message 7
publisher -----> message 8
publisher -----> message 9
publisher -----> message 10
onNext: publisher -----> message 6
onNext: publisher -----> message 7
onNext: publisher -----> message 8
onNext: publisher -----> message 9
onNext: publisher -----> message 10
onComplete			
			]]>
			</screen>
		</section>
		<section id="Flow.Processor">
			<title>Flow.Processor</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.test;


import lombok.SneakyThrows;

import java.util.concurrent.Flow;
import java.util.concurrent.SubmissionPublisher;

public class Test {
    @SneakyThrows
    public static void main(String[] args) {
        Test test = new Test();
        try (final var publisher = new SubmissionPublisher<String>()) {

            final var processor = new UpperCaseProcessor();
            publisher.subscribe(processor);

            processor.subscribe(new Flow.Subscriber<String>() {
                                    private Flow.Subscription subscription;

                                    @Override
                                    public void onSubscribe(Flow.Subscription subscription) {
                                        this.subscription = subscription;
                                        System.out.println("Subscriber.onSubscribe");
                                        subscription.request(1);
                                    }

                                    @Override
                                    public void onNext(String item) {
                                        System.out.println("Subscriber.onNext: " + item);
                                        this.subscription.request(1);
                                    }

                                    @Override
                                    public void onError(Throwable throwable) {
                                        System.out.println("Subscriber.onError: " + throwable);
                                    }

                                    @Override
                                    public void onComplete() {
                                        System.out.println("Subscriber.onComplete");
                                    }
                                }
            );

            publisher.submit("abc");
            publisher.submit("xyz");
            publisher.submit("neo");
            publisher.submit("netkiller");
        }
        Thread.currentThread().join(1000);
    }


    static class UpperCaseProcessor extends SubmissionPublisher<String> implements Flow.Processor<String, String> {

        private Flow.Subscription subscription;

        @Override
        public void onSubscribe(Flow.Subscription subscription) {
            this.subscription = subscription;
            System.out.println("Processor.onSubscribe");
            subscription.request(1);
        }

        @Override
        public void onNext(String item) {
            System.out.println("Processor.onNext: " + item);
            submit(item.toUpperCase());
            this.subscription.request(1);
        }

        @Override
        public void onError(Throwable throwable) {
            System.out.println("Processor.onError: " + throwable.getMessage());
            closeExceptionally(throwable);
        }

        @Override
        public void onComplete() {
            System.out.println("Processor.onComplete");
            close();
        }
    }
}
			
			]]>
			</programlisting>
			<screen>
			<![CDATA[
Processor.onSubscribe
Subscriber.onSubscribe
Processor.onNext: abc
Processor.onNext: xyz
Processor.onNext: neo
Processor.onNext: netkiller
Processor.onComplete
Subscriber.onNext: ABC
Subscriber.onNext: XYZ
Subscriber.onNext: NEO
Subscriber.onNext: NETKILLER
Subscriber.onComplete			
			]]>
			</screen>
		</section>
	</section>

	<section id="VirtualThreads">
		<title>Java 协程</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.thread;

import static java.lang.Thread.*;

public class VirtualThreadsTest {
    public static void main(String[] args) throws InterruptedException {
        var virtualThread = startVirtualThread(() -> System.out.println("Hello from the virtual thread"));
        virtualThread.join();
    }
}		
		]]>
		</programlisting>
		<para>运行演示</para>
		<screen>
		<![CDATA[
neo@MacBook-Pro-M2 thread % java --source 20 --enable-preview VirtualThreadsTest.java
注: VirtualThreadsTest.java 使用 Java SE 20 的预览功能。
注: 有关详细信息，请使用 -Xlint:preview 重新编译。
Hello from the virtual thread
		]]>
		</screen>
		<programlisting>
		<![CDATA[
import java.time.Duration;
import java.util.concurrent.Executors;
import java.util.stream.IntStream;

public class Main {
    public static void main(String[] args) {

        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(0, 10000).forEach(i -> {
                executor.submit(() -> {
                    Thread.sleep(Duration.ofSeconds(1));
                    return i;
                });
            });
        }
    }
}
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class VirtualThreadExample {

    public static void main(String[] args) {
        ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

        executor.submit(() -> {
            System.out.println(Thread.currentThread().getName())
        });

        executor.shutdown();
    }
}		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
Thread.ofVirtual().start(Runnable);
Thread.ofVirtual().unstarted(Runnable);		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
Thread.ofVirtual().start(Runnable);
Thread.ofVirtual().unstarted(Runnable);		
		]]>
		</programlisting>
	</section>
</chapter>