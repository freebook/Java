<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="mvc" ?>
	<title>Spring MVC</title>
	<para>Spring MVC 有两种启动模式，一种是传统Tomcat，需要配置很多XML文件。另一种方式是采用 Spring Boot 需要些一个Java程序，不需要写xml文件，这个程序会帮助你处理启动所需的一切，并且采用嵌入方式启动 Tomcat 或者 Jetty.</para>
	<para>两种方式各有优缺点，Tomcat 方式配置繁琐，但是可以使用虚拟机，同一个IP地址使用不同域名访问，出现不同的内容。而Spring Boot一个应用一个容器一个端口，比不得不通过端口来区分应用。</para>
	&section.mvc.controller.xml;	
	&section.mvc.view.xml;
	<section id="properties">
		<title>Properties</title>
		<section>
			<title>载入*.properties文件</title>
			<programlisting>
			<![CDATA[
	@RequestMapping("/config")
	@ResponseBody
	public void config() {
		try {
			Properties properties = PropertiesLoaderUtils.loadProperties(new ClassPathResource("/config.properties"));
			for(String key : properties.stringPropertyNames()) {
				  String value = properties.getProperty(key);
				  System.out.println(key + " => " + value);
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}	
			]]>
			</programlisting>
		</section>
		<section>
			<title>@Value 注解</title>
			<para>application.properties</para>
			<screen>
server.name=Linux
server.host=192.168.0.1,172.16.0.1
			</screen>
			<screen>
			<![CDATA[
	@Value("${server.name}")
	private String name;
	
	@Value("${server.name:Windows}") 如果application.properties没有配置server.name那么默认值将是 Windows
	private String name;
	
	@Value("${app.name:@null}") // app.name = null
 	private String name;
 	
 	@Value("#{'${server.host}'.split(',')}") 
 	private List<String> host;
 			]]>
			</screen>
		</section>
		<section>
			<title>@PropertySource 注解</title>
			<programlisting>
			<![CDATA[
@PropertySource("classpath:/config.properties}")	

忽略FileNotFoundException，当配置文件不存在系统抛出FileNotFoundException并终止程序运行，ignoreResourceNotFound=true 会跳过使程序能够正常运行
@PropertySource(value="classpath:config.properties", ignoreResourceNotFound=true)		



			]]>
			</programlisting>
			<para>载入多个配置文件</para>
			<programlisting>
			<![CDATA[
@PropertySources({  
        @PropertySource("classpath:config.properties"),  
        @PropertySource("classpath:db.properties")  
})
			]]>
			</programlisting>
			<para>test.properties</para>
			<programlisting>
name=Neo
age=30
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.web;

import java.util.Date;

import javax.servlet.http.HttpSession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
@PropertySource("classpath:test.properties")
public class TestController {
	
	@Autowired
	Environment environment;
	
	@Value("${age}")
	private String age;

	public TestController() {
		// TODO Auto-generated constructor stub
	}
	
	// 环境变量方式
	@RequestMapping("/test/env")
	@ResponseBody
	public String env() {
		String message = environment.getProperty("name");
		return message;
	}
	
	@RequestMapping("/test/age")
	@ResponseBody
	public String age() {
		String message = age;
		return message;
	}

}
			]]>
			</programlisting>
		</section>
	</section>
	<section id="faq">
		<title>FAQ</title>
		<section>
			<title>o.s.web.servlet.PageNotFound</title>
			<para>解决方法，加入下面代码到 dispatcher-servlet.xml 文件中</para>
			<screen>
			<![CDATA[
<mvc:annotation-driven />			
			]]>
			</screen>
			<para>dispatcher-servlet.xml</para>
			<screen>
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans     
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc 
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context.xsd">

	<context:component-scan base-package="cn.netkiller.controller" />
	<mvc:annotation-driven />
	<bean id="viewResolver"
		class="org.springframework.web.servlet.view.UrlBasedViewResolver">
		<property name="viewClass"
			value="org.springframework.web.servlet.view.JstlView" />
		<property name="prefix" value="/WEB-INF/jsp/" />
		<property name="suffix" value=".jsp" />
	</bean>

</beans>
			]]>
			</screen>
		</section>
		<section>
			<title>HTTP Status 500 - Handler processing failed; nested exception
				is java.lang.NoClassDefFoundError:
				javax/servlet/jsp/jstl/core/Config</title>
			<para>pom.xml 文件中加入依赖包</para>
			<screen>
			<![CDATA[
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
			<version>1.2</version>
		</dependency>
			]]>
			</screen>
		</section>
		<section>
			<title>同时使用 Thymeleaf 与 JSP </title>
			<subtitle>Using both Thymeleaf and JSP</subtitle>
			<programlisting>
			<![CDATA[
	<bean
		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="viewClass"
			value="org.springframework.web.servlet.view.JstlView" />
		<property name="prefix" value="/WEB-INF/jsp/" />
		<!-- <property name="suffix" value=".jsp" /> -->
		<property name="viewNames" value="*.jsp" />
	</bean>

	<bean id="templateResolver"
		class="org.thymeleaf.templateresolver.ServletContextTemplateResolver">
		<property name="prefix" value="/WEB-INF/templates/" />
		<!-- <property name="suffix" value=".html" /> -->
		<property name="templateMode" value="HTML5" />
	</bean>

	<bean id="templateEngine" class="org.thymeleaf.spring4.SpringTemplateEngine">
		<property name="templateResolver" ref="templateResolver" />
	</bean>

	<bean class="org.thymeleaf.spring4.view.ThymeleafViewResolver">
		<property name="templateEngine" ref="templateEngine" />
		<property name="viewNames" value="*.html" />
	</bean>	
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
@RequestMapping("/thymeleaf")
public String thymeleafView(){
    return "thymeleaf.html";
}

@RequestMapping("/jsp")
public String jspView(){
    return "jstl.jsp";
}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
			<property name="viewNames" value="*thymeleaf/*" />
			
@RequestMapping(value="/test")
public ModelAndView dboxPrint(Model model){
    ModelAndView modelAndView = new ModelAndView("thymeleaf/test");
    return modelAndView;
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>排除静态内容</title>
			<para>方法一，排除静态内容如 images, css, js 等等</para>
			<programlisting>
			<![CDATA[
	<servlet>
        <servlet-name>springframework</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
	<servlet-mapping>
	    <servlet-name>default</servlet-name>
	    <url-pattern>/images/*</url-pattern>
	    <url-pattern>*.css</url-pattern>
	    <url-pattern>/js/*.js</url-pattern>
	</servlet-mapping>    
    <servlet-mapping>
        <servlet-name>springframework</servlet-name>
        <url-pattern>/welcome.jsp</url-pattern>
        <url-pattern>/welcome.html</url-pattern>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>			
			]]>
			</programlisting>
			<para>方法二</para>
			<programlisting>
			<![CDATA[
	<mvc:resources location="/images/" mapping="/images/**" />
	<mvc:resources location="/css/" mapping="/css/**" />
	<mvc:resources location="/js/" mapping="/js/**" />			
			]]>
			</programlisting>
		</section>
		<section>
			<title>HTTP Status 406</title>
			<para>配置 url-pattern 增加需要传递给Spring的扩展名</para>
			<screen>
			<![CDATA[
	<servlet>
        <servlet-name>springframework</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
   
    <servlet-mapping>
        <servlet-name>springframework</servlet-name>
        <url-pattern>/welcome.jsp</url-pattern>
        <url-pattern>/welcome.html</url-pattern>
        <url-pattern>*.json</url-pattern>
        <url-pattern>*.xml</url-pattern>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>		
			]]>
			</screen>
		</section>
		<section>
			<title>Caused by: java.lang.IllegalArgumentException: Not a managed type: class common.domain.Article</title>
			<para>背景描述：Springboot 入口文件 Application.java 的包是 package api; 为了让 domain,pojo 共用，于是将 domain 放到Maven module下命令为 common。启动后出现这个故障。</para>
			<para>解决方案增加 @EntityScan("common.domain") 即可。</para>
			<programlisting>
			<![CDATA[
package api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
@EnableEurekaClient
@EntityScan("common.domain")
public class Application {

	public static void main(String[] args) {
		System.out.println( "Service Api Starting..." );
		SpringApplication.run(Application.class, args);
	}
}
			
			]]>
			</programlisting>
		</section>
	</section>
</chapter>