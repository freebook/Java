
<chapter id="index"> <?dbhtml dir="mysql" ?>
	<title>Spring Data with MySQL</title>
	<section id="engine">
		<title>选择数据库表引擎</title>
		<para>正常创建表会使用数据库默认引擎，有时数据库默认引擎并不是我们需要的，通过下面配置可以指定表引擎</para>
		<screen>
			<![CDATA[
# Spring boot 1.x.x
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLInnoDBDialect

# Spring boot 2.0.2
spring.jpa.hibernate.use-new-id-generator-mappings=true
spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect
			]]>
		</screen>
	</section>
	<section id="@Entity">
		<title>声明实体</title>
		<section>
			<title>@Entity 声明实体</title>
			<para>声明 Class 即是数据库表</para>
			<programlisting>
			<![CDATA[
@Entity
@Table
public class Your_table {
	...
	...
}			
			]]>
			</programlisting>
		</section>
		<section id="@Table">
			<title>@Table 定义表名</title>
			<section id="catalog">
				<title>catalog</title>
				<screen>
				<![CDATA[
@Table(name="CUSTOMERS",catalog="hibernate")				
				]]>
				</screen>
			</section>
			<section id="schema">
				<title>schema</title>
				<para>配置Schema</para>
				<screen>
				<![CDATA[
@Table(name="tabname", schema="public")
				]]>
				</screen>
			</section>
			<section id="uniqueConstraints">
				<title>uniqueConstraints</title>
				<para>唯一索引</para>
				<screen>
				<![CDATA[
@Table(name="CUSTOMERS",uniqueConstraints={@UniqueConstraint(columnNames={"name","email"})})				
				]]>
				</screen>
				<para>定义多组唯一索引</para>
				<screen>
				<![CDATA[
uniqueConstraints={@UniqueConstraint(columnNames={"name","email"}),@UniqueConstraint(columnNames={"name","age"})} 				
				]]>
				</screen>

			</section>
		</section>
		<section id="@Id">
			<title>@Id 定义主键</title>
			<para>ID 字段，数据库中的主键。</para>
			<screen>
			<![CDATA[
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
private int id;			
			]]>
			</screen>
			<para>@GeneratedValue 主键生成策略：</para>
			<screen>
			<![CDATA[
@GeneratedValue(strategy= GenerationType.IDENTITY) 	该注解由数据库自动生成，AUTO_INCREMENT 自增主键，在 mysql 数据库中使用最频繁，oracle 不支持。
@GeneratedValue(strategy= GenerationType.AUTO) 		主键由程序控制，默认的主键生成策略，oracle 默认是序列化的方式，mysql 默认是主键自增的方式。
@GeneratedValue(strategy= GenerationType.SEQUENCE) 	根据底层数据库的序列来生成主键，条件是数据库支持序列，Oracle支持，Mysql不支持。
@GeneratedValue(strategy= GenerationType.TABLE) 	使用一个特定的数据库表格来保存主键，较少使用。
			]]>
			</screen>
			<para>Long = bigint</para>
			<screen>
			<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@Data
public class Picture implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
    private Long id;
    private String device;
    private String model;
    private String session;
    private String prompt;
    private String thumbnail;
    private String image;
    private String story;
    private boolean share;
    private int likes;
    private int favorites;
    private int forward;
    private Date ctime;
    private Date mtime;

}
			]]>
			</screen>
			<para></para>
			<screen>
			<![CDATA[
CREATE TABLE `picture` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `ctime` datetime(6) DEFAULT NULL,
  `favorites` int NOT NULL,
  `image` varchar(255) DEFAULT NULL,
  `likes` int NOT NULL,
  `mtime` datetime(6) DEFAULT NULL,
  `prompt` varchar(255) DEFAULT NULL,
  `session` varchar(255) DEFAULT NULL,
  `share` bit(1) NOT NULL,
  `story` varchar(255) DEFAULT NULL,
  `thumbnail` varchar(255) DEFAULT NULL,
  `device` varchar(255) DEFAULT NULL,
  `model` varchar(255) DEFAULT NULL,
  `forward` int NOT NULL
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci			
			]]>
			</screen>
			<para>字符串做主键</para>
			<screen>
			<![CDATA[
package api.domain;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table()
public class TransactionsPostion {

	@Id
	private String address;
	private String startblock;
	private String endblock;

	public TransactionsPostion() {
		// TODO Auto-generated constructor stub
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public String getStartblock() {
		return startblock;
	}

	public void setStartblock(String startblock) {
		this.startblock = startblock;
	}

	public String getEndblock() {
		return endblock;
	}

	public void setEndblock(String endblock) {
		this.endblock = endblock;
	}

}

			]]>
			</screen>
			<para>对应数据库表</para>
			<screen>
			<![CDATA[
CREATE TABLE "transactions_postion" (
  "address" varchar(255) NOT NULL,
  "endblock" varchar(255) DEFAULT NULL,
  "startblock" varchar(255) DEFAULT NULL,
  PRIMARY KEY ("address")
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
			]]>
			</screen>
		</section>
		<section id="@Column">
			<title>@Column 定义字段：</title>
			<screen>
			<![CDATA[
unique 		属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint。
nullable 	属性表示该字段是否可以为null值，默认为true。
insertable 	属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值。
updatable	属性表示在使用“UPDATE”脚本插入数据时，是否需要更新该字段的值。insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的。
columnDefinition属性表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。
table 		属性表示当映射多个表时，指定表的表中的字段。默认值为主表的表名。
length 		属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符。
precision 	属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。	
scale		int	列的精度，仅对十进制数值有效，表示小数位的总位数。默认为0。		
			]]>
			</screen>
			<section id="@Column.length">
				<title>字段长度</title>
				<para>字段长度定义</para>
				<screen>
				<![CDATA[
@Column(name="name", length=80, nullable=true)	
				]]>
				</screen>
			</section>
			<section id="BigDecimal">
				<title>浮点型</title>
				<screen>
				<![CDATA[
	@Column(precision=18, scale=5)  
    private BigDecimal principal; 	
    
    @Column(name="Price", columnDefinition="Decimal(10,2) default '100.00'")			
				]]>
				</screen>
				<programlisting>
				<![CDATA[
@Column(name = "totalAmount", precision = 10, scale = 2, nullable = false)
private BigDecimal totalAmount;				
				]]>
				</programlisting>
			</section>
			<section id="@Column.insertable">
				<title>创建于更新控制</title>
				<screen>
				<![CDATA[
	@Column(name = "ctime", nullable = false, insertable = false, updatable = false)				
				]]>
				</screen>
			</section>
			<section id="TEXT">
				<title>TEXT 类型</title>
				<programlisting>
				<![CDATA[
	private String subject;
	@Column(columnDefinition = "TEXT")
	private String content;				
				]]>
				</programlisting>
			</section>
			<section id="UNSIGNED">
				<title>整形数据类型</title>
				<para>无符号整形</para>
				<programlisting>
			<![CDATA[
package com.example.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class Member {
	@Id
	private int id;
		
	@Column(columnDefinition = "INT(10) UNSIGNED NOT NULL")
	private int age;
	
	@Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;

	@Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
	private Date mtime;

	@Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
	private boolean status;
}			
			]]>
				</programlisting>
				<programlisting>
			<![CDATA[
CREATE TABLE `member` (
  `id` int(11) NOT NULL,
  `age` int(10) unsigned NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `status` enum('Y','N') DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8			
			]]>
				</programlisting>
			</section>
		</section>
		<section id="@Transient">
			<title>非数据库字段</title>
			<para>@Transient 该注解标注的字段不会被应射到数据库当中</para>
		</section>
		<section id="@Lob">
			<title>@Lob 注解属性将被持久化为 Blog 或 Clob 类型</title>
			<literallayout>
			<![CDATA[
Clob（Character Large Ojects）类型是长字符串类型，具体的java.sql.Clob, Character[], char[] 和 java.lang.String 将被持久化为 Clob 类型。
Blob（Binary Large Objects）类型是字节类型，具体的java.sql.Blob, Byte[], byte[] 和 serializable type 将被持久化为 Blob 类型。
@Lob 持久化为Blob或者Clob类型,根据get方法的返回值不同,自动进行Clob和Blob的转换。
因为这两种类型的数据一般占用的内存空间比较大，所以通常使用延迟加载的方式，与@Basic标记同时使用，设置加载方式为FetchType.LAZY。			
			]]>
			</literallayout>
			<programlisting>
			<![CDATA[
@Lob 
@Basic(fetch = FetchType.LAZY) 
@Column(name="content", columnDefinition="CLOB", nullable=true) 
public String getContent() {
    return content;
}			
			]]>
			</programlisting>
		</section>
		<section id="@NotNull">
			<title>@NotNull 不能为空声明</title>
			<programlisting>
			<![CDATA[
	@NotNull
	public String username;			
			]]>
			</programlisting>
		</section>

		<section id="@Temporal">
			<title>@Temporal 日期定义</title>
			<programlisting>
			<![CDATA[
@Entity
public class Article {
 
    @Id
    @GeneratedValue
    Integer id;
  
    @Temporal(TemporalType.DATE)
    Date publicationDate;
  
    @Temporal(TemporalType.TIME)
    Date publicationTime;
  
    @Temporal(TemporalType.TIMESTAMP)
    Date creationDateTime;
}			
			]]>
			</programlisting>
		</section>
		<section id="@CreateDate">
			<title>创建日期</title>
			<screen>
			<![CDATA[
    @Column(name = "create_at")
    @CreatedDate
    private Timestamp create_date;			
			]]>
			</screen>
			<section id="CreatedDate">
				<title>CreatedDate</title>
				<para>Spring 提供了 import
					org.springframework.data.annotation.CreatedDate;
				</para>
				<para>但是这些只能作用于实体类。</para>
				<screen>
				<![CDATA[
	@CreatedDate
    private Date createdDateTime;			
				]]>
				</screen>
			</section>
			<section>
				<title>与时间日期有关的 hibernate 注解</title>

				<section id="hibernate.time">
					<title>设置默认时间</title>
					<programlisting>
				<![CDATA[
@Column(insertable = false) 
@org.hibernate.annotations.ColumnDefault("1.00") 
@org.hibernate.annotations.Generated(
org.hibernate.annotations.GenerationTime.INSERT
) 
protected Date lastModified; 
				]]>
					</programlisting>
				</section>
				<section id="createTime">
					<title>创建时间</title>
					<programlisting>
				<![CDATA[
@Temporal(TemporalType.TIMESTAMP)  
@Column(updatable = false)  
@org.hibernate.annotations.CreationTimestamp  
protected Date createdDate;   			
				]]>
					</programlisting>
				</section>
				<section id="updateTime">
					<title>更新时间</title>
					<programlisting>
				<![CDATA[
@Column(name="update_time")  
@org.hibernate.annotations.UpdateTimestamp  
@Temporal(TemporalType.TIMESTAMP)
private Date updateTime;    			
				]]>
					</programlisting>
					<programlisting>
				<![CDATA[
@Temporal(TemporalType.TIMESTAMP)  
@Column(insertable = false, updatable = false)  
@org.hibernate.annotations.Generated(  
org.hibernate.annotations.GenerationTime.ALWAYS  
) 
				]]>
					</programlisting>
				</section>
			</section>
			<section>
				<title>数据库级别的默认创建日期时间定义</title>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Date getCtime() {
		return ctime;
	}

	public void setCtime(Date ctime) {
		this.ctime = ctime;
	}

}				
				]]>
				</programlisting>
				<para>对应数据库DDL</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				]]>
				</programlisting>
			</section>
			<section>
				<title>数据库级别的默认创建日期与更新时间定义</title>
				<para>需求是这样的：</para>
				<para>1.
					创建时间与更新时间只能由数据库产生，不允许在实体类中产生，因为每个节点的时间/时区不一定一直。另外防止人为插入自定义时间时间。
				</para>
				<para>2. 插入记录的时候创建默认时间，创建时间不能为空，时间一旦插入不允许日后在实体类中修改。</para>
				<para>3. 记录创建后更新日志字段为默认为 null 表示该记录没有被修改过。一旦数据被修改，修改日期字段将记录下最后的修改时间。
				</para>
				<para>4. 甚至你可以通过触发器实现一个history 表，用来记录数据的历史修改，详细请参考作者另一部电子书《Netkiller
					Architect 手札》数据库设计相关章节。
				</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;
import javax.validation.constraints.Null;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	// 创建时间
	@Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
	private Date ctime;
	
	// 修改时间
	@Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
	private Date mtime;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Date getCtime() {
		return ctime;
	}

	public void setCtime(Date ctime) {
		this.ctime = ctime;
	}

	public Date getMtime() {
		return mtime;
	}

	public void setMtime(Date mtime) {
		this.mtime = mtime;
	}

}		
				]]>
				</programlisting>
				<para>对应数据库DDL</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
				]]>
				</programlisting>
			</section>
			<section>
				<title>最后修改时间</title>
				<para>需求：记录最后一次修改时间</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class ElasticsearchTrash {
	@Id
	private int id;

	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP")
	private Date lastModified;

}					
				]]>
				</programlisting>
				<para>产生DDL语句如下</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `elasticsearch_trash` (
  `id` int(11) NOT NULL,
  `last_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="@DateTimeFormat">
			<title>@DateTimeFormat 处理日期时间格式</title>
			<programlisting>
			<![CDATA[
	public java.sql.Date createdate; 创建日期 YYYY-MM-DD
	public java.util.Date finisheddate; 创建日期时间 YYYY-MM-DD HH:MM:SS
			]]>
			</programlisting>
			<para>Json默认为 yyyy-MM-ddTHH:mm:ss 注意日期与时间中间的T，修改日期格式将T去掉</para>
			<screen>
			<![CDATA[
	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	private Date createDate;
			]]>
			</screen>
			<programlisting>
			<![CDATA[
    /**
     * 日期 DATE  YYYY-MM-DD
     */
    @Column(name = "create_date")
    @JsonFormat(shape= JsonFormat.Shape.STRING,pattern="yyyy-MM-dd HH:mm:ss",timezone="GMT+8")
    private Date date;			
			]]>
			</programlisting>
			<para>下面我们实际演示一下，例如默认返回 "ctime": "2024-01-25T08:07:39.000+00:00"
				这样的格式
			</para>
			<screen>
			<![CDATA[
HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 25 Jan 2024 08:10:32 GMT
Connection: close

{
  "status": true,
  "code": "SUCCESS",
  "data": [
    {
      "id": 3918,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "1.音频上传",
      "description": "test.amr",
      "ctime": "2024-01-25T08:07:16.000+00:00"
    },
    {
      "id": 3919,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "2.音频转换",
      "description": "AMR 转 PCM",
      "ctime": "2024-01-25T08:07:16.000+00:00"
    },
    {
      "id": 3920,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "3.语音识别",
      "description": "小明是个调皮的小男孩，他觉得地板上有很多污垢，于是他拿起了牙刷用它来刷地板，虽然效果不佳，但是小明却觉得是一种有趣的尝试。",
      "ctime": "2024-01-25T08:07:36.000+00:00"
    },
    {
      "id": 3921,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "4.内容合规",
      "description": "合规：小明是个调皮的小男孩，他觉得地板上有很多污垢，于是他拿起了牙刷用它来刷地板，虽然效果不佳，但是小明却觉得是一种有趣的尝试。",
      "ctime": "2024-01-25T08:07:36.000+00:00"
    },
    {
      "id": 3922,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "5.故事创作",
      "description": "小明，一个满腔调皮的小男孩，发现家里仿佛被污秽覆盖。他拿起牙刷，一面一面地在地板上划过，结果却不尽人意。然而，这个看似毫无预期的尝试，他自己却获得了无比的乐趣。\n\n问题：小明的行为可能使他的生活环境变得更糟糕，你会如何帮助他改变这种状况？",
      "ctime": "2024-01-25T08:07:36.000+00:00"
    },
    {
      "id": 3923,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "6.语音合成",
      "description": "http://oss.test.netkiller.cn/2024/01/25/27310934-4159-4bc9-8142-67a3780faf35.mp3",
      "ctime": "2024-01-25T08:07:39.000+00:00"
    }
  ],
  "reason": "操作成功"
}

			]]>
			</screen>
			<para>加入 @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss") 注解</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@Data
public class SessionStatus implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Long id;

    @Comment("会话主键")
    private String session;

    @Comment("进度")
    private String progress;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("描述")
    private String description;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("创建时间")
    private Date ctime;
}
			
			]]>
			</programlisting>
			<para>日期被格式化为 "ctime": "2024-01-25 08:07:16"</para>
			<screen>
			<![CDATA[
HTTP/1.1 200 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Thu, 25 Jan 2024 08:12:10 GMT
Connection: close

{
  "status": true,
  "code": "SUCCESS",
  "data": [
    {
      "id": 3918,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "1.音频上传",
      "description": "test.amr",
      "ctime": "2024-01-25 08:07:16"
    },
    {
      "id": 3919,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "2.音频转换",
      "description": "AMR 转 PCM",
      "ctime": "2024-01-25 08:07:16"
    },
    {
      "id": 3920,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "3.语音识别",
      "description": "小明是个调皮的小男孩，他觉得地板上有很多污垢，于是他拿起了牙刷用它来刷地板，虽然效果不佳，但是小明却觉得是一种有趣的尝试。",
      "ctime": "2024-01-25 08:07:36"
    },
    {
      "id": 3921,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "4.内容合规",
      "description": "合规：小明是个调皮的小男孩，他觉得地板上有很多污垢，于是他拿起了牙刷用它来刷地板，虽然效果不佳，但是小明却觉得是一种有趣的尝试。",
      "ctime": "2024-01-25 08:07:36"
    },
    {
      "id": 3922,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "5.故事创作",
      "description": "小明，一个满腔调皮的小男孩，发现家里仿佛被污秽覆盖。他拿起牙刷，一面一面地在地板上划过，结果却不尽人意。然而，这个看似毫无预期的尝试，他自己却获得了无比的乐趣。\n\n问题：小明的行为可能使他的生活环境变得更糟糕，你会如何帮助他改变这种状况？",
      "ctime": "2024-01-25 08:07:36"
    },
    {
      "id": 3923,
      "session": "27310934-4159-4bc9-8142-67a3780faf35",
      "progress": "6.语音合成",
      "description": "http://oss.test.netkiller.cn/2024/01/25/27310934-4159-4bc9-8142-67a3780faf35.mp3",
      "ctime": "2024-01-25 08:07:39"
    }
  ],
  "reason": "操作成功"
}
			
			]]>
			</screen>
		</section>
		<section id="enum">
			<title>Enum 枚举数据类型</title>
			<para>Enum 枚举数据类型 MySQL 特殊数据类型</para>
			<section id="EnumType.STRING">
				<title>实体中处理 enum 类型，存储字符串</title>
				<para>@Enumerated(EnumType.STRING) 注解可以使其成功字符串类型。</para>
				<programlisting>
					<![CDATA[
	public enum StatisticsType {
		LIKE, COMMENT, BROWSE;
	}

	@Enumerated(EnumType.STRING)
	private StatisticsType type;
					]]>
				</programlisting>
				<para>SQL</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `statistics_history` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `member_id` bigint(20) NOT NULL,
  `statistics_id` bigint(20) NOT NULL,
  `type` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
				]]>
				</programlisting>
			</section>
			<section id="EnumType.ORDINAL">
				<title>实体中处理 enum 类型，存储序号</title>
				<para>@Enumerated(value = EnumType.ORDINAL) //ORDINAL序数 </para>
				<para>在实体中处理枚举类型适用于所有数据库，Spring data 将枚举视为 String 类型。</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "statistics_history")
public class StatisticsHistory implements Serializable {

	private static final long serialVersionUID = 1L;
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id",unique = true, nullable = false, insertable = true, updatable = false)
	private long id;
	private long memberId;
	private long statisticsId;
	
	public enum StatisticsType {
		LIKE, COMMENT, BROWSE;
	}
	
	private StatisticsType type;
	
	public Long getId() {
		return id;
	}
	
	public void setId(Long id) {
		this.id = id;
	}
	
	public long getMemberId() {
		return memberId;
	}
	
	public void setMemberId(long memberId) {
		this.memberId = memberId;
	}
	
	public long getStatisticsId() {
		return statisticsId;
	}
	
	public void setStatisticsId(long statisticsId) {
		this.statisticsId = statisticsId;
	}
	
	public StatisticsType getType() {
		return type;
	}
	
	public void setType(StatisticsType type) {
		this.type = type;
	}

}
				]]>
				</programlisting>
				<para>默认 enum 类型创建数据库等效 int(11)</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `statistics_history` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `member_id` bigint(20) NOT NULL,
  `statistics_id` bigint(20) NOT NULL,
  `type` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
SELECT * FROM test.statistics;
				]]>
				</programlisting>

			</section>
			<section>
				<title>数据库枚举类型</title>
				<para>在枚举中处理类型虽然可以适用于所有数据库，但有时我们希望适用数据库的枚举类型（例如MySQL），数据库中得枚举类型要比字符串效率更高
				</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.domain.elasticsearch;

import java.util.Date;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table
public class NetkillerTrash {
	@Id
	private int id;

	@Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
	private boolean status;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public boolean isStatus() {
		return status;
	}

	public void setStatus(boolean status) {
		this.status = status;
	}

}				
				]]>
				</programlisting>
				<para>实际对应的数据库DLL</para>
				<programlisting>
				<![CDATA[
CREATE TABLE `netkiller_trash` (
  `id` int(11) NOT NULL,
  `status` enum('Y','N') DEFAULT 'N',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
				]]>
				</programlisting>
			</section>
			<section>
				<title>自定义枚举value属性</title>
				<programlisting>
				<![CDATA[
public enum Gender {
    MALE("男士"),
    FEMALE("女士");

    private final String value;

    private Gender(String value) {
        this.value = value;
    }
    
    // value 转枚举
    public static Gender fromValue(String value) {
        for (Gender gender : values()) {
            if (gender.toValue().equals(value)) {
                return gender;
            }
        }
        return null;
    }

    // 枚举转 value
    public String toValue() {
        return value;
    }
}				
				]]>
				</programlisting>
				<para>创建 Gender 的自定义转换器</para>
				<programlisting>
				<![CDATA[
// 实现 AttributeConverter 接口
java复制代码public class GenderConverter implements AttributeConverter<Gender, String> {
    @Override
    public String convertToDatabaseColumn(Gender gender) {
        return gender.toValue();
    }

    @Override
    public Gender convertToEntityAttribute(String value) {
        return Gender.fromValue(value);
    }
}				
				]]>
				</programlisting>
				<para>在实体中，枚举字段加 @Convert 注解</para>
				<programlisting>
				<![CDATA[
@Convert(converter = GenderConverter.class)
@Column(name = "gender")
private Gender gender;				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="set">
			<title>SET 数据结构</title>
			<programlisting>
			<![CDATA[
package common.domain;

import java.util.Date;
import java.util.Map;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Convert;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import org.springframework.format.annotation.DateTimeFormat;
import com.fasterxml.jackson.annotation.JsonFormat;

import common.type.OptionConverter;

@Entity
public class ItemPool {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false)
	public int id;

	@ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
	@JoinColumn(name = "site_id", referencedColumnName = "id")
	private Site site;

	public String question;

	@Column(columnDefinition = "json DEFAULT NULL")
	@Convert(converter = OptionConverter.class)
	public Map<String, String> options;

	@Column(columnDefinition = "SET('A','B','C','D','E','F','G') DEFAULT NULL COMMENT '答案'")
	public String answer;

	@ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
	@JoinColumn(name = "category_id", referencedColumnName = "id")
	private Category category;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'")
	public Date ctime;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间'")
	public Date mtime;
}
			]]>
			</programlisting>
			<para>定义 SET 如下，在JAVA中
				SET被映射为逗号分隔的字符串（String），所以操作起来并无不同。使用字符串"A,B,C"存储即可，取出也同样是字符串。
			</para>
			<programlisting>
			<![CDATA[
@Column(columnDefinition = "SET('A','B','C','D','E','F','G') DEFAULT NULL COMMENT '答案'")
			]]>
			</programlisting>
			<para>接入后查看</para>
			<programlisting>
			<![CDATA[
mysql> select answer from item_pool;
+--------+
| answer |
+--------+
| A,B,C  |
+--------+
1 row in set (0.00 sec)			
			]]>
			</programlisting>
			<para>完美实现</para>
		</section>
		<section id="json">
			<title>JSON 数据类型</title>
			<para>MySQL 5.7 中增加了 json 数据类型，下面是一个例子：</para>
			<programlisting>
			<![CDATA[
CREATE TABLE `test` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `your` json DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8
			]]>
			</programlisting>
			<para>我们需要在 Java 实体中定义 json
				数据库结构，我搜索遍了整个互联网（Google,Bing,Baidu......），没有找到解决方案，功夫不负有心人，反复尝试后终于成功。记住我是第一个这样用的
				：） 。
			</para>
			<programlisting>
			<![CDATA[
package common.domain;

import java.util.Date;
import java.util.Map;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Convert;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;

import org.springframework.format.annotation.DateTimeFormat;
import com.fasterxml.jackson.annotation.JsonFormat;

import common.type.OptionConverter;

@Entity
public class ItemPool {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false)
	public int id;

	@ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
	@JoinColumn(name = "site_id", referencedColumnName = "id")
	private Site site;

	public String name;

	@Column(columnDefinition = "json DEFAULT NULL")
	@Convert(converter = OptionConverter.class)
	public Map<String, String> options;

	@ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
	@JoinColumn(name = "category_id", referencedColumnName = "id")
	private Category category;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'")
	public Date ctime;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间'")
	public Date mtime;
}

			]]>
			</programlisting>
			<para>类型转换 Class</para>
			<programlisting>
			<![CDATA[
package common.type;

import java.util.Map;
import javax.persistence.AttributeConverter;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class OptionConverter implements AttributeConverter<Map<String, String>, String> {

	Gson json = new Gson();

	@Override
	public String convertToDatabaseColumn(Map<String, String> items) {
		return json.toJson(items, new TypeToken<Map<String, String>>() {
		}.getType());
	}

	@Override
	public Map<String, String> convertToEntityAttribute(String str) {
		return json.fromJson(str, new TypeToken<Map<String, String>>() {
		}.getType());
	}
}			
			]]>
			</programlisting>
			<para>通过 @Column(columnDefinition = "json DEFAULT NULL") 定义数据库为 JSON
				数据类型
			</para>
			<para>数据存储与取出通过 @Convert(converter = OptionConverter.class) 做转换
			</para>
			<para>这里我需要使用
				Map 数据结构 <![CDATA[public Map<String, String> options;]]>，
				你可以根据你的实际需要定义数据类型 Class
			</para>
			<para>启动 Spring 项目后创建 Schema 如下：</para>
			<programlisting>
			<![CDATA[
CREATE TABLE `item_pool` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `ctime` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '????',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '????',
  `name` varchar(255) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `site_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FKgwuxedi20fxclobkk2po053hj` (`category_id`),
  KEY `FKiujumwssofow95st51ukklpgv` (`site_id`),
  CONSTRAINT `FKgwuxedi20fxclobkk2po053hj` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`),
  CONSTRAINT `FKiujumwssofow95st51ukklpgv` FOREIGN KEY (`site_id`) REFERENCES `site` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
			]]>
			</programlisting>
			<para>我们做个简单的测试, 创建仓库。</para>
			<programlisting>
			<![CDATA[
package common.repository;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import common.domain.ItemPool;

@Repository
public interface ItemPoolRepository extends CrudRepository<ItemPool, Integer> {

}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.restful;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import common.domain.ItemPool;
import common.repository.ItemPoolRepository;

@RestController
public class TestRestController {

	private static final Logger logger = LoggerFactory.getLogger(TestRestController.class);
	@Autowired
	private ItemPoolRepository itemPoolRepository;

	@GetMapping("/test/json/data/type")
	public void jsonType() {

		ItemPool itemPool = new ItemPool();
		itemPool.name = "Which is Operstion System?";
		Map<String, String> opt = new LinkedHashMap<String, String>();
		opt.put("A", "Linux");
		opt.put("B", "Java");
		itemPool.options = opt;
		itemPoolRepository.save(itemPool);

		itemPool = null;
		itemPool = itemPoolRepository.findOne(1);
		System.out.println(itemPool.toString());
	}

}

			]]>
			</programlisting>
			<para>只能用完美来形容</para>
			<programlisting>
			<![CDATA[
mysql> select options from item_pool;
+-----------------------------+
| options                     |
+-----------------------------+
| {"A": "Linux", "B": "Java"} |
+-----------------------------+
1 row in set (0.00 sec)			
			]]>
			</programlisting>
		</section>



		<section id="@Embeddable">
			<title>嵌入</title>
			<section>
				<title>@Embeddable / @Embedded</title>
				<programlisting>
				<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Embeddable;

@Embeddable
public class Address {

    private String city;
    private String district;
    private String street;
    private String community;
}
				
				]]>
				</programlisting>
				<programlisting>
				<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;

@Entity
public class Company {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;

    @Embedded
    private Address address;
}

				]]>
				</programlisting>
				<programlisting>
				<![CDATA[
CREATE TABLE `company` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `city` varchar(255) DEFAULT NULL,
  `community` varchar(255) DEFAULT NULL,
  `district` varchar(255) DEFAULT NULL,
  `street` varchar(255) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
				]]>
				</programlisting>
			</section>
			<section>
				<title>@AttributeOverrides 定义字段名称</title>
				<programlisting>
				<![CDATA[
@Data
@Embeddable
public class Address {
    private String province;
    private String city;
    private String street;
}
				]]>
				</programlisting>
				<programlisting>
				<![CDATA[
@Data
@Entity
@Table
public class Company {
    @Id
    @GeneratedValue
    private Long id;
 
    @Column
    private String name;
 
    // 公司地址
    private Address address;
 
    // 注册地址
    @AttributeOverrides({
        @AttributeOverride(name = "city", column = @Column(name= "location_city")),
        @AttributeOverride(name = "province", column=@Column(name="location_province")),
        @AttributeOverride(name = "street", column = @Column(name="location_street"))
    })
    private Address locationAddress;
 
}
				]]>
				</programlisting>
			</section>
			<section>
				<title>创建复合主键</title>

				<para>定义实体</para>
				<programlisting>
		<![CDATA[
package cn.netkiller.wallet.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Embeddable;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;

@Entity
public class UserToken {
	@EmbeddedId
	@Column(unique = true, nullable = false, insertable = true, updatable = false)
	private UserTokenPrimaryKey primaryKey;

	private String name;
	private String symbol;
	private int decimals;

	public UserToken() {
		// TODO Auto-generated constructor stub
	}

	public UserTokenPrimaryKey getPrimaryKey() {
		return primaryKey;
	}

	public void setPrimaryKey(UserTokenPrimaryKey primaryKey) {
		this.primaryKey = primaryKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	public int getDecimals() {
		return decimals;
	}

	public void setDecimals(int decimals) {
		this.decimals = decimals;
	}

	@Override
	public String toString() {
		return "UserToken [primaryKey=" + primaryKey + ", name=" + name + ", symbol=" + symbol + ", decimals=" + decimals + "]";
	}

	@Embeddable
	public static class UserTokenPrimaryKey implements Serializable {

		private static final long serialVersionUID = 1242827922377178368L;
		private String address;
		private String contractAddress;

		public UserTokenPrimaryKey() {
		}

		public UserTokenPrimaryKey(String address, String contractAddress) {
			this.address = address;
			this.contractAddress = contractAddress;
		}

		public String getAddress() {
			return address;
		}

		public void setAddress(String address) {
			this.address = address;
		}

		public String getContractAddress() {
			return contractAddress;
		}

		public void setContractAddress(String contractAddress) {
			this.contractAddress = contractAddress;
		}

		@Override
		public String toString() {
			return "UserTokenPrimaryKey [address=" + address + ", contractAddress=" + contractAddress + "]";
		}

	}

}		
		]]>
				</programlisting>
				<para>实际效果</para>
				<screen>
		<![CDATA[
CREATE TABLE "user_has_token" (
  "address" varchar(255) NOT NULL,
  "contract_address" varchar(255) NOT NULL,
  "decimals" int(11) NOT NULL,
  "name" varchar(255) DEFAULT NULL,
  "symbol" varchar(255) DEFAULT NULL,
  PRIMARY KEY ("address","contract_address")
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
		]]>
				</screen>
				<programlisting>
		<![CDATA[
package cn.netkiller.wallet.repository;

import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import cn.netkiller.wallet.domain.UserToken;
import cn.netkiller.wallet.domain.UserToken.UserTokenPrimaryKey;;

public interface UserTokenRepository extends JpaRepository<UserToken, UserTokenPrimaryKey> {

	UserToken findOneByPrimaryKey(UserTokenPrimaryKey primaryKey);

	@Query("select ut from UserToken ut where ut.primaryKey.address=:address")
	List<UserToken> getByAddress(@Param("address") String address);

	@Query("select ut from UserToken ut where ut.primaryKey.address=:address and ut.primaryKey.contractAddress=:contractAddress")
	List<UserToken> findByPrimaryKey(@Param("address") String address, @Param("contractAddress") String contractAddress);
}		
		]]>
				</programlisting>
			</section>
		</section>
		<section id="@JsonIgnore">
			<title>@JsonIgnore</title>
			<para>当尸体返回 Json 数据结构是，将不包含 @JsonIgnore 定义变量。</para>
			<programlisting>
				<![CDATA[
	@JsonIgnore  
    @OneToMany(mappedBy = "owner")  
    private List<Pet> pets;  
				]]>
			</programlisting>



		</section>
		<section id="@EnableJpaAuditing">
			<title>@EnableJpaAuditing 开启 JPA 审计功能</title>
			<programlisting>
		<![CDATA[
@SpringBootApplication
@EnableJpaAuditing
public class Application {
    
    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application .class, args);
    }
}		
		]]>
			</programlisting>
			<para>在需要审计实体中加入 @EntityListeners(AuditingEntityListener.class)
			</para>
			<programlisting>
		<![CDATA[
@EntityListeners(AuditingEntityListener.class)
public class Member  implements Serializable {

    private static final long serialVersionUID = -6163675075289529459L;

    @JsonIgnore
    String entityName = this.getClass().getSimpleName();

    @CreatedBy
    String createdBy;

    @LastModifiedBy
    String modifiedBy;
    /**
     * 实体创建时间
     */
    @Temporal(TemporalType.TIMESTAMP)
    @CreatedDate
    protected Date dateCreated = new Date();

    /**
     * 实体修改时间
     */
    @Temporal(TemporalType.TIMESTAMP)
    @LastModifiedDate
    protected Date dateModified = new Date();

     #省略getter setter
}		
		]]>
			</programlisting>
		</section>

		<section id="@Comment">
			<title>注释 @Comment</title>
			<programlisting>
			<![CDATA[
    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("点赞")
    private int likes;
    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("收藏")
    private int favorites;
    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("转发")
    private int forward;			
			]]>
			</programlisting>
		</section>
		<section id="@Pattern">
			<title>@Pattern 数据匹配</title>
			<programlisting>
			<![CDATA[
    /**
     * 性别 CHAR(1) 0:女 1:男
     */
    @Pattern(regexp = "[01]")
    @Column(name = "gender",columnDefinition = "char(1)")
    private String gender;

    /**
     * 身份证号 CHAR(18)
     */
    @Pattern(regexp = "^([1-6][1-9]|50)\\d{4}(18|19|20)\\d{2}((0[1-9])|10|11|12)(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$")
    @Column(name = "identityCard",columnDefinition = "char(18)")
    private String identityCard;

    /**
     * 所属部门 CHAR(2)  01：金融一部, 02：金融二部, 03：创新中心
     */
    @Pattern(regexp = "(01|02|03)")
    @Column(name = "department",columnDefinition = "char(2)")
    private String department;			
			]]>
			</programlisting>
		</section>

		<section id="Inheritance">
			<title>实体继承</title>
			<para>B、C 类继承 A 所有属性，并且主键均为数据库（auto_increment）</para>
			<programlisting>
			<![CDATA[
@MappedSuperclass
@(strategy = InheritanceType.TABLE_PER_CLASS)
public class A{
    @Id
    @GeneratedValue(strategy=GenerationType.IDENTITY)
    private int id;
}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
@Entity
@Table(name="b")
public class B extends A{

}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
@Entity
@Table(name="c")
public class C extends A{

}
			]]>
			</programlisting>
		</section>
	</section>
	<section id="@ElementCollection">
		<title>映射集合属性</title>
		<para>@ElementCollection 很像
			@OneToMany，甚至有些场景可以相互替代，@ElementCollection
			更适合 List/Set/Map/Array
			等数据类型，而 @OneToMany 是对应一个实体。
		</para>
		<para>ElementCollection 缺点是，不能对集合表进行 CURD操作</para>
		<programlisting>
			<![CDATA[
import javax.persistence.*;
import java.util.*;
import javax.persistence.*;

@Entity
public class Employee {
     @Id
     @GeneratedValue(strategy = GenerationType.AUTO)
     private int id;
     private String name;
     
     @ElementCollection
     private Set<Address> address = new HashSet<Address>();
}			
			]]>
		</programlisting>
		<programlisting>
			<![CDATA[
import javax.persistence.*;

@Embeddable
public class Address {
     private String province;
     private String city;
     private String state;
}
			]]>
		</programlisting>
		<section>
			<title>List 集合</title>
			<para>List 集合</para>
			<programlisting>
			<![CDATA[
	@ElementCollection(targetClass = String.class) //指定集合中元素的类型
	@CollectionTable(name = "school_inf", joinColumns = @JoinColumn(name="pid",nullable = false)) //表示外键不能为空
	@Column(name = "school_name") 		//指定表中保存集合元素的列名
	@OrderColumn(name = "list_order") 	//索引列
	private List<String> schools = new ArrayList<String>();		
			]]>
			</programlisting>
		</section>
		<section>
			<title>数组集合</title>
			<para>数组集合</para>
			<programlisting>
			<![CDATA[
@Entity
@Table
public class Student {

	@Id @Column
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer sid;
	private String name;
	private Integer age;
	@ElementCollection(targetClass=String.class) //集合中元素的类型
	@CollectionTable(name = "school", joinColumns = @JoinColumn(name="sid",nullable = false))//指定外键的名称为sid,并且不能为空
	@Column(name = "school_name") //指定schools属性，在表中的列名
	@OrderColumn(name = "array_order")
	private String[] schools = new String[3];
	
}
		
			]]>
			</programlisting>

		</section>
		<section>
			<title>Map 集合</title>
			<para>Map 集合</para>
			<programlisting>
			<![CDATA[
@Entity
@Table(name = "student")
public class Student {

	@Id @Column
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer sid;
	private String name;
	private Integer age;
	@ElementCollection(targetClass = Float.class) //对于Map类型的属性：指定的是Value的类型
	@CollectionTable(name = "score_info", joinColumns = @JoinColumn(name="sid", nullable = false))
	@MapKeyClass(String.class) 		// 指定Map中key的类型
	@MapKeyColumn(name="suject") 	//指定索引列，也就是key的列名
	@Column(name = "score") //映射保存Map, Value的列名
	private Map<String, Float> scores = new HashMap<String, Float>(); //科目和成绩

}			
			]]>
			</programlisting>
		</section>

		<section id="Set">
			<title>Set 集合</title>
			<para>Set 集合</para>
			<programlisting>
			<![CDATA[
	@ElementCollection
    private final Set<String> address = new HashSet<String>();			
			]]>
			</programlisting>
			<programlisting>
				<![CDATA[
    @ElementCollection
    @CollectionTable(joinColumns = @JoinColumn(name = "pid", nullable = false))
    private Set<Status> address = new HashSet<Status>();
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("Stable Diffusion Lora 表")
public class Lora implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Long id;

    @Column(unique = true, nullable = false, insertable = true, updatable = true)
    @Comment("模型名称")
    private String name;

    @Comment("模型描述")
    private String description;

    @ElementCollection(fetch = FetchType.EAGER)
    private Set<String> keyword = new HashSet<String>();

    @Comment("状态")
    private boolean status;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    private Date mtime;
}
		
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Lora;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.Set;

@Repository
public interface LoraRepository extends CrudRepository<Lora, Integer> {

}		
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
package cn.netkiller.controller;

import cn.netkiller.domain.Lora;
import cn.netkiller.repository.LoraRepository;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Optional;
import java.util.Set;

@RestController
@Slf4j
@RequestMapping("/lora")
public class LoraController {
    @Autowired
    private LoraRepository loraRepository;

    @GetMapping("test")
    public Lora test() {
        Lora lora = new Lora();
        lora.setName("中国风");
        lora.setDescription("中国风格图片");
        lora.setKeyword(Set.of("茶", "武术", "剪纸"));
        loraRepository.save(lora);

        lora = new Lora();
        lora.setName("二次元");
        lora.setDescription("二次元风格图片");
        lora.setKeyword(Set.of("日本", "机甲", "手办"));
        loraRepository.save(lora);
        return lora;
    }

    @GetMapping("query")
    public Iterable<Lora> query() {
        Iterable<Lora> lora = loraRepository.findAll();
        return lora;
    }

}		
				]]>
			</programlisting>

		</section>
		<section>
			<title>外键名称</title>

			<programlisting>
				<![CDATA[
    @ElementCollection
    @CollectionTable(joinColumns = @JoinColumn(name = "pid", nullable = false))
    private Set<Status> address = new HashSet<Status>();
				]]>
			</programlisting>
		</section>
		<section>
			<title>集合表子查询</title>
			<para>集合表子查询，以Set为例</para>
			<programlisting>
		<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Lora;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.Set;

@Repository
public interface LoraRepository extends CrudRepository<Lora, Integer> {
    Optional<Lora> findByKeywordIn(Set keyword);
}
		]]>
			</programlisting>
			<para>查询接口</para>
			<programlisting>
		<![CDATA[
	@GetMapping("keyword")
    public Optional<Lora> keywordTest(@RequestParam("key") Set<String> keyword) {

        Optional<Lora> lora = loraRepository.findByKeywordIn(keyword);
        return lora;
    }
		]]>
			</programlisting>
			<para>GET 传递 Set 参数的方法如下</para>
			<programlisting>
		<![CDATA[
curl -X 'GET' \
  'http://localhost:8080/lora/keyword?key=%E8%8C%B6&key=%E6%AD%A6%E6%9C%AF&key=%E9%80%A0%E7%BA%B8' \
  -H 'accept: */*'
		]]>
			</programlisting>
		</section>
	</section>

	<section id="ForeignKey">
		<title>外键</title>

		<section id="JoinColumn">
			<title>@JoinColumn</title>
			<para>@JoinColumn与@Column注释类似，它的定义如下代码所示。 </para>
			<screen>
			<![CDATA[
@Target({METHOD, FIELD}) @Retention(RUNTIME) 

public @interface JoinColumn { 

String name() default ""; 

String referencedColumnName() default ""; 

boolean unique() default false; 

boolean nullable() default true; 

boolean insertable() default true; 

boolean updatable() default true; 

String columnDefinition() default ""; 

String table() default ""; 

}
			]]>
			</screen>
			<para>定义外键名称 @ForeignKey(name = "picture_id")</para>
			<programlisting>
				<![CDATA[
    @Id
    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "id", foreignKey = @ForeignKey(name = "picture_id"))
    private Picture picture;				
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
CREATE TABLE `picture_psychoanalysis` (
  `analysis` text COMMENT '心里分析',
  `ctime` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `emotion` varchar(255) DEFAULT NULL COMMENT '感谢|愉快|抱怨|愤怒|喜爱|厌恶|恐惧|悲伤',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `replies` text COMMENT '建议回复话术',
  `sentiment` varchar(255) DEFAULT NULL COMMENT '负向情绪|中性情绪|正向情绪',
  `id` bigint unsigned NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `picture_id` FOREIGN KEY (`id`) REFERENCES `picture` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文生图心里分析'				
				]]>
			</programlisting>
		</section>
		<section id="OneToOne">
			<title>@OneToOne</title>
			<para>一对一表结构，如下面ER图所示，users表是用户表里面有登陆信息，profile
				保存的时死人信息，这样的目的是我们尽量减少users表的字段，在频繁操作该表的时候性能比较好，另外一个目的是为了横向水平扩展。
			</para>
			<programlisting>
			<![CDATA[
    +----------+             +------------+
    | users    |             | profile    |
    +----------+             +------------+
    | id       | <---1:1---o | id         |
    | name     |             | sex        |    
    | password |             | email      |    
    +----------+             +------------+ 
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "users")
public class Users implements Serializable {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	private String password;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	@Override
	public String toString() {
		return "Users [id=" + id + ", name=" + name + ", password=" + password + "]";
	}
}

			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Table;

@Entity
@Table(name = "profile")
public class Profile implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2500499458196257167L;
	@Id
	@OneToOne
	@JoinColumn(name = "id")
	private Users users;

	private int age;
	private String sex;
	private String email;

	public Users getUsers() {
		return users;
	}

	public void setUsers(Users users) {
		this.users = users;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	@Override
	public String toString() {
		return "Profile [users=" + users + ", age=" + age + ", sex=" + sex + ", email=" + email + "]";
	}

}

			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
CREATE TABLE `users` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`password` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
CREATE TABLE `profile` (
	`age` INT(11) NOT NULL,
	`email` VARCHAR(255) NULL DEFAULT NULL,
	`sex` VARCHAR(255) NULL DEFAULT NULL,
	`id` INT(11) NOT NULL,
	PRIMARY KEY (`id`),
	CONSTRAINT `FK6x079ilawxjrfsljwyyi5ujjq` FOREIGN KEY (`id`) REFERENCES `users` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			]]>
			</programlisting>
			<para>如果第二张表关联的并非主表的PK（主键）需要使用 referencedColumnName 指定。</para>
			<programlisting>
			<![CDATA[
@JoinColumn(name = "member_id",referencedColumnName="member_id") 			
			]]>
			</programlisting>
			<section>
				<title>案例一</title>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;

}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;

@Entity
public class BookDetail {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private long numberOfPages;

    @OneToOne
    private Book book;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `book` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

CREATE TABLE `book_detail` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `number_of_pages` bigint NOT NULL,
  `book_id` bigint DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_29qtqq9pgixv8kqlt0woj1hyp` (`book_id`),
  CONSTRAINT `FKl1hmgccsvfwcxhem3qw6l7gpm` FOREIGN KEY (`book_id`) REFERENCES `book` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
					]]>
				</programlisting>
			</section>

			<section>
				<title></title>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;

@Entity
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "book_detail")
    private BookDetail bookDetail;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;

@Entity
public class BookDetail {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;


    private long numberOfPages;


    @OneToOne(cascade = CascadeType.ALL, mappedBy = "bookDetail")
    private Book book;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `book` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `book_detail` bigint DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_d8im4vqhlm2eo0mj9lwjvib94` (`book_detail`),
  CONSTRAINT `FKagqqxsh6783b9dd9197ow49a5` FOREIGN KEY (`book_detail`) REFERENCES `book_detail` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

CREATE TABLE `book_detail` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `number_of_pages` bigint NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci					
					]]>
				</programlisting>
			</section>
			<section>
				<title></title>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String name;

}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.OneToOne;

@Entity
public class Profile {
    @Id
    @OneToOne
    private Users users;

    private int age;


}					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

CREATE TABLE `profile` (
  `age` int NOT NULL,
  `users_id` bigint NOT NULL,
  PRIMARY KEY (`users_id`),
  CONSTRAINT `FKi6d1noonlpe6oyk6pnwc1q49e` FOREIGN KEY (`users_id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
					]]>
				</programlisting>
				<para>指定一对一字段名，默认是表名+PK，例如上面的例子 users_id，如果我们希望自定义字段名，可以使用
					@JoinColumn(name = "id")
				</para>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import lombok.Data;

@Entity
@Data
public class Profile {
    @Id
    @OneToOne
    @JoinColumn(name = "id")
    private Users users;

    private int age;
    private boolean sex;
}
					
					]]>
				</programlisting>
				<para>效果展示</para>
				<programlisting>
					<![CDATA[
CREATE TABLE `profile` (
  `age` int NOT NULL,
  `sex` bit(1) NOT NULL,
  `id` bigint NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `FK6x079ilawxjrfsljwyyi5ujjq` FOREIGN KEY (`id`) REFERENCES `users` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci					
					]]>
				</programlisting>
			</section>
			<section>
				<title>does not define an IdClass</title>
				<para>如果一对一的关系中，我们希望两端都是用 id 字段，而@OneToOne 一端是对象，必须定义一个 @Id，这时加入
					@MapsId 可以解决 does not define an IdClass 错误，这时一段表中没有 @Id
				</para>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

@Entity
@Table
@Data
@DynamicInsert
@DynamicUpdate
@Comment("用户表")
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String username;
    private String password;
    private boolean status;

}

					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Table;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.*;

@Entity
@Table
@Data
@DynamicInsert
@DynamicUpdate
@Comment("用户信息表")
public class Profile {

    @Id
    @Column(name = "id")
    private Long id;

    @MapsId
    @OneToOne
    @JoinColumn(name = "id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Users users;

    private int age;
    private boolean sex;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.repository.demo;

import cn.netkiller.domain.demo.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TestRepository extends JpaRepository<Profile, Long> {
}

					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `password` varchar(255) DEFAULT NULL,
  `status` bit(1) NOT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表'

CREATE TABLE `profile` (
  `id` bigint NOT NULL,
  `age` int NOT NULL,
  `sex` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `FK6x079ilawxjrfsljwyyi5ujjq` FOREIGN KEY (`id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户信息表'
					]]>
				</programlisting>
			</section>
			<section id="@PrimaryKeyJoinColumn">
				<title>共享主键</title>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

@Entity
@Table
@Data
@DynamicInsert
@DynamicUpdate
@Comment("用户表")
public class Users {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;
    private String username;
    private String password;
    private boolean status;

    @OneToOne(mappedBy = "users", cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private Profile profile;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain.demo;

import jakarta.persistence.Table;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.*;

@Entity
@Table
@Data
@DynamicInsert
@DynamicUpdate
@Comment("用户信息表")
public class Profile {

    @Id
    @Column(name = "id")
    private Long id;

    @MapsId
    @OneToOne
    @JoinColumn(name = "id")
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Users users;

    private int age;
    private boolean sex;
}
					
					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `users` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `password` varchar(255) DEFAULT NULL,
  `status` bit(1) NOT NULL,
  `username` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户表'

CREATE TABLE `profile` (
  `id` bigint NOT NULL,
  `age` int NOT NULL,
  `sex` bit(1) NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `FK6x079ilawxjrfsljwyyi5ujjq` FOREIGN KEY (`id`) REFERENCES `users` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户信息表'					
					]]>
				</programlisting>
			</section>
			<section>
				<title>null identifier</title>
				<para>@OneToOne 保存提示 null identifier，经过排查需要配置</para>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.CascadeType;
import jakarta.persistence.ForeignKey;
import jakarta.persistence.Table;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.*;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("文生图心里分析")

public class PicturePsychoanalysis implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;
    
    @Comment("Robert Plutchik 情感轮盘")
    @Column(columnDefinition = "json")
    public String plutchik;
    
    @Id
    @Column(name = "id")
    @Comment("Picture Id 一对一关系")
    private Long id;
    @MapsId
    @OneToOne(cascade = CascadeType.MERGE)
    @JoinColumn(name = "id", insertable = true, updatable = false, columnDefinition = "bigint unsigned", foreignKey = @ForeignKey(name = "picture_id"))
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Picture picture;
    @Comment("负向情绪|中性情绪|正向情绪")
    private String sentiment;
    @Comment("感谢|愉快|抱怨|愤怒|喜爱|厌恶|恐惧|悲伤")
    private String emotion;
    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("建议回复话术")
    private String replies;
    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("心里分析")
    private String analysis;
    //    public JSONObject plutchik;
    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    private Date mtime;
}
					]]>
				</programlisting>
				<para>讲 @OneToOne 增加 @OneToOne(cascade = CascadeType.MERGE) 参数，如果
					CascadeType.ALL 需要改为 CascadeType.MERGE
				</para>
				<programlisting>
					<![CDATA[
	@Id
    @Column(name = "id")
    @Comment("Picture Id 一对一关系")
    private Long id;
    @MapsId
    @OneToOne(cascade = CascadeType.MERGE)
    @JoinColumn(name = "id", insertable = true, updatable = false, columnDefinition = "bigint unsigned", foreignKey = @ForeignKey(name = "picture_id"))
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Picture picture;					
					]]>
				</programlisting>
			</section>
		</section>
		<section id="OneToMany">
			<title>OneToMany 一对多</title>
			<para>我们要实现一个一对多实体关系，ER 图如下</para>
			<programlisting>
			<![CDATA[
    +----------+          +------------+
    | Classes  |          | Student    |
    +----------+          +------------+
    | id       | <---+    | id         |
    | name     |     |    | name       |    
    +----------+     +--o | classes_id |    
                          +------------+ 
    
			]]>
			</programlisting>
			<para>classes 表需要 OneToMany 注解，Student 表需要 ManyToOne
				注解，这样就建立起了表与表之间的关系
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.Table;

@Entity 
@Table(name="classes") 
public class Classes implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = -5422905745519948312L;
	@Id 
	@GeneratedValue(strategy=GenerationType.AUTO) 
	private int id; 
	private String name; 
	    
	@OneToMany(cascade=CascadeType.ALL,mappedBy="classes")    
	private Set<Student> students;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Set<Student> getStudents() {
		return students;
	}

	public void setStudents(Set<Student> students) {
		this.students = students;
	}

	@Override
	public String toString() {
		return "classes [id=" + id + ", name=" + name + ", students=" + students + "]";
	} 
}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;

@Entity
@Table(name = "student")
public class Student implements Serializable{
	/**
	 * 
	 */
	private static final long serialVersionUID = 6737037465677800326L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;

	// 若有多个cascade，可以是：{CascadeType.PERSIST,CascadeType.MERGE}
	@ManyToOne(cascade = { CascadeType.ALL })
	@JoinColumn(name = "classes_id") 
	private Classes classes;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Classes getClasses() {
		return classes;
	}

	public void setClasses(Classes classes) {
		this.classes = classes;
	}

	@Override
	public String toString() {
		return "Student [id=" + id + ", name=" + name + ", classes=" + classes + "]";
	}

}

			]]>
			</programlisting>
			<para>最终 SQL 表如下</para>
			<programlisting>
			<![CDATA[
CREATE TABLE `classes` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;	
			
CREATE TABLE `student` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`class_id` INT(11) NULL DEFAULT NULL,
	PRIMARY KEY (`id`),
	INDEX `FKnsl7w2nw6o6eq53hqlxfcijpm` (`class_id`),
	CONSTRAINT `FKnsl7w2nw6o6eq53hqlxfcijpm` FOREIGN KEY (`class_id`) REFERENCES `classes` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
      Classes classes=new Classes(); 
      classes.setName("One"); 
        
      Student st1=new Student(); 
      st1.setSname("jason"); 
      st1.setClasses(classes); 
      studentRepostitory.save(st1); 
        
      Student st2=new Student(); 
      st2.setSname("neo"); 
      st2.setClasses(classes); 
      studentRepostitory.save(st2); 
			]]>
			</programlisting>
		</section>
		<section id="ManyToMany">
			<title>ManyToMany 多对多</title>
			<para>用户与角色就是一个多对多的关系，多对多是需要中间表做关联的。所以我方需要一个 user_has_role 表。</para>
			<programlisting>
			<![CDATA[
    +----------+          +---------------+            +--------+
    | users    |          | user_has_role |            | role   |
    +----------+          +---------------+            +--------+
    | id       | <------o | user_id       |      /---> | id     |
    | name     |          | role_id       | o---+      | name   |
    | password |          |               |            |        |
    +----------+          +---------------+            +--------+
			]]>
			</programlisting>
			<para>创建 User 表</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.Table;
import javax.persistence.JoinColumn;

@Entity
@Table(name = "users")
public class Users implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2480194112597046349L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	private String password;

	@ManyToMany(fetch = FetchType.EAGER)
	@JoinTable(name = "user_has_role", joinColumns = { @JoinColumn(name = "user_id", referencedColumnName = "id") }, inverseJoinColumns = { @JoinColumn(name = "role_id", referencedColumnName = "id") })
	private Set<Roles> roles;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public Set<Roles> getRoles() {
		return roles;
	}

	public void setRoles(Set<Roles> roles) {
		this.roles = roles;
	}

	@Override
	public String toString() {
		return "Users [id=" + id + ", name=" + name + ", password=" + password + ", roles=" + roles + "]";
	}

}
			]]>
			</programlisting>
			<para>创建 Role 表</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain.test;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToMany;
import javax.persistence.Table;

@Entity
@Table(name = "roles")
public class Roles implements Serializable {
	private static final long serialVersionUID = 6737037465677800326L;
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private int id;
	private String name;
	@ManyToMany(mappedBy = "roles")
	private Set<Users> users;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Set<Users> getUsers() {
		return users;
	}

	public void setUsers(Set<Users> users) {
		this.users = users;
	}

	@Override
	public String toString() {
		return "Roles [id=" + id + ", name=" + name + ", users=" + users + "]";
	}

}

			]]>
			</programlisting>
			<para>最终产生数据库表如下</para>
			<programlisting>
			<![CDATA[
CREATE TABLE `users` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	`password` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;	

CREATE TABLE `roles` (
	`id` INT(11) NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(255) NULL DEFAULT NULL,
	PRIMARY KEY (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			
CREATE TABLE `user_has_role` (
	`user_id` INT(11) NOT NULL,
	`role_id` INT(11) NOT NULL,
	PRIMARY KEY (`user_id`, `role_id`),
	INDEX `FKsvvq61v3koh04fycopbjx72hj` (`role_id`),
	CONSTRAINT `FK2dl1ftxlkldulcp934i3125qo` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`),
	CONSTRAINT `FKsvvq61v3koh04fycopbjx72hj` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`)
)
COLLATE='utf8_general_ci'
ENGINE=InnoDB;
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
			]]>
			</programlisting>
		</section>
		<section id="orphanRemoval">
			<title>外键级联删除</title>
			<para>orphanRemoval 是 JPA 定义，并不是数据库原生</para>
			<programlisting>
					<![CDATA[
    @Id
    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = "id", foreignKey = @ForeignKey(name = "picture_id"))
    private Picture picture;						
					]]>
			</programlisting>
			<para>orphanRemoval = true 可以实现数据级联删除</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.domain;

import java.io.Serializable;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.OneToMany;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonIgnore;

@Entity
@Table(name = "member")
public class Member implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private int id;

	private String name;
	private String sex;
	private int age;
	private String wechat;

	@Column(unique = true)
	private String mobile;
	private String picture;
	private String ipAddress;

	@JsonIgnore
	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "member")
	private Set<Comment> comment;
	@JsonIgnore
	@OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, mappedBy = "member")
	private Set<StatisticsHistory> statisticsHistory;

	public Member() {
	}

	public Member(int id) {
		this.id = id;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getSex() {
		return sex;
	}

	public void setSex(String sex) {
		this.sex = sex;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}

	public String getWechat() {
		return wechat;
	}

	public void setWechat(String wechat) {
		this.wechat = wechat;
	}

	public String getMobile() {
		return mobile;
	}

	public void setMobile(String mobile) {
		this.mobile = mobile;
	}

	public String getPicture() {
		return picture;
	}

	public void setPicture(String picture) {
		this.picture = picture;
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public void setIpAddress(String ipAddress) {
		this.ipAddress = ipAddress;
	}

	@Override
	public String toString() {
		return "Member [id=" + id + ", name=" + name + ", sex=" + sex + ", age=" + age + ", wechat=" + wechat + ", mobile=" + mobile + ", picture=" + picture + ", ipAddress=" + ipAddress + "]";
	}

}			
			]]>
			</programlisting>
		</section>
		<section id="CascadeType">
			<title>外键级联操作</title>
			<para>cascade 属性： 指定级联操作的行为(可多选)</para>
			<programlisting>
				<![CDATA[
CascadeType.PERSIST：级联新增（又称级联保存）：对A对象保存时也会对B对象进行保存。并且，只有A类新增时，会级联B对象新增。若B对象在数据库存在则抛异常。对应EntityManager的presist方法。
CascadeType.MERGE：级联合并（级联更新）：指A类新增或者变化，会级联B对象（新增或者变化）。对应EntityManager的merge方法。
CascadeType.REMOVE：级联删除：只有A类删除时，会级联删除B类,即在设置的那一端进行删除时，另一端才会级联删除。对应EntityManager的remove方法。
CascadeType.REFRESH：级联刷新：获取A对象时也重新获取最新的B对象。对EntityManager的refresh(object)方法。即会重新查询数据库里的最新数据（用的比较少）
CascadeType.DETACH：级联分离。
CascadeType.ALL：级联所有操作。
				]]>
			</programlisting>
			<section id="CascadeType.PERSIST">
				<title>CascadeType.PERSIST</title>
				<programlisting>
					<![CDATA[
@OneToMany(mappedBy = "boss", cascade = CascadeType.PERSIST)  
private List<Staff> staffList;	
					]]>
				</programlisting>
			</section>
			<section id="CascadeType.REMOVE">
				<title>CascadeType.REMOVE</title>
				<programlisting>
					<![CDATA[
@OneToMany(mappedBy = "boss", cascade = CascadeType.REMOVE)  
private List<Staff> staffList;
					]]>
				</programlisting>
			</section>
			<section id="CascadeType.REMOVE">
				<title>CascadeType.MERGE</title>
				<programlisting>
				<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@Data
@DynamicUpdate
@DynamicInsert
@Comment("客户信息表")
public class Consumer implements Serializable {
    @Serial
    public static final long serialVersionUID = -1L;

    @Id
//    @GeneratedValue(strategy = GenerationType.IDENTITY)
//    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("唯一ID")
//    @Column(name = "id", nullable = false, columnDefinition = "int unsigned")
    private Integer id;

    //    CascadeType.MERGE 集联更新，会更新外键表数据，覆盖
    @OneToOne(cascade = CascadeType.MERGE, optional = false)
    @MapsId
    @JoinColumn(name = "id", nullable = false, insertable = true, updatable = false, columnDefinition = "int unsigned", foreignKey = @ForeignKey(name = "device_id"))
    @JsonIgnore
    private Device device;

    @Comment("姓名")
    @Column(length = 8)
    private String name;
    @Comment("昵称")
    @Column(length = 16)
    private String nickname;
    @Comment("头像")
    private String avatar;
    @Comment("性别")
    private Boolean gender;
    @Comment("年龄")
    private Integer age;
    @Comment("生日")
    @JsonFormat(pattern = "yyyy-MM-dd")
    @Temporal(TemporalType.DATE)
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birthday;
    @Comment("地址")
    private String address;
    @Comment("电话")
    @Column(length = 15)
    private String mobile;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
//    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
//    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date mtime;

    public Consumer() {
    }

}

				]]>
				</programlisting>
				<programlisting>
				<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table(uniqueConstraints = {@UniqueConstraint(columnNames = {"name", "business_id"})}
//        indexes = {
//        @Index(name = "key_device_unique", columnList = "name"),
//        @Index(name = "key_device_unique", columnList = "business_id")
//}
)
@DynamicUpdate
@DynamicInsert
@Data
//@Builder
@Comment("设备表")
public class Device implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @Column(nullable = false, length = 32)
    @Comment("设备名称")
    private String name;

    @Column(unique = true, nullable = false, insertable = true, updatable = false, length = 32)
    @Comment("序列号")
    private String sn;

    @Comment("型号")
    @Column(length = 16)
    private String model;
    @Comment("固件版本")
    @Column(length = 16)
    private String fireware;
    @Comment("软件版本")
    @Column(length = 16)
    private String version;

    @Column(columnDefinition = "int unsigned")
    @Comment("存储容量")
    private Integer capacity = null;

    @Column(columnDefinition = "int unsigned")
    @Comment("可用容量")
    private Integer available;

    @Column(columnDefinition = "int unsigned")
    @Comment("内存容量")
    private Integer memory;

    @Comment("移动网络提供商")
    @Column(columnDefinition = "enum('中国移动','中国电信','中国联通','其他') DEFAULT NULL")
    private String provider;

    @Comment("IMEI")
    @Column(length = 15)
    private String imei;

    @Comment("MEID")
    @Column(length = 15)
    private String meid;

    @Comment("ICCID")
    @Column(length = 20)
    private String iccid;

    @Comment("wlan 无线 mac 地址")
    @Column(length = 17)
    private String wlan;
    @Column(length = 17)
    @Comment("蓝牙 mac 地址")
    private String bluetooth;

    @Comment("品牌")
    private String brand;

    @Comment("CPU")
    private String cpu;

    @Comment("设备驱动")
    private String device;

    @Comment("显示屏")
    private String display;

    @Comment("设备标识")
    private String fingerprint;

    @Comment("硬件")
    private String hardware;

    @Comment("制造商")
    private String manufacturer;

    @Comment("产品")
    private String product;

    @Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
    @Comment("设备状态，正常=Y，其他=N")
    private String status;

    @Comment("设备状态原因")
    @Column(columnDefinition = "enum('未激活','激活','充值','正常','禁用','冻结') DEFAULT '正常'")
    private String reason;

    @Comment("设备状态描述")
    private String description;

    @CreatedDate
    @Column(nullable = true, insertable = true, updatable = true)
    @Temporal(TemporalType.TIMESTAMP)
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("访问时间")
    private Date atime;

    @ManyToOne
    @JoinColumn(name = "business_id")
    private Business business;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    //    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    //    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("修改时间")
    private Date mtime;

    public Device() {

    }

}
				]]>
				</programlisting>
				<programlisting>
				<![CDATA[
    @Transactional
    public Optional<Consumer> update(String deviceName, Consumer consumer) {
        Device device = new Device();
        device.setId(consumer.getId());
        device.setName(deviceName);
        consumer.setDevice(device);
        log.debug(consumer.toString());
        consumer = consumerRepository.save(consumer);
        return Optional.ofNullable(consumer);
    }
				]]>
				</programlisting>
				<para>向 Consumer 表中增加数据，Device 表受到影响，会修改里面的数据。这就是 CascadeType.MERGE
					作用，如果不想影响 Device 数据，改为 CascadeType.PERSIST
				</para>
				<programlisting>
				<![CDATA[
@OneToOne(cascade = CascadeType.MERGE, optional = false)
				]]>
				</programlisting>
			</section>
			<section>
				<title>MySQL ON DELETE CASCADE</title>
				<para>@OnDelete(action = OnDeleteAction.CASCADE)</para>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicUpdate;
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@Data
@Comment("文生图心里分析")
public class PicturePsychoanalysis implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @OneToOne()
    @JoinColumn(name = "id", foreignKey = @ForeignKey(name = "picture_id"))
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Picture picture;

//    @Column(unique = true, nullable = false, insertable = true, updatable = false)
//    @Comment("会话")
//    private String session;

    @Comment("负向情绪|中性情绪|正向情绪")
    private String sentiment;

    @Comment("感谢|愉快|抱怨|愤怒|喜爱|厌恶|恐惧|悲伤")
    private String emotion;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("建议回复话术")
    private String replies;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("心里分析")
    private String analysis;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    private Date mtime;
}
					
					]]>
				</programlisting>
				<para></para>
				<programlisting>
					<![CDATA[
CREATE TABLE `picture_psychoanalysis` (
  `analysis` text COMMENT '心里分析',
  `ctime` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `emotion` varchar(255) DEFAULT NULL COMMENT '感谢|愉快|抱怨|愤怒|喜爱|厌恶|恐惧|悲伤',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `replies` text COMMENT '建议回复话术',
  `sentiment` varchar(255) DEFAULT NULL COMMENT '负向情绪|中性情绪|正向情绪',
  `id` bigint unsigned NOT NULL,
  PRIMARY KEY (`id`),
  CONSTRAINT `picture_id` FOREIGN KEY (`id`) REFERENCES `picture` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文生图心里分析'					
					]]>
				</programlisting>
			</section>
		</section>
		<section id="@JoinTable">
			<title>@JoinTable</title>
			<screen>
				<![CDATA[
@JoinTable(name = "table")				
				]]>
			</screen>
			<programlisting>
				<![CDATA[
@OneToMany(cascade = CascadeType.ALL)
@JoinTable
private List<UserProfile> userProfile;				
				]]>
			</programlisting>

			<programlisting>
				<![CDATA[
@JoinTable(name = "cust_user",
    joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id")
)		
				]]>
			</programlisting>

			<programlisting>
				<![CDATA[
@JoinTable(name = "cust_user",
    inverseJoinColumns = @JoinColumn(name = "user_ext_id", referencedColumnName = "id")
)			
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
@JoinTable(name = "cust_user",
    joinColumns = @JoinColumn(name = "user_id", referencedColumnName = "id"),
    inverseJoinColumns = @JoinColumn(name = "user_ext_id", referencedColumnName = "id"),
    uniqueConstraints = {
        @UniqueConstraint(name = "unique_user_id", columnNames = {"user_id"}),
        @UniqueConstraint(name = "unique_user_ext_id", columnNames = {"user_ext_id"})
    }
)		
				]]>
			</programlisting>
			<section>
				<title>多对多实例</title>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;

import java.io.Serializable;

@Entity
@Table
@Data
public class Consumer implements Serializable {
    public static final long serialVersionUID = 7998903421265538801L;
    public String firstName;
    public String lastName;
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    public Integer id;

    @OneToOne(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinTable(name = "consumer_has_device",
            joinColumns =
                    {@JoinColumn(name = "consumer_id", referencedColumnName = "id")},
            inverseJoinColumns =
                    {@JoinColumn(name = "device_id", referencedColumnName = "id")})
    private Device device;

    public Consumer() {
    }

}

					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@Data
@Comment("设备表")
public class Device implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @Comment("设备名称")
    private String name;

    @Comment("型号")
    private String model;
    @Comment("版本")
    private String fireware;
    @Comment("版本")
    private String version;

    @Column(unique = true, nullable = false, insertable = true, updatable = false)
    @Comment("序列号")
    private String sn;
    @Comment("ip")
    private String ip;

    @Comment("mac")
    private String mac;

    @Temporal(TemporalType.TIMESTAMP)
    @Comment("最后一次登陆时间")
    private Date lastTime;

    @Column(columnDefinition = "enum('Y','N') DEFAULT 'N'")
    @Comment("设备状态")
    private boolean status;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    private Date mtime;
}

					]]>
				</programlisting>
				<programlisting>
					<![CDATA[
CREATE TABLE `consumer` (
  `id` int unsigned NOT NULL AUTO_INCREMENT,
  `first_name` varchar(255) DEFAULT NULL,
  `last_name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

CREATE TABLE `device` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `ctime` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `fireware` varchar(255) DEFAULT NULL COMMENT '版本',
  `ip` varchar(255) DEFAULT NULL COMMENT 'ip',
  `last_time` datetime(6) DEFAULT NULL COMMENT '最后一次登陆时间',
  `mac` varchar(255) DEFAULT NULL COMMENT 'mac',
  `model` varchar(255) DEFAULT NULL COMMENT '型号',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `name` varchar(255) DEFAULT NULL COMMENT '设备名称',
  `sn` varchar(255) NOT NULL COMMENT '序列号',
  `status` enum('Y','N') DEFAULT 'N' COMMENT '设备状态',
  `version` varchar(255) DEFAULT NULL COMMENT '版本',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_bg7pgyvfwv0q65tmquumxff3d` (`sn`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='设备表'

CREATE TABLE `consumer_has_device` (
  `device_id` int unsigned DEFAULT NULL,
  `consumer_id` int unsigned NOT NULL,
  PRIMARY KEY (`consumer_id`),
  UNIQUE KEY `UK_ibck20j1s6ch97lncg99uvpgh` (`device_id`),
  CONSTRAINT `FKcottusf6sx3bnouahp29vjdwk` FOREIGN KEY (`device_id`) REFERENCES `device` (`id`),
  CONSTRAINT `FKq7u4eyw8pmfkwg4yymjljx8ra` FOREIGN KEY (`consumer_id`) REFERENCES `consumer` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
					]]>
				</programlisting>
			</section>
		</section>
		<section id="@OrderBy">
			<title>@OrderBy</title>
			<programlisting>
				<![CDATA[
// JPA 默认根据 Student 的 ID 主键对 studentList 集合数据进行递增排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy
private List<Student> studentList;
 
// 手动指定 id 字段的排序方式，ASC 递增排序，DESC 递减排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy("id desc")
private List<Student> studentList;
 
// 手动指定按照 salary 属性进行递减排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy("salary desc")
private List<Student> studentList;
 
// 手动指定按照多个属性进行排序
// 下面将根据 sex 和 salay 进行递增排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy("sex,salary")
private List<Student> studentList;
 
// 下面将根据 sex 递增排序，salary 递增排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy("sex asc,salary asc")
private List<Student> studentList;
 
// 下面将根据 sex 递增排序，salary 递减排序
@OneToMany(cascade = CascadeType.ALL)
@OrderBy("sex asc,salary desc")
private List<Student> studentList;				
				]]>
			</programlisting>
		</section>
		<section id="@JsonIgnoreProperties">
			<title>@JsonIgnoreProperties</title>
			<para>当使用 @OneToMany 与 @ManyToOne 相互引用时，你会发现产生了循环调用，此时可以使用 @JsonIgnoreProperties 避免出现循环，此时加入 @Transient 或 @JsonIgnore 注解可以解决，但要该字段就没有外键数据了。</para> 
			<programlisting>
			<![CDATA[
@Entity
public class Subarea {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private long id;

  @OneToMany
  @JsonIgnoreProperties(value = {"subarea"})
  @JoinColumn(name = "subarea_id")
  private List<SubareaSet> subareaSetList;

}

@Entity
public class SubareaSet {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private long id;
  
  @ManyToOne
  @JsonIgnoreProperties(value = {"subareaSetList"})
  private Subarea subarea;
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>允许外键为 NULL</title>
			<para>optional = true 允许外键为空</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain.story;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("图片表")
//@SecondaryTable(name = "picture_psychoanalysis",
//        pkJoinColumns = @PrimaryKeyJoinColumn(name = "id")
//)
public class Picture implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "bigint unsigned")
    @Comment("主键")
    private Long id;

    @Comment("设备")
    private String device;

    @Column(unique = true, nullable = false, insertable = true, updatable = false, length = 36)
    @Comment("会话")
    private String session;

    @Comment("提示词")
    private String prompt;

    @Comment("英文提示词")
    @Column(length = 1024)
    private String translate;

    @Column(nullable = true)
    @Comment("缩图")
    private String thumbnail;

    @Column(nullable = true)
    @Comment("原图")
    private String image;

    @Column(nullable = true)
    @Comment("故事音频")
    private String audio;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("故事")
    private String story;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("拼音")
    private String pinyin;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("英文")
    private String english;

    @Comment("共享")
    private boolean share;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("点赞数")
    private Integer likes;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("收藏数")
    private Integer favorites;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("转发数")
    private Integer forward;

    @Comment("人工审核，NULL 未审核，true 通过，false 未通过")
    private Boolean audit;

    @ManyToOne(fetch = FetchType.LAZY, optional = true)
    @JsonIgnore
    @JoinColumn(nullable = true)
    private PictureGroup pictureGroup;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("修改时间")
    private Date mtime;

}
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain.story;

import com.fasterxml.jackson.annotation.JsonFormat;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serializable;
import java.util.Date;
import java.util.List;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("图片组")
public class PictureGroup implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @Comment("组名")
    @Column(unique = true, length = 50)
    private String name;

    @OneToMany(mappedBy = "pictureGroup", fetch = FetchType.EAGER)
    private List<Picture> picture;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("修改时间")
    private Date mtime;

}
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
CREATE TABLE `picture` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `ctime` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `device` varchar(255) DEFAULT NULL COMMENT '设备',
  `favorites` int unsigned NOT NULL DEFAULT '0' COMMENT '收藏',
  `forward` int unsigned NOT NULL DEFAULT '0' COMMENT '转发',
  `image` varchar(255) DEFAULT NULL COMMENT '原图',
  `likes` int unsigned NOT NULL DEFAULT '0' COMMENT '点赞',
  `model` varchar(255) DEFAULT NULL COMMENT '型号',
  `mtime` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `prompt` varchar(255) DEFAULT NULL COMMENT '提示词',
  `session` varchar(36) NOT NULL COMMENT '会话',
  `share` bit(1) NOT NULL COMMENT '共享\r\n0、未共享\r\n1、已共享',
  `story` text COMMENT '故事',
  `thumbnail` varchar(255) DEFAULT NULL COMMENT '缩图',
  `audio` varchar(255) DEFAULT NULL COMMENT '故事音频',
  `translate` varchar(1024) DEFAULT NULL COMMENT '英文提示词',
  `pinyin` text COMMENT '拼音',
  `english` text COMMENT '英文',
  `audit` bit(1) DEFAULT NULL COMMENT '人工审核\r\n0、审核未通过\r\n1、审核通过\r\n',
  `picture_group_id` int unsigned DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_6cgmptiqeq2nusk40x5io55oh` (`session`),
  KEY `index_Is_Charging_Id` (`is_charging`,`device`,`charging_time`) USING BTREE,
  KEY `FK8qckqvv3cl83c9ant5wx1f6eo` (`picture_group_id`),
  CONSTRAINT `FK8qckqvv3cl83c9ant5wx1f6eo` FOREIGN KEY (`picture_group_id`) REFERENCES `picture_group` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5846 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='图片表'			
			]]>
			</programlisting>
		</section>
		<section>
			<title>只要外键，不要数据结构</title>
			<para>@ManyToOne 关系 PictureGroup 加载后会出很多数据，在网上传输比较占用带宽，我们要精简 JSON
				数据，实现的方式是讲 pictureGroup 影射给 groupId</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain.story;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("图片表")
public class Picture implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "bigint unsigned")
    @Comment("主键")
    private Long id;

    @Comment("设备")
    private String device;

    @Column(unique = true, nullable = false, insertable = true, updatable = false, length = 36)
    @Comment("会话")
    private String session;

    @Comment("提示词")
    private String prompt;

    @Comment("英文提示词")
    @Column(length = 1024)
    private String translate;

    @Column(nullable = true)
    @Comment("缩图")
    private String thumbnail;

    @Column(nullable = true)
    @Comment("原图")
    private String image;

    @Column(nullable = true)
    @Comment("故事音频")
    private String audio;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("故事")
    private String story;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("拼音")
    private String pinyin;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    @Column(nullable = true, columnDefinition = "text")
    @Comment("英文")
    private String english;

    @Comment("共享")
    private boolean share;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("点赞数")
    private Integer likes;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("收藏数")
    private Integer favorites;

    @Column(columnDefinition = "int unsigned NOT NULL DEFAULT '0'")
    @Comment("转发数")
    private Integer forward;

    @Comment("人工审核，NULL 未审核，true 通过，false 未通过")
    private Boolean audit;

    @ManyToOne(fetch = FetchType.EAGER, optional = true)
    @JsonIgnore
    @JoinColumn(nullable = true)
    private PictureGroup pictureGroup;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Comment("修改时间")
    private Date mtime;

    @JsonProperty
    private Integer groupId;

    private void setGroupId(Integer groupId) {
        this.groupId = groupId;
    }

    private Integer getGroupId() {
        groupId = pictureGroup.getId();
        return groupId;
    }

}
			]]>
			</programlisting>
		</section>
	</section>
	<section id="indexes">
		<title>索引</title>
		<section id=" @Index">
			<title>普通索引</title>
			<screen>
				<![CDATA[
@Table(indexes = { @Index(name = "name", columnList = "name DESC"), @Index(name = "path", columnList = "path") })				
				]]>
			</screen>
			<programlisting>
				<![CDATA[
package common.domain;

import java.util.Date;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Index;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;

import org.springframework.format.annotation.DateTimeFormat;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;

@Entity
@Table(indexes = { @Index(name = "name", columnList = "name DESC"), @Index(name = "path", columnList = "path") })
public class Category {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	public int id;
	public String name;
	public String description;
	public String path;

	@Column(columnDefinition = "enum('Enabled','Disabled') DEFAULT 'Enabled' COMMENT '状态'")
	public String status;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'")
	public Date ctime;

	@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")
	@Column(columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更改时间'")
	public Date mtime;

	@ManyToOne(cascade = { CascadeType.PERSIST, CascadeType.REMOVE })
	@JoinColumn(name = "pid", referencedColumnName = "id")
	private Category categorys;

	@JsonIgnore
	@OneToMany(cascade = CascadeType.ALL, mappedBy = "category", fetch = FetchType.EAGER)
	private Set<Category> category;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getPath() {
		return path;
	}

	public void setPath(String path) {
		this.path = path;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Date getCtime() {
		return ctime;
	}

	public void setCtime(Date ctime) {
		this.ctime = ctime;
	}

	public Date getMtime() {
		return mtime;
	}

	public void setMtime(Date mtime) {
		this.mtime = mtime;
	}

	public Category getCategorys() {
		return categorys;
	}

	public void setCategorys(Category categorys) {
		this.categorys = categorys;
	}

	public Set<Category> getCategory() {
		return category;
	}

	public void setCategory(Set<Category> category) {
		this.category = category;
	}

	@Override
	public String toString() {
		return "Category [id=" + id + ", name=" + name + ", description=" + description + ", path=" + path + ", status="
				+ status + ", ctime=" + ctime + ", mtime=" + mtime + ", categorys=" + categorys + ", category="
				+ category + "]";
	}

}
				
				]]>
			</programlisting>
		</section>
		<section>
			<title>组合索引</title>
			<para>定义相同的 name 可以实现组合索引</para>
			<programlisting>
				<![CDATA[
@Table(indexes = {
        @Index(name = "key_device_hobby", columnList = "device_id"),
        @Index(name = "key_device_hobby", columnList = "hobby")
})				
				]]>
			</programlisting>
			<para>参考案例</para>
			<programlisting>
				<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serializable;

@Entity
@Table(indexes = {
        @Index(name = "key_device_hobby", columnList = "device_id"),
        @Index(name = "key_device_hobby", columnList = "hobby")
})
@DynamicUpdate
@DynamicInsert
@Data
@Comment("用户画像")
public class UserPersona implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "bigint unsigned")
    @Comment("主键")
    private Long id;

    @OneToOne
    @Comment("设备")
    @JoinColumn(name = "device_id", unique = true, nullable = false, insertable = true, updatable = false)
    private Device device;
    @Comment("兴趣爱好")
    private String hobby;
    @Comment("权重")
    private Integer weight;
}
				
				]]>
			</programlisting>
			<para>输出结果 KEY `key_device_hobby` (`device_id`,`hobby`)</para>
			<screen>
				<![CDATA[
CREATE TABLE `user_persona` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `hobby` varchar(255) DEFAULT NULL COMMENT '兴趣爱好',
  `weight` int DEFAULT NULL COMMENT '权重',
  `device_id` int unsigned NOT NULL COMMENT '设备',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_5ib64k66pbo08dmhkr0i0uu7k` (`device_id`),
  KEY `key_device_hobby` (`device_id`,`hobby`),
  CONSTRAINT `FK8ar0rxcxej5u3q0l38xdpwke1` FOREIGN KEY (`device_id`) REFERENCES `device` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户画像'				
				]]>
			</screen>
		</section>
		<section id="unique">
			<title>唯一索引</title>
			<section>
				<title>@Column 声明唯一索引</title>
				<para>针对字段做唯一索引</para>
				<screen>
				<![CDATA[
@Column(unique = true)
				]]>
				</screen>
			</section>
			<section>
				<title>@UniqueConstraint 定义唯一索引</title>
				<para>在表中定义唯一索引</para>
				<programlisting>
				<![CDATA[
@Table(uniqueConstraints = @UniqueConstraint(columnNames= {"name"}))				
				]]>
				</programlisting>
			</section>
			<section id="uniqueConstraints">
				<title>复合唯一索引</title>

				<para>创建由多个字段组成的复合索引</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.model;

import java.io.Serializable;
import java.util.Date;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.UniqueConstraint;

import com.fasterxml.jackson.annotation.JsonFormat;

@Entity
@Table(name = "comment", uniqueConstraints = { @UniqueConstraint(columnNames = { "member_id", "articleId" }) })
public class Comment implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -1484408775034277681L;
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "id", unique = true, nullable = false, insertable = true, updatable = false)
	private int id;

	@ManyToOne(cascade = { CascadeType.ALL })
	@JoinColumn(name = "member_id")
	private Member member;

	private int articleId;

	private String message;

	@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
	@Temporal(TemporalType.TIMESTAMP)
	@Column(updatable = false)
	@org.hibernate.annotations.CreationTimestamp
	protected Date createDate;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public Member getMember() {
		return member;
	}

	public void setMember(Member member) {
		this.member = member;
	}

	public int getArticleId() {
		return articleId;
	}

	public void setArticleId(int articleId) {
		this.articleId = articleId;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	public Date getCreateDate() {
		return createDate;
	}

	public void setCreateDate(Date createDate) {
		this.createDate = createDate;
	}
}
				]]>
				</programlisting>
				<screen>
				<![CDATA[
CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NOT NULL,
  `create_date` datetime DEFAULT NULL,
  `message` varchar(255) DEFAULT NULL,
  `member_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK5qxfiu92nwlvgli7bl3evl11m` (`member_id`,`article_id`),
  CONSTRAINT `FKmrrrpi513ssu63i2783jyiv9m` FOREIGN KEY (`member_id`) REFERENCES `member` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				]]>
				</screen>
				<programlisting>
					<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serializable;

@Entity
@Table(uniqueConstraints = {@UniqueConstraint(name = "UK_device_hobby", columnNames = {"device_id", "hobby"})})
@DynamicUpdate
@DynamicInsert
@Data
@Comment("用户画像")
public class UserPersona implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @ManyToOne
    @Comment("设备")
    @JoinColumn(name = "device_id", unique = false, nullable = false, insertable = true, updatable = false)
    private Device device;

    @Comment("兴趣爱好")
    private String hobby;

    @Comment("权重")
    private Integer weight;
}
					
					]]>
				</programlisting>
				<screen>
					<![CDATA[
CREATE TABLE `user_persona` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `hobby` varchar(255) DEFAULT NULL COMMENT '兴趣爱好',
  `weight` int DEFAULT NULL COMMENT '权重',
  `device_id` int unsigned NOT NULL COMMENT '设备',
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_device_hobby` (`device_id`,`hobby`),
  CONSTRAINT `FK8ar0rxcxej5u3q0l38xdpwke1` FOREIGN KEY (`device_id`) REFERENCES `device` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户画像'			
					]]>
				</screen>
			</section>
			<section>
				<title>定义多组唯一索引</title>
				<programlisting>
					<![CDATA[
@Table(uniqueConstraints = {
        @UniqueConstraint(columnNames={"firstname", "lastname"}),
        @UniqueConstraint(columnNames={"account", "mobile"})
})					
					]]>
				</programlisting>
			</section>

		</section>
	</section>
	<section id="Repository">
		<title>Repository</title>
		<screen>
		<![CDATA[
Repository： 仅仅是一个标识，没有任何方法，方便Spring自动扫描识别
CrudRepository： 继承Repository，实现了一组CRUD相关的方法
PagingAndSortingRepository： 继承CrudRepository，实现了一组分页排序相关的方法
JpaRepository： 继承PagingAndSortingRepository，实现一组JPA规范相关的方法		
		]]>
		</screen>
		<para>Spring Data JPA 为此提供了一些表达条件查询的关键字：</para>
		<screen>
		<![CDATA[
Keyword	Sample	JPQL snippet
And			findByLastnameAndFirstname	… where x.lastname = ?1 and x.firstname = ?2
Or			findByLastnameOrFirstname	… where x.lastname = ?1 or x.firstname = ?2
Is,Equals	findByFirstnameIs,findByFirstnameEquals	… where x.firstname = ?1
Between		findByStartDateBetween	… where x.startDate between ?1 and ?2
LessThan	findByAgeLessThan	… where x.age < ?1
LessThanEqual	findByAgeLessThanEqual	… where x.age ⇐ ?1
GreaterThan	findByAgeGreaterThan	… where x.age > ?1
GreaterThanEqual	findByAgeGreaterThanEqual	… where x.age >= ?1
After		findByStartDateAfter	… where x.startDate > ?1
Before		findByStartDateBefore	… where x.startDate < ?1
IsNull		findByAgeIsNull	… where x.age is null
IsNotNull,NotNull	findByAge(Is)NotNull	… where x.age not null
Like		findByFirstnameLike	… where x.firstname like ?1
NotLike		findByFirstnameNotLike	… where x.firstname not like ?1
StartingWith	findByFirstnameStartingWith	… where x.firstname like ?1 (parameter bound with appended %)
EndingWith	findByFirstnameEndingWith	… where x.firstname like ?1 (parameter bound with prepended %)
Containing	findByFirstnameContaining	… where x.firstname like ?1 (parameter bound wrapped in %)
OrderBy		findByAgeOrderByLastnameDesc	… where x.age = ?1 order by x.lastname desc
Not			findByLastnameNot	… where x.lastname <> ?1
In			findByAgeIn(Collection ages)	… where x.age in ?1
NotIn		findByAgeNotIn(Collection age)	… where x.age not in ?1
TRUE		findByActiveTrue()	… where x.active = true
FALSE		findByActiveFalse()	… where x.active = false
IgnoreCase	findByFirstnameIgnoreCase	… where UPPER(x.firstame) = UPPER(?1)		

常用如下：
And --- 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)
Or --- 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)
Between --- 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)
LessThan --- 等价于 SQL 中的 "<"，比如 findBySalaryLessThan(int max)
GreaterThan --- 等价于 SQL 中的">"，比如 findBySalaryGreaterThan(int min)
IsNull --- 等价于 SQL 中的 "is null"，比如 findByUsernameIsNull()
IsNotNull --- 等价于 SQL 中的 "is not null"，比如 findByUsernameIsNotNull()
NotNull --- 与 IsNotNull 等价
Like --- 等价于 SQL 中的 "like"，比如 findByUsernameLike(String user)
NotLike --- 等价于 SQL 中的 "not like"，比如 findByUsernameNotLike(String user)
OrderBy ---等价于 SQL 中的 "order by"，比如 findByUsernameOrderBySalaryAsc(String user)
Not --- 等价于 SQL 中的 "！ ="，比如 findByUsernameNot(String user)
In --- 等价于 SQL 中的 "in"，比如 findByUsernameIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数
NotIn --- 等价于 SQL 中的 "not in"，比如 findByUsernameNotIn(Collection<String> userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长
		]]>
		</screen>
		<section id="JpaRepository">
			<title>JpaRepository</title>
			<para>
				<ulink
					url="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" />
			</para>
			<screen>
			<![CDATA[
Modifier and Type	Method and Description
void	deleteAllInBatch()
Deletes all entities in a batch call.
void	deleteInBatch(Iterable<T> entities)
Deletes the given entities in a batch which means it will create a single Query.
List<T>	findAll() 
<S extends T>
List<S>	findAll(Example<S> example) 
<S extends T>
List<S>	findAll(Example<S> example, Sort sort) 
List<T>	findAll(Sort sort) 
List<T>	findAllById(Iterable<ID> ids) 
void	flush()
Flushes all pending changes to the database.
T	getOne(ID id)
Returns a reference to the entity with the given identifier.
<S extends T>
List<S>	saveAll(Iterable<S> entities) 
<S extends T>
S	saveAndFlush(S entity)
Saves an entity and flushes changes instantly.		
			]]>
			</screen>
		</section>
		<section id="CrudRepository">
			<title>CrudRepository</title>
			<para>CrudRepository 接口提供了最基本的对实体类的添删改查操作</para>
			<screen>
			<![CDATA[
T save(T entity);								//保存单个实体 
Iterable<T> save(Iterable<? extends T> entities);//保存集合        
T findOne(ID id);								//根据id查找实体         
boolean exists(ID id);							//根据id判断实体是否存在         
Iterable<T> findAll();							//查询所有实体,不用或慎用!         
long count();									//查询实体数量         
void delete(ID id);								//根据Id删除实体         
void delete(T entity);							//删除一个实体 
void delete(Iterable<? extends T> entities);		//删除一个实体的集合         
void deleteAll();								//删除所有实体,不用或慎用! 		
			]]>
			</screen>
			<section>
				<title>批量保存</title>
				<programlisting>
				<![CDATA[
        List<Book> books = new ArrayList<>();
        books.add(new Book("Book A", new BookDetail(1)));
        books.add(new Book("Book B", new BookDetail(2)));
        books.add(new Book("Book C", new BookDetail(3)));
        bookRepository.save(books);				
				]]>
				</programlisting>
			</section>
		</section>


		<section id="PagingAndSortingRepository">
			<title>PagingAndSortingRepository</title>

			<section>
				<title>Pageable</title>
				<para>接口实现 PagingAndSortingRepository</para>
				<programlisting>
				<![CDATA[
package api.repository.h5;

import org.springframework.data.repository.PagingAndSortingRepository;

import api.domain.User;

public interface GatherRepository extends PagingAndSortingRepository<User, Integer> {

}
				
				]]>
				</programlisting>
				<para>控制器添加 Pageable pageable 参数</para>
				<programlisting>
				<![CDATA[
	@RequestMapping("/browse")
	public ModelAndView browse(Pageable pageable) {
		Page<User> users = userRepository.findAll(pageable);
		
		System.out.println(users.toString());
		ModelAndView mv = new ModelAndView();
		mv.addObject("users", users.getContent());
		mv.addObject("number", users.getNumber());
		mv.addObject("size", users.getSize());
		mv.addObject("totalPages", users.getTotalPages());
		mv.setViewName("table");

		return mv;
	}				
				]]>
				</programlisting>

			</section>
			<section>
				<title>解决 PagingAndSortingRepository 没有 save 等方法的问题</title>
				<para>如果 Repository 继承了 PagingAndSortingRepository 你会发
					CrudRepository 中的 save 等方法不能使用了，我的解决方法是写两个 Repository
				</para>
				<para>一个 CURD 的 ChatRepository 放在 cn.netkiller.repository</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Chat;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface ChatRepository extends CrudRepository<Chat, String> {
    List<Chat> findAllBySession(String session);

    Chat findOneBySession(String session);

}				
				]]>
				</programlisting>
				<para>另一个分页的 PagingAndSortingRepository 放在
					cn.netkiller.repository.pageable
				</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.repository.pageable;


import cn.netkiller.domain.Chat;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.PagingAndSortingRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface ChatPageableRepository extends PagingAndSortingRepository<Chat, String> {
    Page<Chat> findAllByDevice(String device, Pageable pageable);
}
				]]>
				</programlisting>
			</section>
			<section id="PageableDefault">
				<title>@PageableDefault 分页</title>
				<programlisting>
		<![CDATA[
@RequestMapping(value = "/list", method=RequestMethod.GET)
public Page<Blog> getEntryByPageable1(@PageableDefault( sort = { "id" }, direction = Sort.Direction.DESC) 
    Pageable pageable) {
    return blogRepository.findAll(pageable);
}

@RequestMapping(value = "/blog", method=RequestMethod.GET)
public Page<Blog> getEntryByPageable(@PageableDefault(value = 15, sort = { "id" }, direction = Sort.Direction.DESC) 
    Pageable pageable) {
    return blogRepository.findAll(pageable);
}

@RequestMapping(value = "/list", method=RequestMethod.GET)
public Page<Blog> getEntryByPageable2(@PageableDefault Pageable pageable) {
    return blogRepository.findAll(pageable);
}

@ModelAttribute("users")
public Page<User> users(@PageableDefault(size = 5) Pageable pageable) {
	return userManagement.findAll(pageable);
}
		]]>
				</programlisting>
				<screen>
		<![CDATA[
我们只需要在方法的参数中直接定义一个pageable类型的参数，当Spring发现这个参数时，Spring会自动的根据request的参数来组装该pageable对象，Spring支持的request参数如下：

page，第几页，从0开始，默认为第0页
size，每一页的大小，默认为20
sort，排序相关的信息，以property,property(,ASC|DESC)的方式组织，例如sort=firstname&sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列
这样，我们就可以通过url的参数来进行多样化、个性化的查询，而不需要为每一种情况来写不同的方法了。

通过url来定制pageable很方便，但唯一的缺点是不太美观，因此我们需要为pageable设置一个默认配置，这样很多情况下我们都能够通过一个简洁的url来获取信息了。

Spring提供了@PageableDefault帮助我们个性化的设置pageable的默认配置。例如@PageableDefault(value = 15, sort = { "id" }, direction = Sort.Direction.DESC)表示默认情况下我们按照id倒序排列，每一页的大小为15。		
		]]>

				</screen>
			</section>
		</section>
		<section id="jpa.find">
			<title>findByXXX</title>
			<programlisting>
			<![CDATA[
	@Autowired
	private ArticleRepository articleRepository;

	@RequestMapping("/mysql")
	@ResponseBody
	public String mysql() {
		articleRepository.save(new Article("Neo", "Chen"));
		for (Article article : articleRepository.findAll()) {
			System.out.println(article);
		}
		Article tmp = articleRepository.findByTitle("Neo");
		return tmp.getTitle();
	}

	@RequestMapping("/search")
	@ResponseBody
	public String search() {

		
		for (Article article : articleRepository.findBySearch(1)) { System.out.println(article); }
		 
		List<Article> tmp = articleRepository.findBySearch(1L);

		tmp.forEach((temp) -> {
			System.out.println(temp.toString());
		});

		return tmp.get(0).getTitle();
	}
		]]>
			</programlisting>
			<section>
				<title>传 Boolean 参数</title>
				<programlisting>
			<![CDATA[
package cn.netkiller.wallet.repository.fcoin;

import java.util.List;

import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.CrudRepository;

import cn.netkiller.wallet.domain.fcoin.Fcoin;;

public interface FcoinRepository extends CrudRepository<Fcoin, String> {

	Fcoin findOneByAddress(String address);

	int countByAirdropFalse();

	List<Fcoin> findByAirdrop(boolean airdrop, Pageable pageable);

}
			]]>
				</programlisting>
			</section>
			<section id="eunm">
				<title>Eunm 传递枚举参数</title>
				<programlisting>
			<![CDATA[
package cn.netkiller.api.repository;

import org.springframework.data.repository.CrudRepository;

import cn.netkiller.api.domain.StatisticsHistory;

public interface StatisticsHistoryRepostitory extends CrudRepository<StatisticsHistory, Long> {

	public StatisticsHistory findByMemberIdAndStatisticsIdAndType(long member_id, long statistics_id,
			StatisticsHistory.StatisticsType type);

}
			]]>
				</programlisting>
				<para></para>
				<programlisting>
			<![CDATA[
	@Autowired
	private StatisticsHistoryRepostitory statisticsHistoryRepostitory;			
			
	statisticsHistoryRepostitory.findByMemberIdAndStatisticsIdAndType(uid, id, type);
			]]>
				</programlisting>
			</section>
		</section>
		<section id="jpa.count">
			<title>count 操作</title>
			<programlisting>
			<![CDATA[
public interface UserRepository extends CrudRepository<User, Long> {

    Long countByFirstName(String firstName);

}
			]]>
			</programlisting>
		</section>
		<section id="jpa.delete">
			<title>delete 删除操作</title>
			<programlisting>
			<![CDATA[
    @Transactional
    Long deleteByFirstName(String firstName);
    
    @Transactional
    List<User> removeByFirstName(String firstName);    			
			]]>
			</programlisting>
		</section>
		<section id="IsNull">
			<title>IsNull</title>
			<programlisting>
			<![CDATA[
    Iterable<PicturePsychoanalysis> findByAnalysisIsNull();			
			]]>
			</programlisting>
			<para>使用 And / Or 链接多个条件</para>
			<programlisting>
			<![CDATA[
    Iterable<Chat> findByAnswerIsNullOrAudioIsNullOrPsychoanalysisIsNull();
			]]>
			</programlisting>
			<para>IsNotNull</para>
			<programlisting>
			<![CDATA[
    Page<Picture> findByImageIsNotNullAndStoryIsNotNullAndAudioIsNotNull(Pageable pageable);			
			]]>
			</programlisting>
		</section>
		<section id="jpa.InNotIn">
			<title>In/NotIn</title>
			<programlisting>
		<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Lora;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.Set;

@Repository
public interface LoraRepository extends CrudRepository<Lora, Integer> {
    Optional<Lora> findByKeywordIn(Set<String> keyword);
    Iterable<Lora> findAllByKeywordIn(Set<String> keyword);
}
		]]>
			</programlisting>
			<para>查询接口</para>
			<programlisting>
			<![CDATA[
    @GetMapping("one")
    public Optional<Lora> keywordTest(@RequestParam("key") Set<String> keyword) {

        Optional<Lora> lora = loraRepository.findByKeywordIn(keyword);
        return lora;
    }

    @GetMapping("all")
    public Iterable<Lora> keywordTest1(@RequestParam("key") Set<String> keyword) {

        Iterable<Lora> lora = loraRepository.findAllByKeywordIn(keyword);
        return lora;
    }
			]]>
			</programlisting>
		</section>
		<section id="find.true">
			<title>TRUE / FALSE</title>
			<programlisting>
			<![CDATA[
    Page<Picture> findByShareTrueAndImageIsNotNullAndStoryIsNotNullAndAudioIsNotNull(Pageable pageable);
			]]>
			</programlisting>
		</section>
		<section id="">
			<title>Before/After</title>
			<programlisting>
			<![CDATA[
//        DateTimeFormatter df = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        LocalDateTime now = LocalDateTime.now();
//        LocalDateTime lastDay = now.minusDays(1);
        LocalDateTime start = now.minusDays(1);
        LocalDateTime end = now.minusMinutes(5);
        log.info("Query picture from {} to {}", start, end);
//        iterable = pictureService.findBySrtIsNullAndCtimeAfter(end);
        iterable = pictureService.findBySrtIsNullAndCtimeBefore(end);
        iterable.forEach(picture -> {
            String appId = businessService.queryAppIdByDevice(picture.getDevice());
            aigcPipeline.setAigc(Aigc.builder().appId(appId).device(picture.getDevice()).session(picture.getSession()).prompt(picture.getPrompt()).story(picture.getStory()).audio(picture.getAudio()).build());
            aigcPipeline.subtitles(srt -> {
                pictureService.updateSrt(aigcPipeline.getAigc().getSession(), srt);
                sessionStatusService.progress(aigcPipeline.getAigc().getSession(), "识别字幕", srt);
            });
        });
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
    public Iterable<Picture> findBySrtIsNullAndCtimeBefore(LocalDateTime lastDay) {
        Iterable<Picture> iterable = pictureRepository.findBySrtIsNullAndCtimeBefore(lastDay);
        return iterable;
    }
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.story.Picture;
import cn.netkiller.repository.model.PictureGroupList;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.Optional;

@Repository
public interface PictureRepository extends CrudRepository<Picture, Long> {
    Picture findAllBySession(String session);

    Optional<Picture> findBySession(String session);

    Page<Picture> findAll(Pageable pageable);

    Iterable<Picture> findBySrtIsNullAndCtimeBefore(LocalDateTime lastDay);
}		
			]]>
			</programlisting>
		</section>
		<section id="OrderBy">
			<title>OrderBy</title>
			<programlisting>
			<![CDATA[
public List<StudentEntity> findAllByOrderByIdAsc();
public List<StudentEntity> findAllByOrderByIdDesc();
List<RecentRead> findByMemberIdOrderByIdDesc(int memberId, Pageable pageable);
			]]>
			</programlisting>
		</section>
		<section id="GreaterThan">
			<title>GreaterThan</title>
			<programlisting>
			<![CDATA[
package schedule.repository;

import java.util.Date;

import org.springframework.data.repository.CrudRepository;

import common.domain.CmsTrash;

public interface CmsTrashRepository extends CrudRepository<CmsTrash, Integer> {

	Iterable<CmsTrash> findBySiteIdAndTypeOrderByCtimeASC(int siteId, String string);

	Iterable<CmsTrash> findBySiteIdAndTypeAndCtimeGreaterThanOrderByCtimeASC(int siteId, String string, Date date);

}
			]]>
			</programlisting>
			<para>复杂的 GreaterThan / LessThan 应用</para>
			<programlisting>
			<![CDATA[
    @Cacheable(value = "picture:share:next", key = "#cursor", unless = "#result == null")
    public Optional<Picture> shareNext(int cursor) {
        return pictureRepository.findFirstByShareTrueAndImageIsNotNullAndStoryIsNotNullAndAudioIsNotNullAndIdGreaterThan(cursor);
    }

    @Cacheable(value = "picture:share:previous", key = "#cursor", unless = "#result == null")
    public Optional<Picture> sharePrevious(int cursor) {
        return pictureRepository.findFirstByShareTrueAndImageIsNotNullAndStoryIsNotNullAndAudioIsNotNullAndIdLessThanOrderByIdDesc(cursor);
    }			
			]]>
			</programlisting>
		</section>

		<section id="sort">
			<title>Sort 排序操作操作</title>
			<programlisting>
			<![CDATA[
List<UserModel> findByName(String name, Sort sort);
			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
Sort sort = new Sort(Direction.DESC, "id"); 
repostitory.findByName("Neo", sort);
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
userRepository.findAll(Sort.by(Sort.Direction.ASC, "name"));
userRepository.findAll(Sort.by("LENGTH(name)"));

			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
userRepository.findAll(Sort.by(Sort.Direction.ASC, "name"));
userRepository.findAll(Sort.by("LENGTH(name)"));

			]]>
			</programlisting>
		</section>


		<section id="pageable">
			<title>Pageable 翻页操作</title>
			<para>Page 返回数据和页码等数据</para>

			<screen>
			<![CDATA[
PageRequest(int page, int size, Sort sort)  Deprecated. 
use PageRequest.of(int, int, Sort) instead.			
			]]>
			</screen>
			<programlisting>
				<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Picture;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PictureRepository extends JpaRepository<Picture, Long> {
    Picture findAllBySession(String session);

    Optional<Picture> findOneBySession(String session);

    Page<Picture> findAll(Pageable pageable);
}				
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
    public Page<Picture> page(Pageable pageable) {
        return pictureRepository.findAll(pageable);
    }				
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
    @GetMapping("/{device}/page")
    public Mono<Page<Picture>> page(@PathVariable String device, Pageable pageable) {

        return Mono.just(pictureService.page(pageable));
    }				
				]]>
			</programlisting>
			<screen>
				<![CDATA[
排序 /picture/test/page?sort=id,desc
每页返回数量 /picture/test/page?size=10
返回第二页5条数据 /picture/test/page?size=5&page=1
返回第二页5条数据，ID倒序排序 /picture/test/page?size=5&page=1&sort=id,desc
				]]>
			</screen>
			<screen>
				<![CDATA[
curl -X 'GET' \
  'http://localhost:8080/picture/test/page?page=0&size=1&sort=id' \
  -H 'accept: */*'
				]]>
			</screen>

			<section>
				<title>PageRequest.of</title>
				<programlisting>
				<![CDATA[
package cn.netkiller.api.repository;

import java.util.List;

import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.CrudRepository;

import cn.netkiller.api.domain.RecentRead;

public interface RecentReadRepostitory extends CrudRepository<RecentRead, Long> {

	List<RecentRead> findByMemberId(long id, Pageable pageable);

}
				]]>
				</programlisting>
				<para>Top 10 实例</para>
				<programlisting>
				<![CDATA[
	@RequestMapping("/recent/read/list/{id}")
	public List<RecentRead> recentList(@PathVariable long id) {
		int page = 0;
		int limit = 10;
		List<RecentRead> recentRead = recentReadRepostitory.findByMemberId(id, new PageRequest(page, limit));
		return recentRead;
	}
				]]>
				</programlisting>
				<para>翻页返回数据可以选择 Iterable/List 或者 Page。 </para>
				<para>Iterable/List 只返回数据，不含页码等数据</para>
				<para>注意 PageRequest(int page, int size) 在新版 Spring boot 2.x
					中已经废弃请使用 PageRequest.of(page, size) 替代
				</para>
				<programlisting>
				<![CDATA[
List<Fcoin> fcoins = fcoinRepository.findByAirdrop(false, PageRequest.of(0, size));
				]]>
				</programlisting>

			</section>
		</section>
		<section id="@DynamicInsert">
			<title>@DynamicInsert 与 @DynamicUpdate</title>
			<para>@DynamicUpdate 只更新修改的字段</para>

		</section>
		<section>
			<title>继承已存在的 Repository</title>
			<programlisting>
			<![CDATA[
public interface MemberRepository extends JpaRepository<User, Integer>, UserRepository {
    ...
}			
			]]>
			</programlisting>
		</section>
		<section>
			<title>自定义返回字段</title>
			<para>我们并不希望每次返回所有字段，JPA默认查询等价 “SELECT * FROM TABLE”</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository.model;

public interface PictureGroupList {
    Integer getId();

    String getImage();

    String getThumbnail();

    String getAudio();

    String getStory();
}

    public Iterable<PictureGroupList> findByPictureGroupId(int pictureGroupId) {
        return pictureRepository.findByPictureGroupId(pictureGroupId);
    }			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serializable;

@Entity
@Table(uniqueConstraints = {@UniqueConstraint(name = "UK_device_hobby", columnNames = {"device_id", "hobby"})})
@DynamicUpdate
@DynamicInsert
@Data
@Comment("用户画像")
public class UserPersona implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @ManyToOne
    @Comment("设备")
    @JoinColumn(name = "device_id", unique = false, nullable = false, insertable = true, updatable = false)
    @JsonIgnore
    private Device device;

    @Comment("兴趣爱好")
    private String hobby;

    @Comment("权重")
    private Integer weight;

    public interface UserPersonaNativeQuery {
        // String getId();

        String getHobby();

        String getWeight();
    }
}
			
			]]>
			</programlisting>
			<para>解放方法是，定一个接口 UserPersonaNativeQuery</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.UserPersona;
import jakarta.transaction.Transactional;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UserPersonaRepository extends CrudRepository<UserPersona, Integer> {
    @Transactional
    @Modifying
    @Query(nativeQuery = true, value = "INSERT INTO user_persona (device_id, hobby,weight) VALUES ((SELECT id FROM device where sn=:device) , :hobby, 1) ON DUPLICATE KEY UPDATE weight = weight + 1;")
    int updateUserPersona(@Param("device") String device, @Param("hobby") String hobby);

    List<UserPersona.UserPersonaNativeQuery> findByDeviceId(Integer id);
}
			]]>
			</programlisting>
			<para>在仓库中指定该接口</para>
			<programlisting>
			<![CDATA[
[
    {
      "weight": "10",
      "hobby": "小朋友"
    },
    {
      "weight": "10",
      "hobby": "妈妈"
    },
    {
      "weight": "10",
      "hobby": "自行车"
    },
    {
      "weight": "5",
      "hobby": "校园"
    },
    {
      "weight": "5",
      "hobby": "欢声笑语"
    },
    {
      "weight": "6",
      "hobby": "雪景"
    },
    {
      "weight": "4",
      "hobby": "皮筋"
    },
    {
      "weight": "4",
      "hobby": "同学们"
    },
    {
      "weight": "4",
      "hobby": "爬杆"
    },
    {
      "weight": "4",
      "hobby": "女同学"
    },
    {
      "weight": "4",
      "hobby": "羽毛球"
    },
    {
      "weight": "4",
      "hobby": "歌曲"
    },
    {
      "weight": "1",
      "hobby": "冰雪"
    },
    {
      "weight": "1",
      "hobby": "包饺子"
    },
    {
      "weight": "1",
      "hobby": "哈尔滨"
    },
    {
      "weight": "1",
      "hobby": "冻梨"
    },
    {
      "weight": "1",
      "hobby": "冰雕"
    }
  ]			
			]]>
			</programlisting>
			<para>@ManyToOne 字段的巧妙处理，正常情况 @ManyToOne
				会返回一个对象，如果我们返回List列表，这个对象就会重复出现，首先使用 @JsonIgnore 将其屏蔽，然后创建两个方法
				private void setDeviceId(Integer deviceId) 和 private Integer
				getDeviceId()
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serializable;

@Entity
@Table(uniqueConstraints = {@UniqueConstraint(name = "UK_device_hobby", columnNames = {"device_id", "hobby"})})
@DynamicUpdate
@DynamicInsert
@Data
@Comment("用户画像")
public class UserPersona implements Serializable {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @ManyToOne
    @Comment("设备")
    @JoinColumn(name = "device_id", unique = false, nullable = false, insertable = true, updatable = false)
    @JsonIgnore
    private Device device;

    @Comment("兴趣爱好")
    private String hobby;

    @Comment("权重")
    private Integer weight;

    private void setDeviceId(Integer deviceId) {
        this.setDevice(Device.builder().id(deviceId).build());
    }

    private Integer getDeviceId() {
        return this.getDevice().getId();
    }

    public interface UserPersonaNativeQuery {
        String getId();

        String getHobby();

        Integer getWeight();

        Integer getDeviceId();
    }
}
			]]>
			</programlisting>
		</section>

	</section>
	<section id="TransactionTemplate">
		<title>TransactionTemplate</title>
		<programlisting>
			<![CDATA[
	@Autowired
	private TransactionTemplate transactionTemplate; 
	...
	...
	public void save(final User user) {
		transactionTemplate.execute((status) => {
			doSomeThing(user);
			doSomeThing1();
			doSomeThing2();
			doSomeThingN();
			return Boolean.TRUE;
		})
	}
			]]>
		</programlisting>
	</section>


	<section id="JPQL">
		<title>JPQL @Query</title>
		<section id="@Modifying">
			<title>@Modifying 更新/删除</title>
			<para>更新/删除操作需要加上 @Modifying 注解</para>
			<programlisting>
			<![CDATA[
@Modifying
@Query("update Money m set m.isDeleted=?2 where  m.money=?1")
void updateStateByMoney(Long money, Byte state);			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[

  @Modifying(clearAutomatically=true, flushAutomatically = true)			
			]]>
			</programlisting>
		</section>

		<section id="@Param">
			<title>参数传递</title>
			<programlisting>
				<![CDATA[
package api.repository.oracle;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import api.domain.oracle.Member;

@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
	public Page<Member> findAll(Pageable pageable);

	// public Member findByBillno(String billno);

	public Member findById(String id);

	@Query("SELECT m FROM Member m WHERE m.status = 'Y' AND m.id = :id")
	public Member findFinishById(@Param("id") String id);

}
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PersonRepository extends JpaRepository<Person, Long> {
    @Query("SELECT p FROM Person p WHERE LOWER(p.lastName) = LOWER(:lastName)")
    public List<Person> find(@Param("lastName") String lastName);
}
				]]>
			</programlisting>
		</section>
		<section id="Query.nativeQuery">
			<title>原生 SQL 操作</title>
			<section>
				<title>查询</title>

				<programlisting>
				<![CDATA[
public interface UserRepository extends JpaRepository<User, Long> {

	@Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?0", nativeQuery = true)
	User findByEmailAddress(String emailAddress);
}
				]]>
				</programlisting>
			</section>
			<section>
				<title>忽略插入</title>
				<para>insert ignore</para>
				<programlisting>
				<![CDATA[
	@Modifying
    @Query(value = "insert ignore into emp(create, modified, user_id, user_name, user_nickname, user_mail) values(?1, ?2, ?3, ?4, ?5, ?6)", nativeQuery = true)
    void insertIgnoreEmployee(Timestamp create, Timestamp modified, String userId, String name, String nickname, String mail);
				
				]]>
				</programlisting>
			</section>
			<section id="nativeQuery">
				<title>数据更新</title>
				<para>这里的nativeQuery=true代表在执行这个方法的时候使用原生sql语句，直接写数据库中的实际表名和表中的字段名，而不是实体表名。
				</para>
				<programlisting>
				<![CDATA[
    @Modifying
    @Query(nativeQuery = true, value = "UPDATE project p, (SELECT MIN(start) AS start, MAX(finish) AS finish FROM project WHERE parent_id = :id) t SET p.start = t.start, p.finish = t.finish WHERE p.id = :id")
    public void updateStartAndFinishById(@Param("id") Long id);				
				]]>
				</programlisting>
				<para>在什么情况下使用呢？例如上面，同时操作两张表，做更新，如果不使用 nativeQuery = true 无法实现。
				</para>
			</section>
		</section>
		<section id="Pageagble">
			<title>@Query 与 Pageagble</title>
			<para>
				<ulink
					url="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#_native_queries" />
			</para>
			<programlisting>
			<![CDATA[
@Query(value = "SELECT u FROM User u ORDER BY id")
Page<User> findAllUsersWithPagination(Pageable pageable);			
			]]>
			</programlisting>
			<programlisting>
				<![CDATA[
package api.domain;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Index;
import javax.persistence.Table;

@Entity
@Table(indexes = { @Index(name = "address", columnList = "from_address,to_address"), @Index(name = "contractAddress", columnList = "contractAddress") })

public class TransactionHistory implements Serializable {
	private static final long serialVersionUID = 6710992220657056861L;
	@Id
	@Column(name = "blockNumber", unique = true, nullable = false, insertable = true, updatable = false)
	private int blockNumber;
	private String timeStamp;
	private String hash;
	@Column(name = "from_address")
	private String from;
	@Column(name = "to_address")
	private String to;
	private String value;
	private String gas;
	private String gasPrice;
	private String isError;
	private String contractAddress;
	private String gasUsed;
	private String symbol;

	public TransactionHistory() {
		// TODO Auto-generated constructor stub
	}

	public int getBlockNumber() {
		return blockNumber;
	}

	public void setBlockNumber(int blockNumber) {
		this.blockNumber = blockNumber;
	}

	public String getTimeStamp() {
		return timeStamp;
	}

	public void setTimeStamp(String timeStamp) {
		this.timeStamp = timeStamp;
	}

	public String getHash() {
		return hash;
	}

	public void setHash(String hash) {
		this.hash = hash;
	}

	public String getFrom() {
		return from;
	}

	public void setFrom(String from) {
		this.from = from;
	}

	public String getTo() {
		return to;
	}

	public void setTo(String to) {
		this.to = to;
	}

	public String getValue() {
		return value;
	}

	public void setValue(String value) {
		this.value = value;
	}

	public String getGas() {
		return gas;
	}

	public void setGas(String gas) {
		this.gas = gas;
	}

	public String getGasPrice() {
		return gasPrice;
	}

	public void setGasPrice(String gasPrice) {
		this.gasPrice = gasPrice;
	}

	public String getIsError() {
		return isError;
	}

	public void setIsError(String isError) {
		this.isError = isError;
	}

	public String getContractAddress() {
		return contractAddress;
	}

	public void setContractAddress(String contractAddress) {
		this.contractAddress = contractAddress;
	}

	public String getGasUsed() {
		return gasUsed;
	}

	public void setGasUsed(String gasUsed) {
		this.gasUsed = gasUsed;
	}

	public static long getSerialversionuid() {
		return serialVersionUID;
	}

	public String getSymbol() {
		return symbol;
	}

	public void setSymbol(String symbol) {
		this.symbol = symbol;
	}

	@Override
	public String toString() {
		return "TransactionHistory [blockNumber=" + blockNumber + ", timeStamp=" + timeStamp + ", hash=" + hash + ", from=" + from + ", to=" + to + ", value=" + value + ", gas=" + gas + ", gasPrice=" + gasPrice + ", isError=" + isError + ", contractAddress=" + contractAddress + ", gasUsed=" + gasUsed + ", symbol=" + symbol + "]";
	}

}
				
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
package api.repository;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import api.domain.TransactionHistory;

@Repository
public interface TransactionHistoryRepository extends CrudRepository<TransactionHistory, Integer> {

	@Query(value = "SELECT * FROM transaction_history th WHERE (th.from_address = :address or th.to_address = :address) and contract_address is NULL",
			countQuery = "SELEÇT count(*) FROM transaction_history th WHERE (th.from_address = :address or th.to_address = :address) and contract_address is NULL",
			nativeQuery = true)
	public Page<TransactionHistory> findEthByAddress(@Param("address") String address, Pageable pageable);

}
				]]>
			</programlisting>
		</section>
		<section id="返回指定字段">
			<title>返回指定字段</title>
			<para>通过实体返回数据有时结果集非常庞大，可能会影响性能，这时我们只需要返回指定字段即可。</para>
			<programlisting>
				<![CDATA[
@Query(value = "select u.userName, ui.name, ui.gender, ui.description from UserInfo ui, User u where u.id = ui.userId")
public List<Object> getCustomField();
				]]>
			</programlisting>
			<programlisting>
			<![CDATA[
@Query(value = "select new map(u.userName, ui.name, ui.gender, ui.description) from UserInfo ui, User u where u.id = ui.userId")
public List<Map<String, Object>> getCustomField();			
			]]>
			</programlisting>
		</section>
		<section id="返回指定的模型">
			<title>返回指定的模型</title>
			<para>临时写一个新的模型</para>
			<programlisting>
				<![CDATA[
public class MyModel implements Serializable {

    private String userName;
    private String name;
    private String gender;
    private String description;

    public MyModel() {};

    public MyModel(String userName, String name, String gender, String description) {
        this.userName = userName;
        this.name = name;
        this.gender = gender;
        this.description = description;
    }
}
				]]>
			</programlisting>
			<para>使用构造方法赋值</para>
			<programlisting>
				<![CDATA[
@Query(value = "select new cn.netkiller.model.MyModel(u.userName, ui.name, ui.gender, ui.description) from UserInfo ui, User u where u.id = ui.userId")
public List<MyModel> getAllRecord();
				]]>
			</programlisting>

		</section>
		<section id="通过定义接口返回指定字段">
			<title>通过定义接口，返回指定字段</title>
			<programlisting>
			<![CDATA[
    @GetMapping("discovery/group")
//    @Deprecated(since = "v4.0.0", forRemoval = true)
    public AigcResponse group(Pageable pageable) {
        Page<DiscoveryPictureGroup> iterable = pictureGroupService.discoveryPictureGroup(pageable);
        return new AigcResponse(iterable);
    }			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.service;

import cn.netkiller.repository.PictureGroupRepository;
import cn.netkiller.repository.model.DiscoveryPictureGroup;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

@Service
public class PictureGroupService {
    @Autowired
    private PictureGroupRepository pictureGroupRepository;

    public Page<DiscoveryPictureGroup> discoveryPictureGroup(Pageable pageable) {
        return pictureGroupRepository.discoveryPictureGroup(pageable);//        UpIsNotNull
    }
}

			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.story.PictureGroup;
import cn.netkiller.repository.model.DiscoveryPictureGroup;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PictureGroupRepository extends CrudRepository<PictureGroup, Integer> {
    Page<PictureGroup> findByOrderByUpDescIdDesc(Pageable pageable);

    @Query(value = "select pg.id, pg.name, p.thumbnail,pg.up from picture_group pg, picture p where pg.id = p.picture_group_id group by pg.id order by pg.up desc, pg.id desc", nativeQuery = true)
    Page<DiscoveryPictureGroup> discoveryPictureGroup(Pageable pageable);

}
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository.model;

public interface DiscoveryPictureGroup {
    Integer getId();
    String getName();
    String getThumbnail();
    Integer getUp();
}
			
			]]>
			</programlisting>
		</section>
		<section>
			<title>@Query 与 @ManyToOne</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;

@Entity
@DynamicInsert
@DynamicUpdate
@Table
@Data
public class Follow implements Serializable {

    @Serial
    public static final long serialVersionUID = -1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @ManyToOne
    @JoinColumn(name = "follower")
    private Consumer follower;

    @ManyToOne
    @JoinColumn(name = "followed")
    private Consumer followed;
}
			
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;
import org.springframework.format.annotation.DateTimeFormat;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@Data
@DynamicUpdate
@DynamicInsert
@Comment("客户信息表")
public class Consumer implements Serializable {
    @Serial
    public static final long serialVersionUID = -1L;

    @Id
//    @GeneratedValue(strategy = GenerationType.IDENTITY)
//    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("唯一ID")
//    @Column(name = "id", nullable = false, columnDefinition = "int unsigned")
    private Integer id;

    @OneToOne(cascade = CascadeType.MERGE)
    @MapsId
    @JoinColumn(name = "id", insertable = true, updatable = false, columnDefinition = "int unsigned", foreignKey = @ForeignKey(name = "device_id"))
    @JsonIgnore
    private Device device;

    @Comment("姓名")
    @Column(length = 8)
    private String name;
    @Comment("昵称")
    @Column(length = 16)
    private String nickname;
    @Comment("头像")
    private String avatar;
    @Comment("性别")
    private Boolean gender;
    @Comment("年龄")
    private Integer age;
    @Comment("生日")
    @JsonFormat(pattern = "yyyy-MM-dd")
    @Temporal(TemporalType.DATE)
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birthday;
    @Comment("地址")
    private String address;
    @Comment("电话")
    @Column(length = 15)
    private String mobile;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
//    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
//    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private Date mtime;

    public Consumer() {
    }

}
			
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
package cn.netkiller.service;

import cn.netkiller.domain.Consumer;
import cn.netkiller.domain.Follow;
import cn.netkiller.repository.FollowRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class FollowService {
    @Autowired
    private FollowRepository followRepository;

    public Iterable<Follow> following() {
        Iterable<Follow> follow = followRepository.findAll();
        return follow;
    }

    public void following(Integer follower, Integer followed) {
        Follow follow = new Follow();
        Consumer me = new Consumer();
        me.setId(follower);

        Consumer their = new Consumer();
        me.setId(followed);

        followRepository.findByFollowerAndFollowed(me, their);

        follow.setFollower(me);
        follow.setFollower(their);

        followRepository.save(follow);

    }

    @Transactional
    public boolean follow(Integer follower, Integer followed) {

//        Consumer follower = new Consumer();
//        follower.setId(follow.getFollower().getId());
//
//        Consumer followed = new Consumer();
//        followed.setId(follow.getFollowed().getId());

        followRepository.followByFollowerAndFollowed(follower, followed);
        return true;
    }

    @Transactional
    public boolean unfollow(Integer follower, Integer followed) {

//        Consumer follower = new Consumer();
//        follower.setId(follow.getFollower().getId());
//
//        Consumer followed = new Consumer();
//        followed.setId(follow.getFollowed().getId());

        followRepository.deleteByFollowerAndFollowed(follower, followed);
        return true;
    }
}
			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.controller;

import cn.netkiller.ai.AigcJsonResponse;
import cn.netkiller.domain.Follow;
import cn.netkiller.service.FollowService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@Slf4j
@RequestMapping("/follow/{appid}/{device}")
public class FollowController {
    @Autowired
    private FollowService followService;

    @GetMapping("following")
    public Iterable<Follow> following() {
        Iterable<Follow> follow = followService.following();
        return follow;
    }

    @PutMapping("follow/{follower}/{followed}")
    public AigcJsonResponse follow(@PathVariable("follower") Integer follower, @PathVariable("followed") Integer followed) {

        followService.follow(follower, followed);
        return new AigcJsonResponse(true);
    }

    @DeleteMapping("unfollow/{follower}/{followed}")
    public AigcJsonResponse unfollow(@PathVariable("follower") Integer follower, @PathVariable("followed") Integer followed) {
        boolean status = followService.unfollow(follower, followed);
        return new AigcJsonResponse(status);
    }
}			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.Consumer;
import cn.netkiller.domain.Follow;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface FollowRepository extends CrudRepository<Follow, Integer> {

    Optional<Follow> findByFollowerAndFollowed(Consumer me, Consumer their);

    @Modifying
//    @Query(value = "DELETE FROM Follow WHERE follower=:follower and followed=:followed", nativeQuery = true)
    @Query(value = "DELETE FROM Follow WHERE follower.id=:follower and followed.id=:followed")
    void deleteByFollowerAndFollowed(@Param("follower") Integer follower, @Param("followed") Integer followed);


    @Query(value = "INSERT INTO Follow(follower,followed) VALUES( :follower,:followed)", nativeQuery = true)
    void followByFollowerAndFollowed(Integer follower, Integer followed);
}			
			]]>
			</programlisting>
			<para>原生写法：@Query(value = "DELETE FROM Follow WHERE
				follower=:follower and followed=:followed", nativeQuery = true)
			</para>
			<para>JPQL写法：@Query(value = "DELETE FROM Follow WHERE
				follower.id=:follower and followed.id=:followed")
			</para>
			<para>两种写法结果相同</para>
		</section>
		<section id="Query.Collection">
			<title>Collection</title>
			<para>返回集合</para>
			<programlisting>
				<![CDATA[
@Query("SELECT u FROM User u WHERE u.status = 1")
Collection<User> findAllActiveUsers();				
				]]>
			</programlisting>
			<para>处理子查询 IN</para>
			<programlisting>
			<![CDATA[
@Query(value = "SELECT u FROM User u WHERE u.name IN :names")
List<User> findUserByNameList(@Param("names") Collection<String> names);			
			]]>
			</programlisting>
		</section>

		<section id="Sort">
			<title>Sort</title>
			<programlisting>
		<![CDATA[
	@Query(value = "SELECT u FROM User u")
	List<User> findAllUsers(Sort sort);		
		]]>
			</programlisting>
		</section>
		<section>
			<title>更新数据，返回值</title>
			<para>返回 0 表示更新失败，返回 1 表示更新成功</para>
			<programlisting>
			<![CDATA[
    @Query("UPDATE Picture SET share = :status WHERE id=:id")
    @Modifying
    int updateShareStatus(@Param("id") Long id, @Param("status") boolean status);
			]]>
			</programlisting>
		</section>
		<section id="@Lock">
			<title>锁 @Lock</title>
			<programlisting>
			<![CDATA[
interface UserRepository extends Repository<User, Long> {

  // Plain query method
  @Lock(LockModeType.READ)
  List<User> findByLastname(String lastname);			
			]]>
			</programlisting>
		</section>
		<section id="JPQL.SUM">
			<title>Sum 求和</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.PictureClick;
import io.lettuce.core.dynamic.annotation.Param;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PictureClickRepository extends CrudRepository<PictureClick, Integer> {

    @Query("SELECT SUM(favorites) AS favorites FROM PictureClick WHERE device.id = :deviceId")
    Optional<Integer> query(@Param("deviceId") Integer deviceId);
		
	@Query(value = "SELECT sum(quantity) FROM Product")
    public Long sumQuantities();

	@Query(value = "SELECT sum(quantity * price) FROM Product")
    public BigDecimal total();	
}	
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
    @Query("SELECT SUM(favorites) AS favorites, SUM(likes) AS likes FROM PictureClick WHERE device.id = :deviceId")
    Optional<List<Integer[]>> query(@Param("deviceId") Integer deviceId);
    
    @Query("SELECT new map(SUM(favorites) AS favorites, SUM(likes) AS likes) FROM PictureClick WHERE device.id = :deviceId")
    Optional<Map<String, Integer>> query(@Param("deviceId") Integer deviceId);
			]]>
			</programlisting>
		</section>
		<section>
			<title>IFNULL</title>
			<programlisting>
			<![CDATA[
    @Query("SELECT new map(IFNULL(SUM(favorites),0) AS favorites, IFNULL(SUM(likes),0) AS likes) FROM PictureClick WHERE device.id = :deviceId")
    Optional<Map<String, Integer>> query(@Param("deviceId") Integer deviceId);
			]]>
			</programlisting>
		</section>
	</section>
	<section id="@Transactional">
		<title>事务 @Transactional</title>
		<literallayout>
			<![CDATA[
下面介绍一下@Transactional注解的参数以及使用：

事物传播行为介绍:

@Transactional(propagation=Propagation.REQUIRED) ：如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)
@Transactional(propagation=Propagation.NOT_SUPPORTED) ：容器不为这个方法开启事务
@Transactional(propagation=Propagation.REQUIRES_NEW) ：不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务
@Transactional(propagation=Propagation.MANDATORY) ：必须在一个已有的事务中执行,否则抛出异常
@Transactional(propagation=Propagation.NEVER) ：必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)
@Transactional(propagation=Propagation.SUPPORTS) ：如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.
事物超时设置:

@Transactional(timeout=30) //默认是30秒
事务隔离级别:

@Transactional(isolation = Isolation.READ_UNCOMMITTED)：读取未提交数据(会出现脏读, 不可重复读) 基本不使用
@Transactional(isolation = Isolation.READ_COMMITTED)：读取已提交数据(会出现不可重复读和幻读)
@Transactional(isolation = Isolation.REPEATABLE_READ)：可重复读(会出现幻读)
@Transactional(isolation = Isolation.SERIALIZABLE)：串行化 　MYSQL: 默认为REPEATABLE_READ级别 　SQLSERVER: 默认为READ_COMMITTED
@Transactional注解中常用参数说明

注意的几点:

@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能.
用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException("注释");)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw new Exception("注释");)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)
@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。
@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 元素的出现 开启 了事务行为。
Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。			

			]]>
		</literallayout>
		<section>
			<title>save() 不需要开启 @Transactional </title>
			<para>在SimpleJpaRepository中save()已经帮我们实现</para>
			<programlisting>
					<![CDATA[
@Repository
@Transactional(readOnly = true)
public class SimpleJpaRepository<T, ID> implements JpaRepositoryImplementation<T, ID> {
​
    private static final String ID_MUST_NOT_BE_NULL = "The given id must not be null!";
​
    private final JpaEntityInformation<T, ?> entityInformation;
    private final EntityManager em;
    private final PersistenceProvider provider;
​
    private @Nullable CrudMethodMetadata metadata;
​
    /**
     * Creates a new {@link SimpleJpaRepository} to manage objects of the given {@link JpaEntityInformation}.
     *
     * @param entityInformation must not be {@literal null}.
     * @param entityManager must not be {@literal null}.
     */
    public SimpleJpaRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
​
        Assert.notNull(entityInformation, "JpaEntityInformation must not be null!");
        Assert.notNull(entityManager, "EntityManager must not be null!");
​
        this.entityInformation = entityInformation;
        this.em = entityManager;
        this.provider = PersistenceProvider.fromEntityManager(entityManager);
    }
​
    /**
     * Creates a new {@link SimpleJpaRepository} to manage objects of the given domain type.
     *
     * @param domainClass must not be {@literal null}.
     * @param em must not be {@literal null}.
     */
    public SimpleJpaRepository(Class<T> domainClass, EntityManager em) {
        this(JpaEntityInformationSupport.getEntityInformation(domainClass, em), em);
    }
​
    /**
     * Configures a custom {@link CrudMethodMetadata} to be used to detect {@link LockModeType}s and query hints to be
     * applied to queries.
     *
     * @param crudMethodMetadata
     */
    public void setRepositoryMethodMetadata(CrudMethodMetadata crudMethodMetadata) {
        this.metadata = crudMethodMetadata;
    }
​
    @Nullable
    protected CrudMethodMetadata getRepositoryMethodMetadata() {
        return metadata;
    }
​
    //......
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.CrudRepository#delete(java.io.Serializable)
     */
    @Transactional
    public void deleteById(ID id) {
​
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);
​
        delete(findById(id).orElseThrow(() -> new EmptyResultDataAccessException(
                String.format("No %s entity with id %s exists!", entityInformation.getJavaType(), id), 1)));
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.CrudRepository#delete(java.lang.Object)
     */
    @Transactional
    public void delete(T entity) {
​
        Assert.notNull(entity, "The entity must not be null!");
        em.remove(em.contains(entity) ? entity : em.merge(entity));
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.CrudRepository#delete(java.lang.Iterable)
     */
    @Transactional
    public void deleteAll(Iterable<? extends T> entities) {
​
        Assert.notNull(entities, "The given Iterable of entities not be null!");
​
        for (T entity : entities) {
            delete(entity);
        }
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#deleteInBatch(java.lang.Iterable)
     */
    @Transactional
    public void deleteInBatch(Iterable<T> entities) {
​
        Assert.notNull(entities, "The given Iterable of entities not be null!");
​
        if (!entities.iterator().hasNext()) {
            return;
        }
​
        applyAndBind(getQueryString(DELETE_ALL_QUERY_STRING, entityInformation.getEntityName()), entities, em)
                .executeUpdate();
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.Repository#deleteAll()
     */
    @Transactional
    public void deleteAll() {
​
        for (T element : findAll()) {
            delete(element);
        }
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#deleteAllInBatch()
     */
    @Transactional
    public void deleteAllInBatch() {
        em.createQuery(getDeleteAllQueryString()).executeUpdate();
    }
​
    //......
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.CrudRepository#save(java.lang.Object)
     */
    @Transactional
    public <S extends T> S save(S entity) {
​
        if (entityInformation.isNew(entity)) {
            em.persist(entity);
            return entity;
        } else {
            return em.merge(entity);
        }
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#saveAndFlush(java.lang.Object)
     */
    @Transactional
    public <S extends T> S saveAndFlush(S entity) {
​
        S result = save(entity);
        flush();
​
        return result;
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#save(java.lang.Iterable)
     */
    @Transactional
    public <S extends T> List<S> saveAll(Iterable<S> entities) {
​
        Assert.notNull(entities, "The given Iterable of entities not be null!");
​
        List<S> result = new ArrayList<S>();
​
        for (S entity : entities) {
            result.add(save(entity));
        }
​
        return result;
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#flush()
     */
    @Transactional
    public void flush() {
        em.flush();
    }
​
    //......
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.repository.CrudRepository#findById(java.io.Serializable)
     */
    public Optional<T> findById(ID id) {
​
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);
​
        Class<T> domainType = getDomainClass();
​
        if (metadata == null) {
            return Optional.ofNullable(em.find(domainType, id));
        }
​
        LockModeType type = metadata.getLockModeType();
​
        Map<String, Object> hints = getQueryHints().withFetchGraphs(em).asMap();
​
        return Optional.ofNullable(type == null ? em.find(domainType, id, hints) : em.find(domainType, id, type, hints));
    }
​
    /*
     * (non-Javadoc)
     * @see org.springframework.data.jpa.repository.JpaRepository#getOne(java.io.Serializable)
     */
    @Override
    public T getOne(ID id) {
​
        Assert.notNull(id, ID_MUST_NOT_BE_NULL);
        return em.getReference(getDomainClass(), id);
    }
​
    /**
     * Applies the given {@link Specification} to the given {@link CriteriaQuery}.
     *
     * @param spec can be {@literal null}.
     * @param domainClass must not be {@literal null}.
     * @param query must not be {@literal null}.
     * @return
     */
    private <S, U extends T> Root<U> applySpecificationToCriteria(@Nullable Specification<U> spec, Class<U> domainClass,
            CriteriaQuery<S> query) {
​
        Assert.notNull(domainClass, "Domain class must not be null!");
        Assert.notNull(query, "CriteriaQuery must not be null!");
​
        Root<U> root = query.from(domainClass);
​
        if (spec == null) {
            return root;
        }
​
        CriteriaBuilder builder = em.getCriteriaBuilder();
        Predicate predicate = spec.toPredicate(root, query, builder);
​
        if (predicate != null) {
            query.where(predicate);
        }
​
        return root;
    }
    //......
}			
					]]>
			</programlisting>
		</section>
		<section>
			<title>SERIALIZABLE</title>
			<programlisting>
					<![CDATA[
@Transactional(isolation = Isolation.SERIALIZABLE)					
					]]>
			</programlisting>
		</section>
		<section>
			<title>readOnly</title>
			<programlisting>
					<![CDATA[
@Transactional(propagation = Propagation.SUPPORTS, readOnly = true)			
					]]>
			</programlisting>
		</section>
		<section>
			<title>删除更新需要 @Transactional 注解</title>
			<programlisting>
				<![CDATA[
package cn.netkiller.api.repository;

import javax.transaction.Transactional;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import cn.netkiller.api.domain.RecentRead;

@Repository
public interface RecentReadRepostitory extends CrudRepository<RecentRead, Integer> {

	Page<RecentRead> findByMemberIdOrderByIdDesc(int memberId, Pageable pageable);

	int countByMemberId(int memberId);
	
	@Transactional
	@Modifying
	@Query("DELETE FROM RecentRead r WHERE r.memberId = ?1 AND r.articleId = ?2")
	void deleteByMemberIdAndArticleId(int memberId, int articleId);
	
	@Transactional
	@Modifying
	@Query("delete from RecentRead where member_id = :member_id")
	public void deleteByMemberId(@Param("member_id") int memberId);

	int countByMemberIdAndArticleId(int memberId, int articleId);

}				
				]]>
			</programlisting>
		</section>
		<section>
			<title>回滚操作</title>
			<programlisting>
				<![CDATA[
	// 指定Exception回滚
	@Transactional(rollbackFor=Exception.class)
    public void methodName() {
       // 不会回滚
       throw new Exception("...");
    }

	//指定Exception回滚，但其他异常不回滚
	@Transactional(noRollbackFor=Exception.class)
    public ItimDaoImpl getItemDaoImpl() {
        // 会回滚
        throw new RuntimeException("注释");
    }
				]]>
			</programlisting>
			<programlisting>
				<![CDATA[
@Service
public class UserService {
    @Autowired
    private UserRepostitory userRepostitory;
    
    @Transactional
    public void add(User user) {
        try {
            userRepostitory.save(user);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
        }
        // 不会回滚
    }
    @Transactional
    public void add(User user) throws Exception {
        try {
             userRepostitory.delete(user);
        } catch (Exception e) {
            log.error(e.getMessage(), e);
            // 抛出异常才会回滚
            throw new Exception(e);
        }
    }
}
				
				]]>
			</programlisting>
		</section>
		<section>
			<title>private、default、protected 和 final 不支持事物 </title>
			<para>@Transactional 必须与 public 一起使用，不能定义为 private、default、protected
			</para>
			<programlisting>
				<![CDATA[
@Service
public class UserService {
    @Transactional
    private void add(User user) {
         save(user);
    }
}
				]]>
			</programlisting>
		</section>
		<section>
			<title>Service 注意事项</title>
			<para>this 调用不支持事物</para>
			<programlisting>
				<![CDATA[
@Service
public class UserService {

    @Autowired
    private UserRepostitory userRepostitory;

    @Transactional
    public void add(User user) {
        userRepostitory.save(user);
        this.update(user);
    }

    @Transactional
    public void update(User user) {
        userRepostitory.update(user);
    }
}				
				]]>
			</programlisting>
			<para>解决方案</para>
			<programlisting>
				<![CDATA[
@Servcie
public class UserService {
   @Autowired
   prvate ProfileService profileService;

   public void save(User user) {
         profileService.save(user);
   }
}

 @Servcie
 public class ProfileService {

    @Transactional(rollbackFor=Exception.class)
    public void save(User user) {

    }

}				
				]]>
			</programlisting>
		</section>
		<section>
			<title>需要 @Service 注解配合使用</title>
			<para>@Transactional 需要在 @Controller、@Service、@Component、@Repository
				等注解下才能使用
			</para>
			<programlisting>
				<![CDATA[
// @Servcie
public class UserService {
	@Autowired
	prvate ProfileService profileService;
   
	@Transactional
	public void save(User user) {
         profileService.save(user);
	}
}				
				]]>
			</programlisting>
			<para>屏蔽 @Servcie 后观察 save 的 @Transactional 是不生效的。</para>
			<programlisting>
				<![CDATA[
@Service
public class UserService {

    @Autowired
    private UserRepostitory userRepostitory;
    @Autowired
    private RoleService roleService;

    @Transactional
    public void add(User user) throws Exception {
        userRepostitory.save(user);
        new Thread(() -> {
            roleService.doOtherThing();
        }).start();
    }
}

@Service
public class RoleService {

    @Transactional
    public void doOtherThing() {
        ...
        ...
    }
}				
				]]>
			</programlisting>
		</section>
		<section>
			<title>事务回滚</title>
			<programlisting>
				<![CDATA[
    @Transactional
    public void test(SysConfigEntity entity) throws Exception {
        //不会回滚
        this.saveSysConfig(entity);
        throw new Exception("rollback test");
         
    }
     
    @Transactional(rollbackFor = Exception.class)
    public void test1(SysConfigEntity entity) throws Exception {
        //会回滚
        this.saveSysConfig(entity);
        throw new Exception("rollback test");
         
    }
     
    @Transactional
    public void test2(SysConfigEntity entity) throws Exception {
        //会回滚
        this.saveSysConfig(entity);
        throw new RuntimeException("rollback test");
         
    }
     
    @Transactional
    public void test3(SysConfigEntity entity) throws Exception {
        //事务仍然会被提交
        this.test4(entity);
        throw new Exception("rollback test");
    }
     
    @Transactional(rollbackFor = Exception.class)
    public void test4(SysConfigEntity entity) throws Exception {
         
        this.saveSysConfig(entity);
    }			
				]]>
			</programlisting>
		</section>
	</section>
	<section id="jpa.mysql.faq">
		<title>FAQ 常见问题</title>
		<section>
			<title>Could not write JSON: failed to lazily initialize a collection
				of role
			</title>
			<screen>
		<![CDATA[
{"status":false,"code":"HttpMessageNotWritableException","data":null,"reason":"Could not write JSON: failed to lazily initialize a collection of role: cn.netkiller.domain.Lora.keyword: could not initialize proxy - no Session"}⏎
		]]>
			</screen>
			<programlisting>
		<![CDATA[
	@ElementCollection(fetch = FetchType.EAGER)
    private Set<String> keyword = new HashSet<String>();
		]]>
			</programlisting>
		</section>
		<section>
			<title>Query did not return a unique result: 2 results were returned
			</title>
			<para>查询 version 表中的最有一条记录，提示 Query did not return a unique result: 2
				results were returned
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.domain;

import jakarta.persistence.*;
import lombok.Data;
import org.hibernate.annotations.Comment;
import org.hibernate.annotations.DynamicInsert;
import org.hibernate.annotations.DynamicUpdate;

import java.io.Serial;
import java.io.Serializable;
import java.util.Date;

@Entity
@Table
@DynamicUpdate
@DynamicInsert
@Data
@Comment("版本表")
public class Version implements Serializable {
    @Serial
    public static final long serialVersionUID = 1L;

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", unique = true, nullable = false, insertable = false, updatable = false, columnDefinition = "int unsigned")
    @Comment("主键")
    private Integer id;

    @Comment("产品")
    @Column(columnDefinition = "enum('Phone','Tablet','Badges','Watch') DEFAULT 'Tablet'")
    private String product;

    @Comment("版本")
    @Column(length = 5)
    private String version;
    @Comment("下载地址")
    private String url;

    @Column(insertable = false, updatable = false, columnDefinition = "TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
    @Comment("创建时间")
    private Date ctime;

    @Column(nullable = true, insertable = false, updatable = false, columnDefinition = "TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP")
    @Comment("修改时间")
    private Date mtime;

}
	
			]]>
			</programlisting>
			<para>接口定义 findOneBy 查询 version 表中存在多条记录，我们只要最后一条，所以不能使用
				findOneBy，需要使用 findFirstBy
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.Version;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface VersionRepository extends CrudRepository<Version, Integer> {
    Iterable<Version> findByProduct(String tablet);

    Optional<Version> findOneByProductOrderByIdDesc(String tablet);
}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;

import cn.netkiller.domain.Version;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface VersionRepository extends CrudRepository<Version, Integer> {
    Iterable<Version> findByProduct(String tablet);

    Optional<Version> findFirstByProductOrderByIdDesc(String tablet);
}
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
    @GetMapping("/version/tablet/latest")
    public AigcResponse tabletLatest() {
        Optional<Version> optional = versionRepository.findFirstByProductOrderByIdDesc("Tablet");
        if (optional.isPresent()) {
            Version version = optional.get();
            log.debug(version.toString());
            return new AigcResponse(version);
        }
        return new AigcResponse(null);
    }
			]]>
			</programlisting>
		</section>
		<section>
			<title>Executing an update/delete query</title>
			<para>org.springframework.dao.InvalidDataAccessApiUsageException:
				Executing an update/delete query
			</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.repository;


import cn.netkiller.domain.Picture;
import io.lettuce.core.dynamic.annotation.Param;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PictureRepository extends JpaRepository<Picture, Long> {
    @Query("UPDATE Picture SET share = :status WHERE id=:id")
    @Modifying
    int updateShareStatus(@Param("id") Long id, @Param("status") boolean status);
}
			]]>
			</programlisting>
			<para>Service</para>
			<programlisting>
			<![CDATA[
    public int share(Long id, boolean status) {
        return pictureRepository.updateShareStatus(id, status);
    }
			]]>
			</programlisting>
			<para>解决方案，再 Server 方法增加事务注解</para>
			<programlisting>
			<![CDATA[
    @Transactional(rollbackFor = Exception.class)
    public int share(Long id, boolean status) {
        return pictureRepository.updateShareStatus(id, status);
    }
			]]>
			</programlisting>

		</section>
		<section>
			<title>could not initialize proxy [cn.netkiller.domain.Device#16] -
				no Session </title>
			<para>第一种解决方法，捕捉 LazyInitializationException 异常</para>
			<programlisting>
			<![CDATA[
    @Cacheable(value = "picture:click", key = "#deviceId+'-'+#pictureId", unless = "#result == null")
    public Optional<PictureClick> click(Integer deviceId, Integer pictureId) {
        Optional<PictureClick> optional = pictureClickRepository.findByDeviceIdAndPictureId(deviceId, pictureId);
        optional.ifPresent(pictureClick -> {
            try {
                log.debug(pictureClick.toString());
            } catch (LazyInitializationException e) {
                log.error(e.getMessage());
            }
        });
        return optional;
    }	
			]]>
			</programlisting>
			<para>第二种解决方法 FetchType.EAGER</para>
			<programlisting>
			<![CDATA[
@ManyToOne(fetch = FetchType.EAGER, optional = false)	
			]]>
			</programlisting>
			<para>第三种解决方法 @Transactional(readOnly = true)</para>
			<programlisting>
			<![CDATA[
    @Transactional(readOnly = true)
    public Optional<PictureClick> click(Integer deviceId, Integer pictureId) {
        Optional<PictureClick> optional = pictureClickRepository.queryByDeviceIdAndPictureId(deviceId, pictureId);
        optional.ifPresent(pictureClick -> {
            try {
                log.debug(pictureClick.toString());
            } catch (LazyInitializationException e) {
                log.error(e.getMessage());
            }
        });
        return optional;
    }	
			]]>
			</programlisting>
			<para>第四种解决方法 @Proxy(lazy = false)</para>
			<programlisting>
			<![CDATA[
@Proxy(lazy = false) 的意思和FetchType.EAGER类似	
			]]>
			</programlisting>
		</section>
		<section>
			<title>this is incompatible with sql_mode=only_full_group_by</title>
			<screen>
			<![CDATA[
JDBC exception executing SQL [select p1_0.id,p1_0.audio,p1_0.audit,p1_0.bmp,p1_0.ctime,p1_0.device,p1_0.english,p1_0.favorites,p1_0.forward,p1_0.group_id,p1_0.image,p1_0.likes,p1_0.mtime,p1_0.picture_group_id,p1_0.pinyin,p1_0.prompt,p1_0.session,p1_0.share,p1_0.story,p1_0.thumbnail,p1_0.translate from picture p1_0 where p1_0.audit=1 and p1_0.share=1 group by coalesce(p1_0.picture_group_id,p1_0.session) limit ?,?] [Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'watch.p1_0.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by] [n/a]; SQL [n/a]
			]]>
			</screen>
			<para>解决方案一，使用 ANY_VALUE() 函数</para>
			<programlisting>
			<![CDATA[
	@Query(" SELECT ANY_VALUE(p.id), ANY_VALUE(p.story), ANY_VALUE(p.image) FROM Picture p WHERE p.audit = true AND p.share = true GROUP BY IFNULL(p.pictureGroup.id,p.session)")
    Page<Picture> queryGroup(Pageable pageable);
			]]>
			</programlisting>
			<para>解决方案二，修改数据库配置</para>
			<programlisting>
			<![CDATA[
	SET sql_mode='';
	SELECT id,name,group_id FROM test.photograph group by group_id;
			
			
	SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));
    SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''));
			]]>
			</programlisting>
		</section>
	</section>
</chapter>