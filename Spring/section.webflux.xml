<section id="webflux.router">
	<title>WebFlux Router</title>
	<section id="router.component">
		<title>Component 原件</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.webflux.component;

import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;

import reactor.core.publisher.Mono;

@Component
public class HelloWorldHandler {

	public HelloWorldHandler() {
	}

	public Mono<ServerResponse> helloWorld(ServerRequest request) {
		return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World!!!"));
	}
}

		]]>
		</programlisting>
	</section>
	<section id="router.config">
		<title>路由配置</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.webflux.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;

import cn.netkiller.webflux.component.HelloWorldHandler;

@Configuration
public class WebFluxRouter {

	public WebFluxRouter() {
	}

	@Bean
	public RouterFunction<ServerResponse> routeHelloWorld(HelloWorldHandler helloWorldHandler) {

		return RouterFunctions.route(RequestPredicates.GET("/hello").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), helloWorldHandler::helloWorld);
	}
}
		
		]]>
		</programlisting>
	</section>
	<section id="webflux.Thymeleaf">
		<title>Thymeleaf</title>
		<section>
			<title>模板引擎 Thymeleaf 依赖</title>
			<screen>
			<![CDATA[
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>			
			]]>
			</screen>
		</section>
		<section>
			<title>application.properties 相关的配置</title>
			<screen>
			<![CDATA[
spring.thymeleaf.cache=true # Enable template caching.
spring.thymeleaf.check-template=true # Check that the template exists before rendering it.
spring.thymeleaf.check-template-location=true # Check that the templates location exists.
spring.thymeleaf.enabled=true # Enable Thymeleaf view resolution for Web frameworks.
spring.thymeleaf.encoding=UTF-8 # Template files encoding.
spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.
spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.
spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.
spring.thymeleaf.reactive.max-chunk-size= # Maximum size of data buffers used for writing to the response, in bytes.
spring.thymeleaf.reactive.media-types= # Media types supported by the view technology.
spring.thymeleaf.servlet.content-type=text/html # Content-Type value written to HTTP responses.
spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.
spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.
spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.
			]]>
			</screen>
		</section>
		<section>
			<title>Webflux 控制器</title>
			<programlisting>
			<![CDATA[
	@GetMapping("/welcome")
    public Mono<String> hello(final Model model) {
        model.addAttribute("name", "Neo");
        model.addAttribute("city", "深圳");

        String path = "hello";
        return Mono.create(monoSink -> monoSink.success(path));
    }

    @GetMapping("/list")
    public String listPage(final Model model) {
        final Flux<City> citys = cityService.findAllCity();
        model.addAttribute("cityLists", citys);
        return "cityList";
    }			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Tymeleaf 视图</title>
			<para>welcome.html</para>
			<programlisting>
			<![CDATA[
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>欢迎页面</title>
</head>

<body>

<h1 >你好，欢迎来自<p th:text="${city}"></p>的<p th:text="${name}"></p></h1>

</body>
</html>			
			]]>
			</programlisting>
			<para>cityList.html</para>
			<programlisting>
			<![CDATA[
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>城市列表</title>
</head>

<body>

<div>


    <table>
        <legend>
            <strong>城市列表</strong>
        </legend>
        <thead>
        <tr>
            <th>城市编号</th>
            <th>省份编号</th>
            <th>名称</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="city : ${cityLists}">
            <td th:text="${city.id}"></td>
            <td th:text="${city.provinceId}"></td>
            <td th:text="${city.name}"></td>
            <td th:text="${city.description}"></td>
        </tr>
        </tbody>
    </table>

</div>

</body>
</html>			
			]]>
			</programlisting>
		</section>

	</section>
	<section id="redis-reactive">
		<title>Webflux Redis</title>
		<section>
			<title>Maven Redis 依赖</title>
			<screen>
			<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis-reactive</artifactId>
		</dependency>
			]]>
			</screen>
		</section>
		<section>
			<title>Redis 配置</title>
			<screen>
			<![CDATA[
server:
  port: 8080
spring:
  application:
    name: webflux
  redis:
    host: 127.0.0.1
    port: 6379
    password: pwd2020
    timeout: 5000
    lettuce:
      pool:
        max-active: 200 
        max-idle: 20 
        min-idle: 5 
        max-wait: 1000 			
			]]>
			</screen>
		</section>
		<section>
			<title>Config</title>
			<programlisting>
			<![CDATA[
	@Bean
	public ReactiveRedisTemplate<String, String> reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
		ReactiveRedisTemplate<String, String> reactiveRedisTemplate = new ReactiveRedisTemplate<>(factory,RedisSerializationContext.string());
		return reactiveRedisTemplate;
	}			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Service</title>
			<programlisting>
			<![CDATA[
@Service
public class RedisServiceImpl implements RedisService {

	@Autowired
	private ReactiveRedisTemplate<String, String> redisTemplate;
	
	@Override
	public Mono<String> get(String key) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.get(key);
	}

	@Override
	public Mono<String> set(String key,User user) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.getAndSet(key, JSON.toJSONString(user));
	}

	@Override
	public Mono<Boolean> delete(String key) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.delete(key);
	}

	@Override
	public Mono<String> update(String key,User user) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.getAndSet(key, JSON.toJSONString(user));
	}

	@Override
	public Flux<String> all(String key) {
		ReactiveListOperations<String, String> operations = redisTemplate.opsForList();
		return operations.range(key, 0, -1);
	}


	@Override
	public Mono<Long> push(String key,List<String> list) {
		
		ReactiveListOperations<String, String> operations = redisTemplate.opsForList();
		return operations.leftPushAll(key, list);
	}
	
	@Override
	public Flux<String> find(String key) {
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return redisTemplate.keys(key).flatMap(keyId ->operations.get(keyId));
	}
}			
			]]>
			</programlisting>
		</section>
		<section>
			<title></title>
			<programlisting>
			<![CDATA[
@RestController
@RequestMapping("/user")
public class UserController {
	
	public final static String USER_KEY="user";
	
	@Autowired
	private RedisService redisService;
	
	@GetMapping("/get/{key}")
	public Mono<String> getUserByKey(@PathVariable("id")String key){
		return redisService.get(key);
	}
	
	@GetMapping("/add")
	public Mono<String> add(User user){
		user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");

		System.out.println(JSON.toJSONString(user));
		return redisService.set("neo",user);		
	}
	
	@GetMapping("/addlist")
	public Mono<Long> addlist(){
		List<String> list=new ArrayList<String>();
		User user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");
		
		//添加第一条数据
		list.add(JSON.toJSONString(user));
		//添加第二条数据
		list.add(JSON.toJSONString(user));
		//添加第三条数据
		list.add(JSON.toJSONString(user));
		
		return redisService.addlist("list", list);
	}

	@GetMapping(value="/findAll",produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
	public Flux<String> findAll(){
		return redisService.all("list").delayElements(Duration.ofSeconds(2));
	}
	
	@GetMapping("/getUsers")
	public Flux<String> findUsers() {
		return redisService.find("*").delayElements(Duration.ofSeconds(2));
	}
}			
			]]>
			</programlisting>
		</section>
	</section>
	<section id="mongodb-reactive">
		<title>Webflux Mongdb</title>
		<section>
			<title>Maven 依赖</title>
			<screen>
			<![CDATA[
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
	</dependency>			
			]]>
			</screen>
		</section>
		<section>
			<title>Repository</title>
			<programlisting>
			<![CDATA[
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;

import cn.netkiller.entity.User;

public interface UserRepository extends ReactiveMongoRepository<User, Long>{

}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Service</title>
			<screen>
			<![CDATA[
@Service
public class MongoServiceImpl implements MongoService {
	
	@Autowired
	private UserRepository userRepository;
	
	@Override
	public Mono<User> getById(Long id) {
		return userRepository.findById(id);
	}

	@Override
	public Mono<User> addUser(User user) {
		return userRepository.save(user);
	}

	@Override
	public Mono<Boolean> deleteById(Long id) {
		 userRepository.deleteById(id);
		 return Mono.create(userMonoSink -> userMonoSink.success());
	}

	@Override
	public Mono<User> updateById(User user) {
		return userRepository.save(user);
	}

	@Override
	public Flux<User> findAllUser() {
		return userRepository.findAll();
	}
}			
			]]>
			</screen>
		</section>
		<section>
			<title>控制器</title>
			<programlisting>
			<![CDATA[
@RestController
@RequestMapping("/usermg")
public class UserMongoController {
	
	@Autowired
	private MongoService mongoService;

	@GetMapping("/add")
	public Mono<User> add(User user) {
		user = new User();
		User user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");
		
	
		System.out.println(JSON.toJSONString(user));
		return mongoService.addUser(user);

	}
	
	/**
	 *	注意这里 produces = MediaType.APPLICATION_STREAM_JSON_VALUE 必须这样设置
	 */
	@GetMapping(value="/findAll",produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
	public Flux<User> findAll(){
		return mongoService.findAllUser().delayElements(Duration.ofSeconds(1));
	}
}
			]]>
			</programlisting>
			<para>produces
				如果不是application/stream+json则调用端无法滚动得到结果，将一直阻塞等待数据流结束或超时。
			</para>
		</section>
	</section>
	<section id="webflux.mono">
		<title>Mono</title>
		<para>Mono(返回0或1个元素)/Flux(返回0-n个元素)</para>
		<programlisting>
		<![CDATA[
    @GetMapping("mono")
    public Mono<Object> mono() {
        return Mono.create(monoSink -> {
                    log.info("创建 Mono");
                    monoSink.success("hello webflux");
                })
                .doOnSubscribe(subscription -> { //当订阅者去订阅发布者的时候，该方法会调用
                    log.info("doOnSubscribe={}", subscription);
                }).doOnNext(next -> { //当订阅者收到数据时，改方法会调用
                    log.info("doOnNext={}", next);
                });
    }
		]]>
		</programlisting>
		<para>从 Supplier 创建 Mono</para>
		<programlisting>
		<![CDATA[
    @GetMapping("/get")
    private Mono<String> get() {
        log.info("start");
        Mono<String> result = Mono.fromSupplier(() -> {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
            }
            return "netkiller";
        });
        log.info("end");
        return result;
    }		
		]]>
		</programlisting>
	</section>
	<section id="webflux.flux">
		<title>Flux 返回多条数据</title>
		<para>返回 List</para>
		<programlisting>
		<![CDATA[
    @GetMapping("flux")
    public Flux<Picture> flux() {
        List<Picture> list = new ArrayList<Picture>();
        IntStream.range(1, 10).forEach(i -> {
            Picture picture = new Picture();
            picture.setId(Long.valueOf(i));
            picture.setImage("https://www.netkiller.cn/images/" + i + ".png");
            list.add(picture);
        });
        return Flux.fromIterable(list);
    }
		]]>
		</programlisting>
		<para>返回 Map</para>
		<programlisting>
		<![CDATA[
    @GetMapping("map")
    public Flux<Map.Entry<String, String>> map() {
        Map<String, String> map = new HashMap<>();
        IntStream.range(1, 10).forEach(i -> {
            map.put("key" + i, "value" + i);
        });

        return Flux.fromIterable(map.entrySet());
    }
		]]>
		</programlisting>
		<para>从 Stream 返回 Flux</para>
		<programlisting>
		<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<String> getWords() {
        Stream<String> items = Arrays.asList("alpha", "bravo", "charlie").stream();
        return Flux.fromStream(items);
    }		
		]]>
		</programlisting>
	</section>

	<section id="webflux.sse">
		<title>SSE</title>

		<section>
			<title>一次性事件</title>
			<programlisting>
			<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> createConnectionAndSendEvents() {
        return Flux.just("Alpha", "Omega");
    }			
			]]>
			</programlisting>
			<para>curl 访问 SSE 需要设置HTTP头 -H "Accept: text/event-stream" </para>
			<screen>
			<![CDATA[
neo@MacBook-Pro-M2 ~ % curl -H "Accept: text/event-stream" -X 'GET' 'http://localhost:8080/mock/sse'
data:Alpha

data:Omega			
			]]>
			</screen>
			<tip>Safari 浏览器不支持 SSE推送，微软的 Egde 支持。</tip>
		</section>
		<section>
			<title>周期性事件</title>
			<para>每间隔一秒发送一次数据</para>
			<programlisting>
			<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<String> getWords() {
        String[] WORDS = "The quick brown fox jumps over the lazy dog.".split(" ");
        return Flux
                .zip(Flux.just(WORDS), Flux.interval(Duration.ofSeconds(1)))
                .map(Tuple2::getT1);
    }
    
	@GetMapping("/random")
	public Flux<ServerSentEvent<Integer>> randomNumbers() {
		return Flux.interval(Duration.ofSeconds(1)).map(seq -> Tuples.of(seq, ThreadLocalRandom.current().nextInt())).map(data -> ServerSentEvent.<Integer>builder().event("random").id(Long.toString(data.getT1())).data(data.getT2()).build());
	}    
	
	@GetMapping(path = "/stream-flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux<String> streamFlux() {
	    return Flux.interval(Duration.ofSeconds(1))
	      .map(sequence -> "Flux - " + LocalTime.now().toString());
	}	
			]]>
			</programlisting>
		</section>
		<section>
			<title>SSE 完整的例子</title>
			<programlisting>
		<![CDATA[
package cn.netkiller.webflux.controller;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerSentEvent;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;
import reactor.util.function.Tuples;

@RestController
@RequestMapping("/sse")
public class SseController {
	private int count_down = 10;

	public SseController() {

	}

	@GetMapping(value = "/launch", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux<ServerSentEvent<Object>> countDown() {

		return Flux.interval(Duration.ofSeconds(1)).map(seq -> Tuples.of(seq, getCountDownSec())).map(data -> ServerSentEvent.<Object>builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}

	private String getCountDownSec() {
		if (count_down > 0) {
			count_down--;
			return "倒计时：" + count_down;
		}
		return "发射";
	}



	@GetMapping("/range")
	public Flux<Object> range() {
		return Flux.range(10, 1).map(seq -> Tuples.of(seq, getCountDownSec())).map(data -> ServerSentEvent.<Object>builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}
	
	// WebFlux 服务器推送(SSE - >Server Send Event)
	@GetMapping(value = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	private Flux<String> flux() {
		Flux<String> result = Flux.fromStream(IntStream.range(1, 10).mapToObj(i -> {
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
			}
			logger.info("sse " + i);
			return "flux data -- " + i;
		}));
		return result;
	}
}
		
		]]>
			</programlisting>
			<para>运行结果</para>
			<screen>
		<![CDATA[
id:0
event:launch
data:倒计时：9

id:1
event:launch
data:倒计时：8

id:2
event:launch
data:倒计时：7

id:3
event:launch
data:倒计时：6

id:4
event:launch
data:倒计时：5

id:5
event:launch
data:倒计时：4

id:6
event:launch
data:倒计时：3

id:7
event:launch
data:倒计时：2

id:8
event:launch
data:倒计时：1

id:9
event:launch
data:倒计时：0

id:10
event:launch
data:发射
		
		]]>
			</screen>
		</section>
		<section>
			<title>SSE Client 订阅实例</title>
			<programlisting>
			<![CDATA[
 	@GetMapping("/server")
    public Flux<ServerSentEvent<String>> streamEvents() {
        return Flux.interval(Duration.ofSeconds(1))
                .map(sequence -> ServerSentEvent.<String>builder()
                        .id(String.valueOf(sequence))
                        .event("test-event")
                        .data("LocalTime: " + LocalTime.now())
                        .build());
    }

    @GetMapping("/client")
    public void consumeServerSentEvent() {
        WebClient client = WebClient.create("http://localhost:8080");
        ParameterizedTypeReference<ServerSentEvent<String>> type
                = new ParameterizedTypeReference<ServerSentEvent<String>>() {
        };

        Flux<ServerSentEvent<String>> eventStream = client.get()
                .uri("mock/server")
                .retrieve()
                .bodyToFlux(type);

        eventStream.subscribe(
                content -> log.info("Time: {} - event: name[{}], id [{}], content[{}] ",
                        LocalTime.now(), content.event(), content.id(), content.data()),
                error -> log.error("Error receiving SSE: {}", error),
                () -> log.info("Completed!!!"));
    }
			]]>
			</programlisting>
		</section>
	</section>
	<section id="webflux.webclient">
		<title>WebClient</title>
		<programlisting>
		<![CDATA[
    @GetMapping("webclient")
    public Mono<String> webclient() {
        WebClient webClient = WebClient.create("http://localhost:8080");
        Mono<String> response = webClient
                .get().uri("/mock/mono")
                .retrieve()
                .bodyToMono(String.class);
        response.subscribe(System.out::println);
        return response;
    }
		]]>
		</programlisting>
		<section>
			<title></title>
			<programlisting>
		<![CDATA[
WebClient.create("http://localhost:8080")
    .get()
    .uri("/students")
    .retrieve()
    .bodyToFlux(Student.class);		
			]]>
			</programlisting>
		</section>
		<section>
			<title>URI 参数</title>
			<programlisting>
			<![CDATA[
WebClient.create("http://localhost:8080")
    .get()
    .uri("/students/" + studentId)
    .retrieve()
    .bodyToMono(Student.class);
			]]>
			</programlisting>
			<para>通过 uriBuilder 组装 Uri 参数</para>
			<programlisting>
			<![CDATA[
WebClient.create("http://localhost:8080")
    .get()
    .uri(uriBuilder -> uriBuilder
        .path("/student/{studentId}")
        .build(studentId))
    .retrieve()
    .bodyToMono(Student.class);		
    
WebClient.create("http://localhost:8080")
    .get()
    .uri(uriBuilder -> uriBuilder
        .path("/student/{studentId}/assignments/{assignmentId}")
        .build(studentId, assignmentId))
    .retrieve()
    .bodyToMono(Student.class);
			]]>
			</programlisting>
			<para>uriTemplate 组装 Uri 参数</para>
			<programlisting>
			<![CDATA[
UriTemplate uriTemplate = new UriTemplate(
    "/student/{studentId}/assignments/{assignmentId}");

WebClient.create("http://localhost:8080")
    .get()
    .uri(uriTemplate.expand(studentId, assignmentId))
    .retrieve()
    .bodyToMono(Student.class);			
			]]>
			</programlisting>
		</section>
		<section>
			<title>查询参数</title>
			<para>http://localhost:8080/students?firstName=Jon&year=1996</para>
			<programlisting>
			<![CDATA[
String firstName = "Jon";
String year = "1996";

WebClient.create("http://localhost:8080")
    .get()
    .uri(uriBuilder -> uriBuilder.path("/students")
        .queryParam("firstName", firstName)
        .queryParam("year", year)
        .build())
    .retrieve()
    .bodyToMono(Student.class);			
			]]>
			</programlisting>
			<para>http://localhost:8080/students?year=1995,1996,1997</para>
			<programlisting>
			<![CDATA[
WebClient.create("http://localhost:8080")
    .get()
    .uri(uriBuilder -> uriBuilder.path("/students")
        .queryParam("year", String.join(",", "1995", "1996", "1997"))
        .build())
    .retrieve()
    .bodyToMono(Student.class);			
			]]>
			</programlisting>
			<programlisting>
			<![CDATA[
			
			]]>
			</programlisting>
		</section>
		<section>
			<title></title>
			<programlisting>
			<![CDATA[
			
			]]>
			</programlisting>
		</section>
	</section>
</section>
