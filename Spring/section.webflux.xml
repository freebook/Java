<?xml version="1.0" encoding="UTF-8"?>
<section id="WebFlux.VS.SprintMVC">
	<title>WebFlux 与 SprintMVC 有什么不同？</title>
	<section>
		<title>实验程序</title>
		<programlisting>
			<![CDATA[
package cn.netkiller.controller;

import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@RestController
@Slf4j
public class WebFluxController {
	private static final Logger logger = LoggerFactory.getLogger(WebFluxController.class);

	public WebFluxController() {
	}

	// 阻塞5秒钟
	private String job() {
		try {
			TimeUnit.SECONDS.sleep(5);
		} catch (InterruptedException e) {
		}
		return "Hellowoard!!!";
	}

	// SpringMVC 方式
	@GetMapping("/SpringMVC")
	private String springmvc() {
		logger.info("start");
		String result = job();
		logger.info("done");
		return result;
	}

	// WebFlux 方式
	@GetMapping("/WebFlux")
	private Mono<String> webflux() {
		logger.info("start");
		Mono<String> result = Mono.fromSupplier(() -> job());
		logger.info("done");
		return result;
	}
}

			]]>
		</programlisting>
	</section>
	<section>
		<title>实验结果</title>
		<screen>
			<![CDATA[
neo@MacBook-Pro-Neo ~> time curl http://localhost:8080/SpringMVC
Hellowoard!!!
________________________________________________________
Executed in    5.02 secs      fish           external
   usr time    4.98 millis  242.00 micros    4.74 millis
   sys time    5.48 millis  993.00 micros    4.49 millis			
			]]>
		</screen>
		<screen>
			<![CDATA[
2023-02-24T14:13:07.063+08:00 TRACE 1552 --- [  XNIO-1 task-2] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to cn.netkiller.controller.WebFluxController#springmvc()
2023-02-24T14:13:07.077+08:00  INFO 1552 --- [  XNIO-1 task-2] c.n.controller.WebFluxController         : start
2023-02-24T14:13:12.082+08:00  INFO 1552 --- [  XNIO-1 task-2] c.n.controller.WebFluxController         : done			
			]]>
		</screen>
		<para>从省输出日志可以看到 start 2023-02-24T14:13:07, done 2023-02-24T14:13:12
			程序运行被阻塞了 5秒钟
		</para>
		<screen>
			<![CDATA[
neo@MacBook-Pro-Neo ~> time curl http://localhost:8080/WebFlux
Hellowoard!!!
________________________________________________________
Executed in    5.02 secs      fish           external
   usr time    5.19 millis  228.00 micros    4.96 millis
   sys time    6.05 millis  854.00 micros    5.20 millis	
			]]>
		</screen>
		<screen>
			<![CDATA[
2023-02-24T14:14:54.720+08:00 TRACE 1583 --- [  XNIO-1 task-2] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to cn.netkiller.controller.WebFluxController#webflux()
2023-02-24T14:14:54.729+08:00  INFO 1583 --- [  XNIO-1 task-2] c.n.controller.WebFluxController         : start
2023-02-24T14:14:54.731+08:00  INFO 1583 --- [  XNIO-1 task-2] c.n.controller.WebFluxController         : done
2023-02-24T14:14:59.753+08:00 TRACE 1583 --- [  XNIO-1 task-3] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to cn.netkiller.controller.WebFluxController#webflux()	
			]]>
		</screen>
		<para>再看 webflux 的表现，start 2023-02-24T14:14:54, done
			2023-02-24T14:14:54 执行时间不到一秒钟。
		</para>
	</section>
</section>
<section id="webflux.router">
	<title>WebFlux Router</title>
	<section id="router.component">
		<title>Component 原件</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.webflux.component;

import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;

import reactor.core.publisher.Mono;

@Component
public class HelloWorldHandler {

	public HelloWorldHandler() {
	}

	public Mono<ServerResponse> helloWorld(ServerRequest request) {
		return ServerResponse.ok().contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World!!!"));
	}
}

		]]>
		</programlisting>
	</section>
	<section id="router.config">
		<title>路由配置</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.webflux.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RequestPredicates;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerResponse;

import cn.netkiller.webflux.component.HelloWorldHandler;

@Configuration
public class WebFluxRouter {

	public WebFluxRouter() {
	}

	@Bean
	public RouterFunction<ServerResponse> routeHelloWorld(HelloWorldHandler helloWorldHandler) {

		return RouterFunctions.route(RequestPredicates.GET("/hello").and(RequestPredicates.accept(MediaType.TEXT_PLAIN)), helloWorldHandler::helloWorld);
	}
}
		
		]]>
		</programlisting>
	</section>

</section>
<section id="webflux.Thymeleaf">
	<title>Thymeleaf</title>
	<section>
		<title>模板引擎 Thymeleaf 依赖</title>
		<screen>
			<![CDATA[
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-thymeleaf</artifactId>
    </dependency>			
			]]>
		</screen>
	</section>
	<section>
		<title>application.properties 相关的配置</title>
		<screen>
			<![CDATA[
spring.thymeleaf.cache=true # Enable template caching.
spring.thymeleaf.check-template=true # Check that the template exists before rendering it.
spring.thymeleaf.check-template-location=true # Check that the templates location exists.
spring.thymeleaf.enabled=true # Enable Thymeleaf view resolution for Web frameworks.
spring.thymeleaf.encoding=UTF-8 # Template files encoding.
spring.thymeleaf.excluded-view-names= # Comma-separated list of view names that should be excluded from resolution.
spring.thymeleaf.mode=HTML5 # Template mode to be applied to templates. See also StandardTemplateModeHandlers.
spring.thymeleaf.prefix=classpath:/templates/ # Prefix that gets prepended to view names when building a URL.
spring.thymeleaf.reactive.max-chunk-size= # Maximum size of data buffers used for writing to the response, in bytes.
spring.thymeleaf.reactive.media-types= # Media types supported by the view technology.
spring.thymeleaf.servlet.content-type=text/html # Content-Type value written to HTTP responses.
spring.thymeleaf.suffix=.html # Suffix that gets appended to view names when building a URL.
spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain.
spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved.
			]]>
		</screen>
	</section>
	<section>
		<title>Webflux 控制器</title>
		<programlisting>
			<![CDATA[
	@GetMapping("/welcome")
    public Mono<String> hello(final Model model) {
        model.addAttribute("name", "Neo");
        model.addAttribute("city", "深圳");

        String path = "hello";
        return Mono.create(monoSink -> monoSink.success(path));
    }

    @GetMapping("/list")
    public String listPage(final Model model) {
        final Flux<City> citys = cityService.findAllCity();
        model.addAttribute("cityLists", citys);
        return "cityList";
    }			
			]]>
		</programlisting>
	</section>
	<section>
		<title>Tymeleaf 视图</title>
		<para>welcome.html</para>
		<programlisting>
			<![CDATA[
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>欢迎页面</title>
</head>

<body>

<h1 >你好，欢迎来自<p th:text="${city}"></p>的<p th:text="${name}"></p></h1>

</body>
</html>			
			]]>
		</programlisting>
		<para>cityList.html</para>
		<programlisting>
			<![CDATA[
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <title>城市列表</title>
</head>

<body>

<div>


    <table>
        <legend>
            <strong>城市列表</strong>
        </legend>
        <thead>
        <tr>
            <th>城市编号</th>
            <th>省份编号</th>
            <th>名称</th>
            <th>描述</th>
        </tr>
        </thead>
        <tbody>
        <tr th:each="city : ${cityLists}">
            <td th:text="${city.id}"></td>
            <td th:text="${city.provinceId}"></td>
            <td th:text="${city.name}"></td>
            <td th:text="${city.description}"></td>
        </tr>
        </tbody>
    </table>

</div>

</body>
</html>			
			]]>
		</programlisting>
	</section>

</section>
<section id="redis-reactive">
	<title>Webflux Redis</title>
	<section>
		<title>Maven Redis 依赖</title>
		<screen>
			<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis-reactive</artifactId>
		</dependency>
			]]>
		</screen>
	</section>
	<section>
		<title>Redis 配置</title>
		<screen>
			<![CDATA[
server:
  port: 8080
spring:
  application:
    name: webflux
  redis:
    host: 127.0.0.1
    port: 6379
    password: pwd2020
    timeout: 5000
    lettuce:
      pool:
        max-active: 200 
        max-idle: 20 
        min-idle: 5 
        max-wait: 1000 			
			]]>
		</screen>
	</section>
	<section>
		<title>Config</title>
		<programlisting>
			<![CDATA[
	@Bean
	public ReactiveRedisTemplate<String, String> reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
		ReactiveRedisTemplate<String, String> reactiveRedisTemplate = new ReactiveRedisTemplate<>(factory,RedisSerializationContext.string());
		return reactiveRedisTemplate;
	}			
			]]>
		</programlisting>
	</section>
	<section>
		<title>Service</title>
		<programlisting>
			<![CDATA[
@Service
public class RedisServiceImpl implements RedisService {

	@Autowired
	private ReactiveRedisTemplate<String, String> redisTemplate;
	
	@Override
	public Mono<String> get(String key) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.get(key);
	}

	@Override
	public Mono<String> set(String key,User user) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.getAndSet(key, JSON.toJSONString(user));
	}

	@Override
	public Mono<Boolean> delete(String key) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.delete(key);
	}

	@Override
	public Mono<String> update(String key,User user) {
		
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return operations.getAndSet(key, JSON.toJSONString(user));
	}

	@Override
	public Flux<String> all(String key) {
		ReactiveListOperations<String, String> operations = redisTemplate.opsForList();
		return operations.range(key, 0, -1);
	}


	@Override
	public Mono<Long> push(String key,List<String> list) {
		
		ReactiveListOperations<String, String> operations = redisTemplate.opsForList();
		return operations.leftPushAll(key, list);
	}
	
	@Override
	public Flux<String> find(String key) {
		ReactiveValueOperations<String, String> operations = redisTemplate.opsForValue();
		return redisTemplate.keys(key).flatMap(keyId ->operations.get(keyId));
	}
}			
			]]>
		</programlisting>
	</section>
	<section>
		<title></title>
		<programlisting>
			<![CDATA[
@RestController
@RequestMapping("/user")
public class UserController {
	
	public final static String USER_KEY="user";
	
	@Autowired
	private RedisService redisService;
	
	@GetMapping("/get/{key}")
	public Mono<String> getUserByKey(@PathVariable("id")String key){
		return redisService.get(key);
	}
	
	@GetMapping("/add")
	public Mono<String> add(User user){
		user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");

		System.out.println(JSON.toJSONString(user));
		return redisService.set("neo",user);		
	}
	
	@GetMapping("/addlist")
	public Mono<Long> addlist(){
		List<String> list=new ArrayList<String>();
		User user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");
		
		//添加第一条数据
		list.add(JSON.toJSONString(user));
		//添加第二条数据
		list.add(JSON.toJSONString(user));
		//添加第三条数据
		list.add(JSON.toJSONString(user));
		
		return redisService.addlist("list", list);
	}

	@GetMapping(value="/findAll",produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
	public Flux<String> findAll(){
		return redisService.all("list").delayElements(Duration.ofSeconds(2));
	}
	
	@GetMapping("/getUsers")
	public Flux<String> findUsers() {
		return redisService.find("*").delayElements(Duration.ofSeconds(2));
	}
}			
			]]>
		</programlisting>
	</section>
</section>
<section id="mongodb-reactive">
	<title>Webflux Mongdb</title>
	<section>
		<title>Maven 依赖</title>
		<screen>
			<![CDATA[
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
	</dependency>			
			]]>
		</screen>
	</section>
	<section>
		<title>Repository</title>
		<programlisting>
			<![CDATA[
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;

import cn.netkiller.entity.User;

public interface UserRepository extends ReactiveMongoRepository<User, Long>{

}
			]]>
		</programlisting>
	</section>
	<section>
		<title>Service</title>
		<screen>
			<![CDATA[
@Service
public class MongoServiceImpl implements MongoService {
	
	@Autowired
	private UserRepository userRepository;
	
	@Override
	public Mono<User> getById(Long id) {
		return userRepository.findById(id);
	}

	@Override
	public Mono<User> addUser(User user) {
		return userRepository.save(user);
	}

	@Override
	public Mono<Boolean> deleteById(Long id) {
		 userRepository.deleteById(id);
		 return Mono.create(userMonoSink -> userMonoSink.success());
	}

	@Override
	public Mono<User> updateById(User user) {
		return userRepository.save(user);
	}

	@Override
	public Flux<User> findAllUser() {
		return userRepository.findAll();
	}
}			
			]]>
		</screen>
	</section>
	<section>
		<title>控制器</title>
		<programlisting>
			<![CDATA[
@RestController
@RequestMapping("/usermg")
public class UserMongoController {
	
	@Autowired
	private MongoService mongoService;

	@GetMapping("/add")
	public Mono<User> add(User user) {
		user = new User();
		User user = new User();
		user.setAccount("neo");
		user.setPassword("123456");
		user.setNickname("netkiller");
		user.setEmail("netkiller@msn.com");
		user.setPhone("");
		user.setGender(true);
		user.setBirthday("1980-01-30");
		user.setProvince("广东省");
		user.setCity("深圳市");
		user.setCounty("南山区");
		user.setAddress("");
		user.setState("Enabled");
		
	
		System.out.println(JSON.toJSONString(user));
		return mongoService.addUser(user);

	}
	
	/**
	 *	注意这里 produces = MediaType.APPLICATION_STREAM_JSON_VALUE 必须这样设置
	 */
	@GetMapping(value="/findAll",produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
	public Flux<User> findAll(){
		return mongoService.findAllUser().delayElements(Duration.ofSeconds(1));
	}
}
			]]>
		</programlisting>
		<para>produces
			如果不是application/stream+json则调用端无法滚动得到结果，将一直阻塞等待数据流结束或超时。
		</para>
	</section>
</section>
<section id="webflux.mono">
	<title>Mono</title>
	<para>Mono(返回0或1个元素)/Flux(返回0-n个元素)</para>
	<section>
		<title>Mono.just()/Mono.justOrEmpty()</title>
		<programlisting>
		<![CDATA[
Mono.justOrEmpty(Optional.of("Netkiller")).subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>

	<section>
		<title>MonoSink 创建 Mono</title>
		<programlisting>
		<![CDATA[
Mono.create(sink -> sink.success("Netkiller")).subscribe(System.out::println);	
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
    @GetMapping("mono")
    public Mono<Object> mono() {
        return Mono.create(monoSink -> {
                    log.info("创建 Mono");
                    monoSink.success("hello webflux");
                })
                .doOnSubscribe(subscription -> { //当订阅者去订阅发布者的时候，该方法会调用
                    log.info("doOnSubscribe={}", subscription);
                }).doOnNext(next -> { //当订阅者收到数据时，改方法会调用
                    log.info("doOnNext={}", next);
                });
    }
		]]>
		</programlisting>
	</section>
	<section>
		<title>Supplier 创建 Mono</title>
		<para>从 Supplier 创建 Mono</para>
		<programlisting>
		<![CDATA[
    @GetMapping("/get")
    private Mono<String> get() {
        log.info("start");
        Mono<String> result = Mono.fromSupplier(() -> {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
            }
            return "netkiller";
        });
        log.info("end");
        return result;
    }		
		]]>
		</programlisting>
	</section>


	<section>
		<title>then()</title>
		<programlisting>
		<![CDATA[
Mono.empty()
    .then()
    .doOnSuccess(i -> System.out.println("On success: " + i))
    .doOnError(i -> System.out.println("On error: " + i))
    .block();

Mono.empty()
    .then(Mono.just("Good bye"))
    .doOnSuccess(i -> System.out.println("On success: " + i))
    .doOnError(i -> System.out.println("On error: " + i))
    .block();

Mono.just("Hello World")
    .then(Mono.just("Good bye"))
    .doOnSuccess(i -> System.out.println("On success: " + i))
    .doOnError(i -> System.out.println("On error: " + i))
    .block();

Mono.error(new RuntimeException("Something wrong"))
    .then(Mono.just("Good bye"))
    .doOnSuccess(i -> System.out.println("On success: " + i))
    .doOnError(i -> System.out.println("On error: " + i))
    .block();

Mono.error(new RuntimeException("Something wrong"))
    .then(Mono.error(new RuntimeException("Something very wrong")))
    .doOnSuccess(i -> System.out.println("On success: " + i))
    .doOnError(i -> System.out.println("On error: " + i))
    .block();
		]]>
		</programlisting>
	</section>
	<section>
		<title>异常处理</title>
		<programlisting>
		<![CDATA[
Mono.just("Netkiller")
        .concatWith(Mono.error(new IllegalStateException()))
        .subscribe(System.out::println, System.err::println);
		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
Mono.just("Netkiller")
        .concatWith(Mono.error(new IllegalStateException()))
        .onErrorReturn("defaultError")
        .subscribe(System.out::println);		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
Mono.just("Netkiller")
         .concatWith(Mono.error(new IllegalStateException()))
         .switchOnError(Mono.just("defaultError"))
         .subscribe(System.out::println);
		
		]]>
		</programlisting>
	</section>
	<section>
		<title>同步阻塞等待结果</title>
		<programlisting>
		<![CDATA[
        Mono.just("Hello World")
                .doOnNext(i -> System.out.println("On next: " + i))
                .doOnSuccess(i -> System.out.println("On success: " + i))
                .doOnError(i -> System.out.println("On error: " + i))
                .block();	
                
		Mono.empty()
		    .doOnNext(i -> System.out.println("On next: " + i))
		    .doOnSuccess(i -> System.out.println("On success: " + i))
		    .doOnError(i -> System.out.println("On error: " + i))
		    .block();

		Mono.just("Hello World")
		    .mapNotNull(s -> null)
		    .doOnNext(i -> System.out.println("On next: " + i))
		    .doOnSuccess(i -> System.out.println("On success: " + i))
		    .doOnError(i -> System.out.println("On error: " + i))
		    .block();       
				    
		Mono.error(new RuntimeException("Something wrong"))
		    .doOnNext(i -> System.out.println("On next: " + i))
		    .doOnSuccess(i -> System.out.println("On success: " + i))
		    .doOnError(i -> System.out.println("On error: " + i))
		    .block();
    
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
        Mono.delay(Duration.ofMillis(10)).map(d -> {
            System.out.println(d);
            return d;
        }).block();		
        Mono.delay(Duration.ofMillis(10)).map(d -> {
            System.out.println(d);
            return d;
        }).subscribe(System.out::println);        
		]]>
		</programlisting>

	</section>
</section>
<section id="webflux.flux">
	<title>Flux 返回多条数据</title>

	<section>
		<title>FluxSink 创建异步 Flux</title>
		<programlisting>
		<![CDATA[
        Flux<String> flux = Flux.create(sink -> {
            sink.next("Neo");
            sink.next("netkiller");
            sink.complete();
        });
        flux.subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>
	<section>
		<title>SynchronousSink 创建同步 Flux</title>
		<programlisting>
		<![CDATA[
        Flux<String> generate = Flux.generate(synchronousSink -> {
            synchronousSink.next("Neo");
            synchronousSink.complete();
        });
        generate.subscribe(System.out::println);		
		]]>
		</programlisting>
		<para>多个值</para>
		<programlisting>
		<![CDATA[
final Random random = new Random();
Flux.generate(ArrayList::new, (list, sink) -> {
    int value = random.nextInt(100);
    list.add(value);
    sink.next(value);
    if (list.size() == 10) {
        sink.complete();
    }
    return list;
}).subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>
	<section>
		<title>just()</title>
		<programlisting>
		<![CDATA[
//单个元素
Flux.just("just").subscribe(System.out::println);
//多个元素
Flux.just("just", "just1", "just2").subscribe(System.out::println);	
		]]>
		</programlisting>
	</section>
	<section>
		<title>从 Flux/Mono 创建 Flux</title>
		<programlisting>
		<![CDATA[
//Flux->Flux
Flux.from(Flux.just("just", "just1", "just2")).subscribe(System.out::println);
//Mono->Mono
Flux.from(Mono.just("just")).subscribe(System.out::println);	
		]]>
		</programlisting>
	</section>
	<section>
		<title>消息订阅</title>

		<programlisting>
		<![CDATA[
Flux.just("Netkiller1", "Netkiller2", "Netkiller3")
        .subscribe(data -> System.out.println("onNext:" + data), err -> {
        }, () -> System.out.println("onComplete"));		
		]]>
		</programlisting>
		<para>多个订阅者</para>
		<programlisting>
		<![CDATA[
    List<String> list = new ArrayList<>();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");
        Flux<String> flux = Flux.fromIterable(list);
        flux.subscribe(System.out::println);
        flux.subscribe(System.out::println);
        flux.subscribe(System.out::println);
		]]>
		</programlisting>
		<para>手动控制</para>
		<programlisting>
		<![CDATA[
	Flux<String> flux = Flux.fromIterable(list);
        ConnectableFlux<String> con = flux.publish();
        con.subscribe(System.out::println);
        con.subscribe(System.out::println);
        con.subscribe(System.out::println);
        // 手动的开启消费数据
        con.connect();		
		]]>
		</programlisting>
	</section>
	<section>
		<title>从 Flux/Mono 创建 Flux</title>
		<programlisting>
		<![CDATA[
Flux.fromArray(new String[] { "arr", "arr", "arr", "arr" }).subscribe(System.out::println);	
		]]>
		</programlisting>
	</section>
	<section>
		<title>从 Iterable 创建 Flux</title>
		<programlisting>
		<![CDATA[
Set<String> v = new HashSet<>();
v.add("1");
v.add("2");
v.add("3");
Flux.fromIterable(() -> v.iterator()).subscribe(System.out::println);
		]]>
		</programlisting>
		<para>autoConnect(5) 表示如果订阅者达到5个 就自动开启</para>
		<programlisting>
		<![CDATA[
        Flux<String> auto = flux.publish().autoConnect(5);
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);		
		]]>
		</programlisting>
		<para>停止消费策略</para>
		<programlisting>
		<![CDATA[
		// 如果订阅者少于三个就会停止消费数据，直到订阅者达到三个为止
        Flux<String> auto = flux.publish().refCount(3);
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);

        Thread.sleep(1000L);

      	// 如果订阅者少于三个且超过十秒没有新的订阅才会停止消费数据
        Flux<String> auto = flux.publish().refCount(3,Duration.ofSeconds(10));
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);
        auto.subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>


	<section>
		<title>从 Stream 创建 Flux</title>

		<para>从 Stream 返回 Flux</para>
		<programlisting>
		<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<String> getWords() {
        Stream<String> items = Arrays.asList("alpha", "bravo", "charlie").stream();
        return Flux.fromStream(items);
    }		
		]]>
		</programlisting>
	</section>
	<section>
		<title>defer()</title>
		<programlisting>
		<![CDATA[
Flux.defer(() -> Flux.just("just", "just1", "just2")).subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>
	<section id="Flux.interval">
		<title>Flux.interval()</title>
		<programlisting>
		<![CDATA[
Flux.interval(Duration.of(500, ChronoUnit.MILLIS)).subscribe(System.out::println);	
Flux.interval(Duration.ofSeconds(2), Duration.ofMillis(200)).subscribe(System.out::println);

Flux.intervalMillis(1000).subscribe(System.out::println);
		]]>
		</programlisting>
	</section>
	<section>
		<title>Flux.empty()</title>
		<programlisting>
		<![CDATA[
Flux.empty().subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>
	<section>
		<title>Flux.error()</title>
		<programlisting>
		<![CDATA[
Flux.error(new RuntimeException()).subscribe(System.out::println);
		]]>
		</programlisting>
	</section>
	<section>
		<title>Flux.never()</title>
		<programlisting>
		<![CDATA[
Flux.never().subscribe(System.out::println);
		]]>
		</programlisting>
	</section>
	<section>
		<title>Flux.range()</title>
		<programlisting>
		<![CDATA[
Flux.range(0, 100).subscribe(System.out::println);
		]]>
		</programlisting>
	</section>
	<section>
		<title>返回数据</title>
		<para>返回 List</para>
		<programlisting>
		<![CDATA[
    @GetMapping("flux")
    public Flux<Picture> flux() {
        List<Picture> list = new ArrayList<Picture>();
        IntStream.range(1, 10).forEach(i -> {
            Picture picture = new Picture();
            picture.setId(Long.valueOf(i));
            picture.setImage("https://www.netkiller.cn/images/" + i + ".png");
            list.add(picture);
        });
        return Flux.fromIterable(list);
    }
		]]>
		</programlisting>
		<para>返回 Map</para>
		<programlisting>
		<![CDATA[
    @GetMapping("map")
    public Flux<Map.Entry<String, String>> map() {
        Map<String, String> map = new HashMap<>();
        IntStream.range(1, 10).forEach(i -> {
            map.put("key" + i, "value" + i);
        });

        return Flux.fromIterable(map.entrySet());
    }
		]]>
		</programlisting>
	</section>
	<section>
		<title>持续更新 Flux</title>

		<programlisting>
	<![CDATA[
		AtomicReference<FluxSink<String>> fluxSink = new AtomicReference<FluxSink<String>>();

        Flux<String> response = Flux.create(sink -> {
            fluxSink.set(sink);
        });
        response.subscribe(System.out::println);
        //下发元素
        fluxSink.get().next("Neo");
        fluxSink.get().next("Netkiller");
	]]>
		</programlisting>

		<programlisting>
		<![CDATA[
	Consumer<String> producer;

    @Test
    public void testFluxCreate() {
        Flux.create(sink -> {
            producer = nextData -> sink.next(nextData);
        }).subscribe(e -> System.out.println(e));

        //do something

        //下发元素
        producer.accept("Neo");

        producer.accept("Netkiller");

    }

	FluxSink<String> outSink;
    @Test
    public void testFluxCreate() {
        Flux<String> f = Flux.create(sink -> {
            outSink = sink;
        });
        f.subscribe(e -> System.out.println(e))
        //do something

        //下发元素
        outSink.next("Neo");

        outSink.next("Netkiller");
    }
		
		]]>
		</programlisting>
		<programlisting>
	<![CDATA[
interface MyEventListener<T> {
    void onDataChunk(List<T> chunk);
    void processComplete();
}


Flux<String> bridge = Flux.create(sink -> {
    myEventProcessor.register( 
      new MyEventListener<String>() { 

        public void onDataChunk(List<String> chunk) {
          for(String s : chunk) {
            sink.next(s); 
          }
        }
        public void processComplete() {
            sink.complete(); 
        }
    });
});	
	]]>
		</programlisting>
	</section>
	<section>
		<title>map(), flatMap()</title>
		<programlisting>
		<![CDATA[
        Flux.just(1, 2, 3, 4)
                .log()
                .map(i -> {
                    return i * 2;
                })
                .subscribe(System.out::println);		
		]]>
		</programlisting>
		<programlisting>
		<![CDATA[
        Flux.just(1, 2, 3, 4)
                .log()
                .flatMap(e -> {
                    return Flux.just(e * 2).delayElements(Duration.ofSeconds(1));
                })
                .subscribe(System.out::println);		
		]]>
		</programlisting>


	</section>
	<section>
		<title>过滤</title>
		<programlisting>
		<![CDATA[
        Flux<Integer> flux = Flux.just(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        flux.map(num -> num * 2) // 将每个元素乘以2
                .filter(num -> num % 2 == 0) // 过滤掉奇数
                .subscribe(System.out::println);		
		]]>
		</programlisting>
	</section>
	<section>
		<title>触发操作</title>
		<para>doOnComplete 完成时执行</para>
		<programlisting>
	<![CDATA[
AtomicBoolean onComplete = new AtomicBoolean();
        Flux<Integer> flux = Flux.just(1, 2, 3);
        flux.log()
                .doOnComplete(() -> onComplete.set(true))
                .doOnComplete(() -> {
                    System.out.println("OK");
                })
                .subscribe(System.out::println);
        System.out.println(onComplete.get());	
	]]>
		</programlisting>
	</section>
</section>

<section id="webflux.sse">
	<title>SSE</title>

	<section>
		<title>一次性事件</title>
		<programlisting>
			<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> createConnectionAndSendEvents() {
        return Flux.just("Alpha", "Omega");
    }			
			]]>
		</programlisting>
		<para>curl 访问 SSE 需要设置HTTP头 -H "Accept: text/event-stream" </para>
		<screen>
			<![CDATA[
neo@MacBook-Pro-M2 ~ % curl -H "Accept: text/event-stream" -X 'GET' 'http://localhost:8080/mock/sse'
data:Alpha

data:Omega			
			]]>
		</screen>
		<tip>Safari 浏览器不支持 SSE推送，微软的 Egde 支持。</tip>
	</section>
	<section>
		<title>从 Steam 返回数据</title>
		<programlisting>
		<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<String> getWords() {
        Stream<String> items = Arrays.asList("alpha", "bravo", "charlie").stream();
        return Flux.fromStream(items);
    }		
		]]>
		</programlisting>
	</section>
	<section>
		<title>周期性事件</title>
		<para>每间隔一秒发送一次数据</para>
		<programlisting>
			<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<String> getWords() {
        String[] WORDS = "The quick brown fox jumps over the lazy dog.".split(" ");
        return Flux
                .zip(Flux.just(WORDS), Flux.interval(Duration.ofSeconds(1)))
                .map(Tuple2::getT1);
    }
    
	@GetMapping("/random")
	public Flux<ServerSentEvent<Integer>> randomNumbers() {
		return Flux.interval(Duration.ofSeconds(1)).map(seq -> Tuples.of(seq, ThreadLocalRandom.current().nextInt())).map(data -> ServerSentEvent.<Integer>builder().event("random").id(Long.toString(data.getT1())).data(data.getT2()).build());
	}    
	
	@GetMapping(path = "/stream-flux", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux<String> streamFlux() {
	    return Flux.interval(Duration.ofSeconds(1))
	      .map(sequence -> "Flux - " + LocalTime.now().toString());
	}	
			]]>
		</programlisting>
	</section>
	<section>
		<title>返回 ServerSentEvent 数据结构</title>
		<programlisting>
		<![CDATA[
    @GetMapping(path = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    private Flux<ServerSentEvent<Object>> getWords() {
        AtomicInteger seq = new AtomicInteger(1);
        return Flux.just("你好", "我是 Neo", "我的昵称是 netkiller")
                .map(data -> ServerSentEvent.builder()
                        .event("hello")
                        .id(String.valueOf(seq.getAndIncrement()))
                        .data(data)
                        .comment("测试数据")
                        .build());
    }		
		]]>
		</programlisting>
		<para>演示结果</para>
		<screen>
		<![CDATA[
neo@MacBook-Pro-M2 ~> curl http://localhost:8080/test/sse
id:1
event:hello
data:你好
:测试数据

id:2
event:hello
data:我是 Neo
:测试数据

id:3
event:hello
data:我的昵称是 netkiller
:测试数据
		]]>
		</screen>
	</section>
	<section>
		<title>SSE 完整的例子</title>
		<programlisting>
		<![CDATA[
package cn.netkiller.webflux.controller;

import java.time.Duration;
import java.util.concurrent.ThreadLocalRandom;

import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerSentEvent;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import reactor.core.publisher.Flux;
import reactor.util.function.Tuples;

@RestController
@RequestMapping("/sse")
public class SseController {
	private int count_down = 10;

	public SseController() {

	}

	@GetMapping(value = "/launch", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	public Flux<ServerSentEvent<Object>> countDown() {

		return Flux.interval(Duration.ofSeconds(1)).map(seq -> Tuples.of(seq, getCountDownSec())).map(data -> ServerSentEvent.<Object>builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}

	private String getCountDownSec() {
		if (count_down > 0) {
			count_down--;
			return "倒计时：" + count_down;
		}
		return "发射";
	}



	@GetMapping("/range")
	public Flux<Object> range() {
		return Flux.range(10, 1).map(seq -> Tuples.of(seq, getCountDownSec())).map(data -> ServerSentEvent.<Object>builder().event("launch").id(Long.toString(data.getT1())).data(data.getT2().toString()).build());
	}
	
	// WebFlux 服务器推送(SSE - >Server Send Event)
	@GetMapping(value = "/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
	private Flux<String> flux() {
		Flux<String> result = Flux.fromStream(IntStream.range(1, 10).mapToObj(i -> {
			try {
				TimeUnit.SECONDS.sleep(1);
			} catch (InterruptedException e) {
			}
			logger.info("sse " + i);
			return "flux data -- " + i;
		}));
		return result;
	}
}
		
		]]>
		</programlisting>
		<para>运行结果</para>
		<screen>
		<![CDATA[
id:0
event:launch
data:倒计时：9

id:1
event:launch
data:倒计时：8

id:2
event:launch
data:倒计时：7

id:3
event:launch
data:倒计时：6

id:4
event:launch
data:倒计时：5

id:5
event:launch
data:倒计时：4

id:6
event:launch
data:倒计时：3

id:7
event:launch
data:倒计时：2

id:8
event:launch
data:倒计时：1

id:9
event:launch
data:倒计时：0

id:10
event:launch
data:发射
		
		]]>
		</screen>
	</section>
	<section>
		<title>SSE Client 订阅实例</title>
		<programlisting>
			<![CDATA[
 	@GetMapping("/server")
    public Flux<ServerSentEvent<String>> streamEvents() {
        return Flux.interval(Duration.ofSeconds(1))
                .map(sequence -> ServerSentEvent.<String>builder()
                        .id(String.valueOf(sequence))
                        .event("test-event")
                        .data("LocalTime: " + LocalTime.now())
                        .build());
    }

    @GetMapping("/client")
    public void consumeServerSentEvent() {
        WebClient client = WebClient.create("http://localhost:8080");
        ParameterizedTypeReference<ServerSentEvent<String>> type
                = new ParameterizedTypeReference<ServerSentEvent<String>>() {
        };

        Flux<ServerSentEvent<String>> eventStream = client.get()
                .uri("mock/server")
                .retrieve()
                .bodyToFlux(type);

        eventStream.subscribe(
                content -> log.info("Time: {} - event: name[{}], id [{}], content[{}] ",
                        LocalTime.now(), content.event(), content.id(), content.data()),
                error -> log.error("Error receiving SSE: {}", error),
                () -> log.info("Completed!!!"));
    }
			]]>
		</programlisting>
	</section>
</section>
<section>
	<title>并发</title>
	<programlisting>
	<![CDATA[
        Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
                .publishOn(Schedulers.parallel())
                .flatMap(integer -> {
                    System.out.println("val:" + integer + ", thread:" + Thread.currentThread().getId());
                    return Mono.just(integer);
                }, 5)
                .repeat()
                .subscribe();	
	]]>
	</programlisting>
	<programlisting>
	<![CDATA[
    @GetMapping(value = "parallel", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<Integer> parallel() {
        return Flux.just(1, 2, 3, 4, 5, 6, 7, 8)
                .publishOn(Schedulers.parallel())
                .flatMap(integer -> {
                    log.info("val:" + integer + ", thread:" + Thread.currentThread().getId());
                    return Mono.just(integer);
                }, 2).repeat(10L);

    }
	]]>
	</programlisting>
	<programlisting>
	<![CDATA[
Flux.just(1,2,3,4,5,6,7,8)
    .parallel(2) // mention number of threads
    .runOn(Schedulers.parallel())
    .map(integer -> {
             System.out.println("val:" + integer + ", thread:" + Thread.currentThread().getId()); 
             return integer;
        })   
    .subscribe();	
	]]>
	</programlisting>
	<programlisting>
	<![CDATA[
package cn.netkiller.test;

import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;


public class Test {
    public static void main(String[] args) {

        Flux.create(sink -> {
                    sink.next(Thread.currentThread().getName());
                    sink.complete();
                }).publishOn(Schedulers.single())
                .map(x -> String.format("[%s] %s", Thread.currentThread().getName(), x))
                .publishOn(Schedulers.immediate())
                .map(x -> String.format("[%s] %s", Thread.currentThread().getName(), x))
                .subscribeOn(Schedulers.parallel())
                .toStream()
                .forEach(System.out::println);

    }
}
	]]>
	</programlisting>
	<programlisting>
	<![CDATA[
Flux.just(1,2,3,4,5,6,7,8)
        .publishOn(Schedulers.parallel()) // <- Each flux can be published in a different thread
        .flatMap(integer -> {
            return Mono.fromCallable(() -> {
                 System.out.println("val:" + integer + ", thread:" + Thread.currentThread().getId()); 
                 return integer;
            }).publishOn(Schedulers.parallel()); // <- Each Mono processing every integer can be processed in a different thread
         })
        .repeat()
        .subscribe();	
	]]>
	</programlisting>
</section>
<section id="ConnectableFlux">
	<title>ConnectableFlux</title>
	<programlisting>
	<![CDATA[
        AtomicBoolean onComplete = new AtomicBoolean();
        ConnectableFlux<Integer> f = Flux.just(1)
                .doOnComplete(() -> onComplete.set(true))
                .publish();	
	]]>
	</programlisting>
</section>
