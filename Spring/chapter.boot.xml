<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="boot" ?>
	<title>Spring Boot</title>
	<para>注意以下使用 Spring boot 2.1.3</para>
	&section.boot.quickstart.xml;
	<section id="spring-boot-maven-plugin">
		<title>Springboot with Maven</title>
		<para>spring-boot-maven-plugin 插件</para>
		<section>
			<title>resource</title>
			<para>将 resource 添加应用程序</para>
			<screen>
			<![CDATA[
<build>
    <resources>
        <resource>
            <directory>src/main/java/resources</directory>
            <filtering>true</filtering>
            <excludes>
                <exclude>*.jks</exclude>
            </excludes>
        </resource>
    </resources>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <addResources>true</addResources>
            </configuration>
        </plugin>
    </plugins>
</build>		
			]]>
			</screen>
		</section>
		<section>
			<title>Spring Boot maven 插件 build-image</title>
			<para>Spring Boot 构建 Docker 镜像，你不需要写 Dockerfile，plugin 帮你完成。</para>
			<para>只需要简单的执行：</para>
			<screen>
			<![CDATA[
mvn spring-boot:build-image			
			]]>
			</screen>
			<para>执行完成后会看到成功提示信息：</para>
			<screen>
			<![CDATA[
[INFO] Successfully buit image 'docker.io/library/demo:0.0.1-SNAPSHOT'			
			]]>
			</screen>
			<para>运行容器测试：</para>
			<screen>
			<![CDATA[
docker run -p 8000:8080 -t demo:0.0.1-SNAPSHOT			
			]]>
			</screen>
			<para>注意：这里映射的本机端口是8000。</para>
			<screen>
			<![CDATA[
curl http://localhost:8000/
			]]>
			</screen>
		</section>
	</section>
	<section id="spring.run">
		<title>运行 Spring boot 项目</title>
		<section>
			<title>Maven run</title>
			<programlisting>
			<![CDATA[
$ mvn spring-boot:run
$ mvn -P prod spring-boot:run
			]]>
			</programlisting>
			<para>-P 指定 profile</para>
			<para>打包后，使用jar包运行</para>
			<programlisting>
			<![CDATA[
$ mvn verify
$ mvn package
$ java -jar target/api.netkiller.cn-0.0.1-SNAPSHOT.jar
			]]>
			</programlisting>
		</section>
		<section>
			<title>Linux systemd</title>
			<para>/etc/systemd/system/spring.service</para>
			<screen>
			<![CDATA[
####################################################
# Homepage: http://netkiller.github.io
# Author: netkiller<netkiller@msn.com>
# Script: https://github.com/oscm/shell
# Date: 2015-11-03
####################################################
[Unit]
Description=Spring Boot Application
After=network.target

[Service]
User=www
Group=www
Type=oneshot
WorkingDirectory=/www/netkiller.cn/api.netkiller.cn
ExecStart=/usr/bin/java -jar your_jar_file.jar --spring.config.location=appliction-production.properties --spring.profiles.active=profile
#ExecStop=pkill -9 -f  
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
			]]>
			</screen>
		</section>
		<section>
			<title>传统 init.d 脚本</title>
			<screen>
			<![CDATA[
#!/bin/bash
##############################################
# Author: netkiller<netkiller@msn.com>
# Homepage: http://www.netkiller.cn
# Date: 2017-02-08
# $Author$
# $Id$
##############################################
# chkconfig: 345 100 02
# description: Spring boot application
# processname: springbootd
# File : springbootd
##############################################
BASEDIR="/www/netkiller.cn/api.netkiller.cn"
JAVA_HOME=/srv/java
JAVA_OPTS="-server -Xms2048m -Xmx8192m -Djava.security.egd=file:/dev/./urandom"
PACKAGE="api.netkiller.cn-0.0.2-release.jar"
CONFIG="--spring.config.location=$BASEDIR/application.properties"
USER=www
##############################################
NAME=springbootd
PROG="$JAVA_HOME/bin/java $JAVA_OPTS -jar $BASEDIR/$PACKAGE $CONFIG"
LOGFILE=/var/tmp/$NAME.log
PIDFILE=/var/tmp/$NAME.pid
ACCESS_LOG=/var/tmp/$NAME.access.log
##############################################

function log(){
	echo "$(date -d "today" +"%Y-%m-%d %H:%M:%S") $1	$2" >> $LOGFILE
}

function start(){
	if [ -f "$PIDFILE" ]; then
		echo $PIDFILE
		exit 2
	fi

	su - $USER -c "$PROG & echo \$! > $PIDFILE"
	log info start
}
function stop(){
	[ -f $PIDFILE ] && kill `cat $PIDFILE` && rm -rf $PIDFILE
	log info stop
}
function status(){
	ps aux | grep $PACKAGE | grep -v grep | grep -v status
	log info status
}
function reset(){
	pkill -f $PACKAGE
  	[ -f $PIDFILE ] && rm -rf $PIDFILE
	log info reset
}

case "$1" in
	start)
		start
		;;
	stop)
		stop
		;;
	status)
		status
		;;
	restart)
		stop
		start
		;;
	log)
		tail -f $LOGFILE
		;;
	reset)
		reset
		;;
	*)
		echo $"Usage: $0 {start|stop|status|restart|log|reset}"
esac
exit $?

			]]>
			</screen>
		</section>
		<section id="war">
			<title>编译用于Tomcat的 War</title>
			<programlisting>
			<![CDATA[
package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.web.SpringBootServletInitializer;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@ComponentScan
@EnableAutoConfiguration
public class Application extends SpringBootServletInitializer {

    private static Class<Application> applicationClass = Application.class;
    
    public static void main(String[] args) {
        SpringApplication.run(applicationClass, args);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(applicationClass);
    }
}		
			]]>
			</programlisting>
		</section>

	</section>

	<section id="SpringApplication">
		<title>SpringApplication</title>
		<programlisting>
		<![CDATA[

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@ComponentScan({"cn.netkiller.controller"})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
		]]>
		</programlisting>

		<section id="SpringBootApplication">
			<title>@SpringBootApplication</title>
			<para>@SpringBootApplication 是 @Configuration, @EnableAutoConfiguration 跟 @ComponentScan 的集合。</para>
			<programlisting>
			<![CDATA[
@SpringBootApplication
			]]>
			</programlisting>
			<section>
				<title>排除 @EnableAutoConfiguration 加载项</title>
				<programlisting>
				<![CDATA[
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="EnableAutoConfiguration">
			<title>@EnableAutoConfiguration</title>
			<para>exclude 排除配置，下面例子是排除 DataSource配置</para>
			<programlisting>
			<![CDATA[
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
			]]>
			</programlisting>
		</section>
		<section id="@ComponentScan">
			<title>@ComponentScan</title>
			<para>@ComponentScan 注入会扫描 @Controller 与 @RestController</para>
			<programlisting>
			<![CDATA[
@ComponentScan
@ComponentScan({"cn.netkiller.controller"})
@ComponentScan({"cn.netkiller.controller", "cn.netkiller.rest"})
			]]>
			</programlisting>
		</section>
		<section id="@EntityScan">
			<title>@EntityScan 实体扫描</title>
			<programlisting>
			<![CDATA[
@EntityScan("common.domain")
			]]>
			</programlisting>
		</section>
		<section id="@EnableJpaRepositories">
			<title>@EnableJpaRepositories</title>
			<para>扫描 Jpa 仓库</para>
			<programlisting>
			<![CDATA[
@EnableJpaRepositories("common.domain")			
			]]>
			</programlisting>
		</section>
		<section id="CharacterEncodingFilter">
			<title>CharacterEncodingFilter</title>
			<programlisting>
			<![CDATA[
	public @Bean Filter characterEncodingFilter() {
		CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
		characterEncodingFilter.setEncoding("UTF-8");
		characterEncodingFilter.setForceEncoding(true);
		return characterEncodingFilter;
	}			
			]]>
			</programlisting>
		</section>
		<section id="banner">
			<title>隐藏 Banner</title>
			<para>隐藏 Spring Boot Banner</para>
			<screen>
				. ____ _ __ _ _
				/\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \
				( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
				\\/ ___)| |_)| | | | | || (_| | ) ) ) )
				' |____| .__|_| |_|_| |_\__, | / / / /
				=========|_|==============|___/=/_/_/_/
				:: Spring Boot :: (v2.3.1.RELEASE)
			</screen>
			<programlisting>
			<![CDATA[
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(Application.class);
    app.setShowBanner(false);
    app.run(args);
}
			]]>
			</programlisting>
		</section>

		<section id="scan">
			<title>实体与仓库扫描</title>
			<programlisting>
			<![CDATA[
@EntityScan(basePackages = { "cn.netkiller.model" }) 
@EnableJpaRepositories(basePackages = { "cn.netkiller.repository" })			
			]]>
			</programlisting>
		</section>
		<section id="beans">
			<title>列出 Beans</title>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import java.util.Arrays;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
@EnableMongoRepositories
@EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		//SpringApplication.run(Application.class, args);

		ApplicationContext ctx = SpringApplication.run(Application.class, args);

		System.out.println("Let's inspect the beans provided by Spring Boot:");

		String[] beanNames = ctx.getBeanDefinitionNames();
		Arrays.sort(beanNames);
		for (String beanName : beanNames) {
			System.out.println(beanName);
		}

	}
}
			]]>
			</programlisting>
		</section>
		<section id="spring.boot.ports">
			<title>Tomcat 端口</title>
			<programlisting>
		<![CDATA[
@Configuration
public class TomcatConfiguration implements EmbeddedServletContainerCustomizer {

	int ports[] = { 8080, 8081, 8082 };

	@Override
	public void customize(ConfigurableEmbeddedServletContainer configurableEmbeddedServletContainer) {

		if (ports != null) {
			// 判断如果是Tomcat才进行如下配置
			if (configurableEmbeddedServletContainer instanceof TomcatEmbeddedServletContainerFactory) {

				TomcatEmbeddedServletContainerFactory tomcat = (TomcatEmbeddedServletContainerFactory) configurableEmbeddedServletContainer;

				for (int port : ports) {
					// 一个Connecter监听一个端口,指定协议为HTTP/1.1
					Connector httpConnector = new Connector("HTTP/1.1");
					httpConnector.setPort(port);
					tomcat.addAdditionalTomcatConnectors(httpConnector);
				}

			}
		}
	}
}
		]]>
			</programlisting>
		</section>
	</section>
	
	&section.boot.properties.xml;
	&section.boot.logging.xml;

	<section id="https">
		<title>Spring boot with HTTP2 SSL</title>
		<section>
			<title>生成自签名证书</title>
			<programlisting>
			<![CDATA[
keytool -genkey -alias www.netkiller.cn -keyalg RSA -keystore /www/netkiller.cn/www.netkiller.cn.keystore
			]]>
			</programlisting>
			<para>导入证书（Windows）</para>
			<programlisting>
			<![CDATA[
keytool -selfcert -alias www.netkiller.cn -keystore www.netkiller.cn.keystore
keytool -export -alias www.netkiller.cn -keystore www.netkiller.cn.keystore -storepass passw0rd -rfc -file www.netkiller.cn.cer
			]]>
			</programlisting>
			<para>导入证书（JVM）</para>
			<programlisting>
			<![CDATA[
keytool -importcert -alias www.netkiller.cn -file www.netkiller.cn.cer -keystore /srv/java/jre/lib/security/cacerts
			]]>
			</programlisting>
		</section>
		<section>
			<title>application.properties 配置文件</title>
			<para>配置Tomcat HTTPS 端口 8443（由于JVM不能fork和setuid，所以无法向nginx,apache httpd 那样设置 80 端口，除非你使用root用户运行，但这样做是不安全的。）</para>
			<programlisting>
			<![CDATA[
server.port=8443
server.ssl.enabled=true
server.ssl.key-store=/www/netkiller.cn/www.netkiller.cn.keystore
server.ssl.key-store-password=passw0rd
server.ssl.key-store-type=JKS
server.ssl.key-alias=www.netkiller.cn
			]]>
			</programlisting>
			<para>keystore 文件可以放到 classpath 中，首先将证书文件放到 src/main/resources 目录中，然后配置 application.properties 如下：</para>
			<programlisting>
				server.port=8443
				server.ssl.enabled=true
				server.ssl.key-store=classpath:www.netkiller.cn.keystore
				server.ssl.key-store-password=123456
				server.ssl.key-store-type=JKS
				server.ssl.key-alias=www.netkiller.cn
			</programlisting>
		</section>
		<section>
			<title>启动 Spring boot</title>
			<screen>
			<![CDATA[
/srv/java/bin/java -server -Xms2048m -Xmx8192m -Djava.security.egd=file:/dev/./urandom -jar /www/netkiller.cn/www.netkiller.cn/www.netkiller.cn-0.0.1.war
			]]>
			</screen>
		</section>
		<section>
			<title>restTemplate 调用实例</title>
			<programlisting>
			<![CDATA[
String url = "https://www.netkiller.cn:8443/public/test/version.json";
ResponseEntity<RestResponse<String>> result = restTemplate.exchange(url, HttpMethod.GET, null, new ParameterizedTypeReference<RestResponse<String>>() {});
			]]>
			</programlisting>
		</section>
		<section>
			<title>HTTP2</title>
			<para>启用 HTTP2 必须使用 Tomcat 9 以上， Springboot 2.1</para>
			<para>创建证书</para>
			<screen>
			<![CDATA[
keytool -genkey -alias localhost -storetype PKCS12 -keyalg RSA -keysize 2048 -keystore keystore.p12 -dname "CN=localhost, OU=netkiller, O=netkiller.cn, L=Guangdong, ST=Shenzhen, C=CN"
			]]>
			</screen>
			<para>配置启用 http2</para>
			<screen>
			<![CDATA[
server:
  port: 8443
  servlet:
    context-path: /
  ssl:
    enabled: true
    key-store: classpath:ssl/keystore.p12
    key-store-type: PKCS12
    key-store-password: 123456
  http2:
    enabled: true			
			]]>
			</screen>
			<para>我的配置</para>
			<screen>
			<![CDATA[
spring.application.name=web
server.port=8443
#server.servlet.context-path=/
server.ssl.enabled: true
server.ssl.key-store: classpath:keystore.p12
server.ssl.key-store-type: PKCS12
server.ssl.key-store-password: 123456
server.http2.enabled: true
			]]>
			</screen>
			<para>使用 curl 访问可以看到 HTTP/2 字样，表示成功</para>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~ % curl -i -k https://localhost:8443/ping
HTTP/2 200 
content-type: text/plain;charset=UTF-8
content-length: 4
date: Tue, 09 Apr 2019 08:41:29 GMT

Pong%    			
			]]>
			</screen>
		</section>
	</section>
	<section id="jetty">
		<title>Spring boot with Jetty</title>
		<para>使用 Jetty 替代 Tomcat</para>
		<screen>
		<![CDATA[
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!-- Exclude the Tomcat dependency -->
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!-- Use Jetty instead -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>		
		]]>
		</screen>
	</section>
	<section id="ViewResolver">
		<title>Spring boot with Webpage</title>
		<subtitle> ViewResolver </subtitle>
		<section>
			<title>Maven</title>
			<screen>
			<![CDATA[
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
		</dependency>
			]]>
			</screen>
		</section>
		<section>
			<title>application.properties</title>
			<programlisting>
				spring.mvc.view.prefix=/WEB-INF/jsp/
				spring.mvc.view.suffix=.jsp
			</programlisting>
		</section>
		<section>
			<title>Application</title>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>IndexController</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.web;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class IndexController {

	@RequestMapping("/welcome")
	@ResponseBody
	public String welcome() {
		String message = "Welcome";
		return message;
	}
	
	@RequestMapping("/index")
	public ModelAndView index() {
		String message = "Helloworld";
		return new ModelAndView("index").addObject("message", message);
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>src/main/webapp/WEB-INF/jsp/index.jsp</title>
			<programlisting>
			<![CDATA[
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Home</title>
</head>
<body>
${message}
</body>
</html>
			]]>
			</programlisting>
		</section>
		<section>
			<title>集成模板引擎</title>
			<para>如果你需要使用其他模板引擎可以采用 Bean 注解方式。</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
public class WebMvcConfig extends WebMvcConfigurerAdapter {

	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}

	@Bean
	public InternalResourceViewResolver viewResolver() {
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix("WEB-INF/jsp/");
		resolver.setSuffix(".jsp");
		return resolver;
	}

}
			]]>
			</programlisting>
		</section>

	</section>
	<section id="velocity">
		<title>Spring boot with Velocity template</title>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-velocity</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.velocity</groupId>
			<artifactId>velocity</artifactId>
		</dependency>			
			]]>
			</programlisting>
			<example>
				<title>Spring boot with Velocity template (pom.xml)</title>
				<programlisting>
				<![CDATA[
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>netkiller.cn</groupId>
	<artifactId>api.netkiller.cn</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>api.netkiller.cn</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-mongodb</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-oracle</artifactId>
			<version>1.0.0.RELEASE</version>
		</dependency>

		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<!-- <version>12.1.0.1</version> -->
			<version>11.2.0.3</version>
			<scope>system</scope>
			<systemPath>${basedir}/lib/ojdbc6.jar</systemPath>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-velocity</artifactId>
		</dependency>
		<dependency>
			<groupId>org.apache.velocity</groupId>
			<artifactId>velocity</artifactId>
		</dependency>
		<dependency>
			<groupId>com.google.code.gson</groupId>
			<artifactId>gson</artifactId>
			<scope>compile</scope>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<sourceDirectory>src</sourceDirectory>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.3</version>
				<configuration>
					<source />
					<target />
				</configuration>
			</plugin>
			<plugin>
				<artifactId>maven-war-plugin</artifactId>
				<version>2.6</version>
				<configuration>
					<warSourceDirectory>WebContent</warSourceDirectory>
					<failOnMissingWebXml>false</failOnMissingWebXml>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
				]]>
				</programlisting>
			</example>
		</section>
		<section>
			<title>Resource</title>
			<para>src/main/resources/application.properties</para>
			<programlisting>
			<![CDATA[
spring.velocity.resourceLoaderPath=classpath:/templates/
spring.velocity.prefix=
spring.velocity.suffix=.vm
spring.velocity.cache=false
spring.velocity.check-template-location=true
spring.velocity.content-type=text/html
spring.velocity.charset=UTF-8
spring.velocity.properties.input.encoding=UTF-8
spring.velocity.properties.output.encoding=UTF-8
			]]>
			</programlisting>
			<para>src/main/resources/templates/email.vm</para>
			<programlisting>
			<![CDATA[
<html>
<body>
    <h3>${title}!</h3>
    <p>${body}</p>
</body>
</html>
			]]>
			</programlisting>
		</section>
		<section>
			<title>Application</title>
			<programlisting>
			<![CDATA[
package api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

import api.ApplicationConfiguration;

@SpringBootApplication
@EnableConfigurationProperties(ApplicationConfiguration.class)
@EnableAutoConfiguration
@ComponentScan({ "api.web", "api.rest", "api.service" })
@EnableMongoRepositories
@EnableJpaRepositories
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
			]]>
			</programlisting>
		</section>
		<section>
			<title>RestController</title>
			<programlisting>
			<![CDATA[
package api.rest;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

import javax.mail.internet.MimeMessage;

import org.apache.velocity.app.VelocityEngine;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.ui.velocity.VelocityEngineUtils;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import api.pojo.Email;

@RestController
@RequestMapping("/v1/email")
public class EmailRestController extends CommonRestController {

	@Autowired
	private JavaMailSender javaMailSender;

	@Autowired
	private VelocityEngine velocityEngine;

	@RequestMapping("version")
	@ResponseStatus(HttpStatus.OK)
	public String version() {
		return "[OK] Welcome to withdraw Restful version 1.0";
	}

	@RequestMapping(value = "send", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> sendSimpleMail(@RequestBody Email email) {
		SimpleMailMessage message = new SimpleMailMessage();
		message.setFrom(email.getFrom());
		message.setTo(email.getTo());
		message.setSubject(email.getSubject());
		message.setText(email.getText());
		javaMailSender.send(message);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}

	@RequestMapping(value = "attachments", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> attachments(@RequestBody Email email) throws Exception {

		MimeMessage mimeMessage = javaMailSender.createMimeMessage();

		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
		mimeMessageHelper.setFrom(email.getFrom());
		mimeMessageHelper.setTo(email.getTo());
		mimeMessageHelper.setSubject(email.getSubject());
		mimeMessageHelper.setText("<html><body><img src=\"cid:banner\" >" + email.getText() + "</body></html>", true);

		FileSystemResource file = new FileSystemResource(new File("banner.jpg"));
		mimeMessageHelper.addInline("banner", file);

		FileSystemResource fileSystemResource = new FileSystemResource(new File("Attachment.jpg"));
		mimeMessageHelper.addAttachment("Attachment.jpg", fileSystemResource);

		javaMailSender.send(mimeMessage);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}

	@RequestMapping(value = "template", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> template(@RequestBody Email email) throws Exception {

		Map<String, Object> model = new HashMap<String, Object>();
		model.put("title", email.getSubject());
		model.put("body", email.getText());
		String text = VelocityEngineUtils.mergeTemplateIntoString(velocityEngine, "email.vm", "UTF-8", model);
		
		System.out.println(text);

		MimeMessage mimeMessage = javaMailSender.createMimeMessage();
		
		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
		mimeMessageHelper.setFrom(email.getFrom());
		mimeMessageHelper.setTo(email.getTo());
		mimeMessageHelper.setSubject(email.getSubject());
		mimeMessageHelper.setText(text, true);

		javaMailSender.send(mimeMessage);
		
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}
}

			]]>
			</programlisting>
		</section>
		<section>
			<title>Test</title>
			<programlisting>
			<![CDATA[
$ curl -i -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d '{"from":"www@netkiller.cn", "to":"21214094@qq.com","subject":"Hello","text":"Hello world!!!"}' http://172.16.0.20:8080/v1/email/template.json
			]]>
			</programlisting>
		</section>
	</section>
	<section id="thymeleaf">
		<title>Spring boot with Thymeleaf</title>
		<section id="thymeleaf.maven">
			<title>Maven</title>
			<programlisting>
			<![CDATA[
	<dependency>  
		<groupId>org.springframework.boot</groupId>  
		<artifactId>spring-boot-starter-thymeleaf</artifactId>  
	</dependency>
			]]>
			</programlisting>
		</section>
		<section id="thymeleaf.application.properties">
			<title>application.properties</title>
			<para>创建目录 src/main/resources/templates/ 用户存放模板文件</para>
			<programlisting>
			<![CDATA[
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML5
spring.thymeleaf.encoding=UTF-8
spring.thymeleaf.content-type=text/html
spring.thymeleaf.cache=false	
			]]>
			</programlisting>
		</section>
		<section id="thymeleaf.controller">
			<title>Controller</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
@RequestMapping("/")
public class HelloController {

	@GetMapping("/hello")
	// 如果此处使用 @ResponseBody，将会返回 "hello" 字符串，而不是模板
	public String test() {
		return "hello";

	}

	@RequestMapping("/hello1")
	public String hello1(Map<String, Object> map) {
		// 传递参数测试
		map.put("name", "Neo");
		return "thymeleaf";
	}

	@RequestMapping("/hello2")
	public ModelAndView hello2() {
		ModelAndView mv = new ModelAndView();
		mv.addObject("name", "Amy");
		mv.setViewName("thymeleaf");
		return mv;
	}

	@RequestMapping(value = "/{name}", method = RequestMethod.GET)
	public String getMovie(@PathVariable String name, ModelMap model) {
		model.addAttribute("name", name);
		return "hello";
	}

}			

			]]>
			</programlisting>
		</section>
		<section id="thymeleaf.template">
			<title>HTML5 Template</title>
			<para>在 src/main/resources/templates/ 目录下创建模板文件 hello.html</para>
			<programlisting>
			<![CDATA[
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
<meta charset="UTF-8" />
<title>Spring MVC + Thymeleaf Example</title>
</head>
<body>
	<h1>Welcome to Thymeleaf</h1>
	<span th:text="${name}"></span>
</body>
</html>
			]]>
			</programlisting>
		</section>
	</section>
	<section id="RestTemplate">
		<title>String boot with RestTemplate</title>
		<para>RestTemplate 是 Spring Restful Client 用于调用restful接口</para>
		<section>
			<title>在控制器中完整实例</title>
			<programlisting>
			<![CDATA[
package api.web;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.client.RestTemplate;

import api.domain.City;
import api.repository.CityRepository;

@Controller
public class IndexController {

	@Autowired
	private CityRepository repository;

	// Spring RESTFul Client
	
	@RequestMapping("/restful/get")
	@ResponseBody
	public String restfulGet() {
		RestTemplate restTemplate = new RestTemplate();
		String text = restTemplate.getForObject("http://inf.netkiller.cn/detail/html/2/2/42564.html", String.class);
		return text;
	}

	@RequestMapping("/restful/get/{id}")
	@ResponseBody
	private static String restfulGetId(@PathVariable String id) {
		final String uri = "http://inf.netkiller.cn/detail/html/{tid}/{cid}/{id}.html";

		Map<String, String> params = new HashMap<String, String>();
		params.put("tid", "2");
		params.put("cid", "2");
		params.put("id", id);
		RestTemplate restTemplate = new RestTemplate();
		String result = restTemplate.getForObject(uri, String.class, params);

		return (result);
	}

	@RequestMapping("/restful/post/{id}")
	@ResponseBody
	private static String restfullPost(@PathVariable String id) {

		final String uri = "http://inf.netkiller.cn/detail/html/{tid}/{cid}/{id}.html";

		Map<String, String> params = new HashMap<String, String>();
		params.put("tid", "2");
		params.put("cid", "2");
		params.put("id", id);

		City city = new City("Shenzhen", "Guangdong");

		RestTemplate restTemplate = new RestTemplate();
		String result = restTemplate.postForObject(uri, city, String.class, params);
		return result;
	}

	@RequestMapping("/restful/put/{id}")
	private static void restfulPut(@PathVariable String id) {
		final String uri = "http://inf.netkiller.cn/detail/html/{tid}/{cid}/{id}.html";

		Map<String, String> params = new HashMap<String, String>();
		params.put("id", id);

		City city = new City("Shenzhen", "Guangdong");

		RestTemplate restTemplate = new RestTemplate();
		restTemplate.put(uri, city, params);
	}

	@RequestMapping("/restful/delete/{id}")
	private static void restfulDelete(@PathVariable String id) {
		final String uri = "http://inf.netkiller.cn/detail/html/{tid}/{cid}/{id}.html";

		Map<String, String> params = new HashMap<String, String>();
		params.put("id", id);

		RestTemplate restTemplate = new RestTemplate();
		restTemplate.delete(uri, params);
	}
}
			
			]]>
			</programlisting>
		</section>

	</section>


	<section id="session">
		<title>Spring boot with Session share</title>
		<section>
			<title>Redis</title>
			<section>
				<title>Maven</title>
				<para>增加下面代码到pom.xml</para>
				<programlisting>
				<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
				]]>
				</programlisting>
				<para>pom.xml 文件</para>
				<programlisting>
				<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>cn.netkiller</groupId>
	<artifactId>deploy</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>deploy.netkiller.cn</name>
	<description>Deploy project for Spring Boot</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> -->
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> -->
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jdbc</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-websocket</artifactId>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>webjars-locator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>sockjs-client</artifactId>
			<version>1.0.2</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>stomp-websocket</artifactId>
			<version>2.3.3</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>bootstrap</artifactId>
			<version>3.3.7</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>jquery</artifactId>
			<version>3.1.0</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>

	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

	<repositories>
		<repository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
	<pluginRepositories>
		<pluginRepository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</pluginRepository>
		<pluginRepository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</pluginRepository>
	</pluginRepositories>

</project>
				
				]]>
				</programlisting>
			</section>
			<section>
				<title>application.properties</title>
				<para>spring.session.store-type=redis 将Session 存储在Redis中</para>
				<programlisting>
				<![CDATA[
spring.redis.database=0
spring.redis.host=192.168.4.1
spring.redis.port=6379
#spring.redis.password=
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=30
spring.redis.pool.max-idle=8
spring.redis.pool.min-idle=0
spring.redis.timeout=10

spring.session.store-type=redis
				]]>
				</programlisting>

			</section>
			<section>
				<title>Application</title>
				<programlisting>
				<![CDATA[
package cn.netkiller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
@EnableMongoRepositories
@EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);

	}
}
				]]>
				</programlisting>
				<para>RedisHttpSessionConfig.java</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@Configuration
@EnableRedisHttpSession
public class RedisHttpSessionConfig {

	public RedisHttpSessionConfig() {
		// TODO Auto-generated constructor stub
	}

}				
				]]>
				</programlisting>
			</section>

		</section>
		<section>
			<title>测试 Session</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.web;

import java.util.Date;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController {

	public TestController() {
		// TODO Auto-generated constructor stub
	}

	@RequestMapping("/session/set")
	@ResponseBody
	public String set(HttpSession session) {
		String key = "test";
		session.setAttribute(key, new Date());
		return key;
	}

	@RequestMapping("/session/get")
	@ResponseBody
	public String get(HttpSession session) {
		String value = (String) session.getAttribute("test").toString();
		return value;
	}

}
			]]>
			</programlisting>
			<para>keys spring:session:* 查看 Session Key</para>
			<screen>
			<![CDATA[			
$ telnet 192.168.4.1 6379
Connecting to 192.168.4.1:6379...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
keys spring:session:*
*7
$68
spring:session:sessions:expires:a510f46f-0a2f-4649-af05-34bd750562c1
$40
spring:session:expirations:1476100200000
$40
spring:session:expirations:1476098400000
$60
spring:session:sessions:f6494a2f-591e-42ba-b381-ce2596f4046d
$60
spring:session:sessions:a510f46f-0a2f-4649-af05-34bd750562c1
$112
spring:session:index:org.springframework.session.FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME:user
$60
spring:session:sessions:627018c8-243e-43ac-87b9-fc07f130c899
				]]>
			</screen>
		</section>
		<section>
			<title>JDBC</title>
			<programlisting>
			<![CDATA[
spring.session.store-type=jdbc
spring.session.jdbc.table-name=SESSIONS			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Springboot 2.1</title>
			<screen>
			<![CDATA[
<dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-redis</artifactId>  
</dependency>  
<dependency>  
        <groupId>org.springframework.session</groupId>  
        <artifactId>spring-session-data-redis</artifactId>  
</dependency>  
			]]>
			</screen>
			<para>开启Redis共享SESSION @EnableRedisHttpSession </para>
			<screen>
			<![CDATA[
package cn.netkiller.oauth2;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@SpringBootApplication
@EnableAutoConfiguration
@EnableRedisHttpSession 
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
			
			]]>
			</screen>
			<para>application.properties中配置redis服务器</para>
			<screen>
			<![CDATA[
spring.redis.host=localhost  
spring.redis.port=6379 			
			]]>
			</screen>
		</section>
	</section>


	
	&section.boot.datasource.xml;


	<section id="cache">
		<title>Spring boot with Caching</title>
		<section>
			<title>maven</title>
			<programlisting>
				<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
		</dependency>			
				]]>
			</programlisting>
		</section>
		<section id="">
			<title>启用 Cache</title>
			<para>添加 @EnableCaching </para>
			<screen>
			<![CDATA[
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}			
			]]>
			</screen>
		</section>

		<section>
			<title>测试 Controller</title>
			<para>缓存返回结果</para>
			<programlisting>
				<![CDATA[
	@Cacheable("cacheable")
	@RequestMapping("/test/cacheable")
	@ResponseBody
	public String cacheable() {
		Date date = new Date();
		String message = date.toString();
		return message;
	}
				]]>
			</programlisting>
			<para>5秒钟清楚一次缓存</para>
			<programlisting>
				<![CDATA[
	@Scheduled(fixedDelay = 5000)
	@CacheEvict(allEntries = true, value = "cacheable")	
	public void expire() {
		Date date = new Date();
		String message = date.toString();
		System.out.println(message);
	}
				]]>
			</programlisting>
		</section>
		<section>
			<title>@Cacheable 的用法</title>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#id")
public User find(Integer id) {

   return null;

}			
			]]>
			</programlisting>
			<para>引用对象</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#user.id")
public User find(User user) {

   returnnull;

}			
			]]>
			</programlisting>
			<para>条件判断</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="messagecache", key="#id", condition="id < 10")
public String getMessage(int id){

	return "hello"+id;

}

@Cacheable(value="test",condition="#userName.length()>2")
@Cacheable(value={"users"}, key="#user.id", condition="#user.id%2==0")
			]]>
			</programlisting>
			<para>#p0 参数索引，p0表示第一个参数</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#p0")
public User find(Integer id) {

   return null;

}

@Cacheable(value="users", key="#p0.id")
public User find(User user) {

   return null;

}
			]]>
			</programlisting>
			<para>@Cacheable 如果没有任何参数将会自动生成 key ，前提是必须设置 @CacheConfig(cacheNames = "test")</para>
			<programlisting>
			<![CDATA[
	@GetMapping("/cache/auto")
	@Cacheable()
	public Attribute auto() {
		Attribute attribute = new Attribute();
		attribute.setName("sdfsdf");
		return attribute;
	}			
			]]>
			</programlisting>
			<screen>
			<![CDATA[
127.0.0.1:6379> keys *
1) "test::SimpleKey []"			
			]]>
			</screen>
		</section>
		<section id="">
			<title>@CachePut 用法</title>
			<para>@CachePut 每次都会执行方法，都会将结果存入指定key的缓存中，@CachePut 不会判断是否 key 已经存在，二是始终覆盖。</para>
			<programlisting>
			<![CDATA[
@CachePut("users")
public User find(Integer id) {

   return null;

}
			]]>
			</programlisting>
		</section>
		<section id="">
			<title>解决Expire 和 TTL 过期时间</title>
			<para>Springboot 1.x</para>
			<programlisting>
			<![CDATA[
	@Bean
	public CacheManager cacheManager(RedisTemplate redisTemplate) {
		RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);
		cacheManager.setDefaultExpiration(60);	//缓存默认 60 秒
		Map<String, Long> expiresMap = new HashMap<>();
		expiresMap.put("Product", 5L);  //设置 key = Product 时 5秒缓存。你可以添加很多规则。 
		cacheManager.setExpires(expiresMap);
		return cacheManager;
	}			
			]]>
			</programlisting>
			<para>Springboot 2.x</para>
			<programlisting>
			<![CDATA[
package api.config;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import org.springframework.cache.CacheManager;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
public class CachingConfigurer {

	public CachingConfigurer() {
		// TODO Auto-generated constructor stub
	}

	@Bean
	public KeyGenerator simpleKeyGenerator() {
		return (o, method, objects) -> {
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.append(o.getClass().getSimpleName());
			stringBuilder.append(".");
			stringBuilder.append(method.getName());
			stringBuilder.append("[");
			for (Object obj : objects) {
				stringBuilder.append(obj.toString());
			}
			stringBuilder.append("]");

			return stringBuilder.toString();
		};
	}

	@Bean
	public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
		return new RedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory), 
		this.redisCacheConfiguration(600), 	// 默认配置
		this.initialCacheConfigurations());	// 指定key过期时间配置
	}
               
	private Map<String, RedisCacheConfiguration> initialCacheConfigurations() {
		Map<String, RedisCacheConfiguration> redisCacheConfigurationMap = new HashMap<>();
		redisCacheConfigurationMap.put("UserInfoList", this.redisCacheConfiguration(3000));
		redisCacheConfigurationMap.put("UserInfoListAnother", this.redisCacheConfiguration(18000));

		return redisCacheConfigurationMap;
	}

	private RedisCacheConfiguration redisCacheConfiguration(Integer seconds) {
		Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
		ObjectMapper om = new ObjectMapper();
		om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		jackson2JsonRedisSerializer.setObjectMapper(om);

		RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
		redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).entryTtl(Duration.ofSeconds(seconds));

		return redisCacheConfiguration;
	}

}

			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
	@Cacheable(value = "DefaultKey", keyGenerator = "simpleKeyGenerator") // 600秒，使用默认策略
	@Cacheable(value = "UserInfoList", keyGenerator = "simpleKeyGenerator") // 3000秒
    @Cacheable(value = "UserInfoListAnother", keyGenerator = "simpleKeyGenerator") // 18000秒
    
			]]>
			</programlisting>
			<screen>
			<![CDATA[
127.0.0.1:6379> keys *
1) "test2::SimpleKey []"

127.0.0.1:6379> ttl "test2::SimpleKey []"
(integer) 584
			
			]]>
			</screen>
		</section>
		<section>
			<title>SpEL表达式</title>
			<programlisting>
			<![CDATA[
	@GetMapping("/cache/expire")
	@Cacheable("test1#${select.cache.timeout:1000}")
	public String expire() {
		return "Test";
	}
	
	@GetMapping("/cache/expire")
	@Cacheable("test1#${select.cache.timeout:1000}#${select.cache.refresh:600}")
	public String expire() {
		return "Test";
	}
			]]>
			</programlisting>
		</section>
	</section>
	<section id="email">
		<title>Spring boot with Email</title>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
			]]>
			</programlisting>
			<example>
				<title>Spring boot with Email (pom.xml)</title>
				<programlisting>
				<![CDATA[
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>netkiller.cn</groupId>
	<artifactId>api.netkiller.cn</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>api.netkiller.cn</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-mongodb</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-oracle</artifactId>
			<version>1.0.0.RELEASE</version>
		</dependency>

		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<!-- <version>12.1.0.1</version> -->
			<version>11.2.0.3</version>
			<scope>system</scope>
			<systemPath>${basedir}/lib/ojdbc6.jar</systemPath>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>

		<dependency>
			<groupId>com.google.code.gson</groupId>
			<artifactId>gson</artifactId>
			<scope>compile</scope>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<sourceDirectory>src</sourceDirectory>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.3</version>
				<configuration>
					<source />
					<target />
				</configuration>
			</plugin>
			<plugin>
				<artifactId>maven-war-plugin</artifactId>
				<version>2.6</version>
				<configuration>
					<warSourceDirectory>WebContent</warSourceDirectory>
					<failOnMissingWebXml>false</failOnMissingWebXml>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

				]]>
				</programlisting>
			</example>
		</section>
		<section>
			<title>Resource</title>
			<para>application.properties</para>
			<para>Postfix / Exam4 / Sendmail 邮件服务器配置</para>
			<programlisting>
			<![CDATA[
spring.mail.host=smtp.163.com    
			]]>
			</programlisting>
			<para>SMTP 配置</para>
			<programlisting>
			<![CDATA[
spring.mail.host=smtp.163.com
spring.mail.username=openunix@163.com
spring.mail.password=your_password
spring.mail.properties.mail.smtp.auth=true  
#spring.mail.properties.mail.smtp.starttls.enable=true  
#spring.mail.properties.mail.smtp.starttls.required=true  
			]]>
			</programlisting>
		</section>
		<section>
			<title>POJO</title>
			<programlisting>
			<![CDATA[
package api.pojo;

public class Email {
	public String from;
	public String to;
	public String subject;
	public String text;
	public boolean status;
	
	public String getFrom() {
		return from;
	}
	public void setFrom(String from) {
		this.from = from;
	}
	public String getTo() {
		return to;
	}
	public void setTo(String to) {
		this.to = to;
	}
	public String getSubject() {
		return subject;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public String getText() {
		return text;
	}
	public void setText(String text) {
		this.text = text;
	}
	
	public boolean isStatus() {
		return status;
	}
	public void setStatus(boolean status) {
		this.status = status;
	}
	
	@Override
	public String toString() {
		return "Email [from=" + from + ", to=" + to + ", subject=" + subject + ", text=" + text + "]";
	}
	public Email() {

	}
	public Email(String from, String to, String subject, String text) {
		super();
		this.from = from;
		this.to = to;
		this.subject = subject;
		this.text = text;
	}
	
}

			]]>
			</programlisting>
		</section>
		<section>
			<title>RestController</title>
			<programlisting>
			<![CDATA[
package api.rest;

import java.io.File;

import javax.mail.internet.MimeMessage;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import api.pojo.Email;

@RestController
@RequestMapping("/v1/email")
public class EmailRestController extends CommonRestController {

	@Autowired
	private JavaMailSender javaMailSender;

	@RequestMapping("version")
	@ResponseStatus(HttpStatus.OK)
	public String version() {
		return "[OK] Welcome to withdraw Restful version 1.0";
	}

	@RequestMapping(value = "send", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> sendSimpleMail(@RequestBody Email email) {
		SimpleMailMessage message = new SimpleMailMessage();
		message.setFrom(email.getFrom());
		message.setTo(email.getTo());
		message.setSubject(email.getSubject());
		message.setText(email.getText());
		javaMailSender.send(message);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}

	@RequestMapping(value = "attachments", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> attachments(@RequestBody Email email) throws Exception {

		MimeMessage mimeMessage = javaMailSender.createMimeMessage();

		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
		mimeMessageHelper.setFrom(email.getFrom());
		mimeMessageHelper.setTo(email.getTo());
		mimeMessageHelper.setSubject(email.getSubject());
		mimeMessageHelper.setText("<html><body><img src=\"cid:banner\" >" + email.getText() + "</body></html>", true);

		FileSystemResource file = new FileSystemResource(new File("banner.jpg"));
		mimeMessageHelper.addInline("banner", file);

		FileSystemResource fileSystemResource = new FileSystemResource(new File("Attachment.jpg"));
		mimeMessageHelper.addAttachment("Attachment.jpg", fileSystemResource);

		javaMailSender.send(mimeMessage);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}
	
	// 如果你不想使用 application.properties 中的 spring.mail.host 配置，想自行配置SMTP主机可以参考下面例子
	@RequestMapping(value = "sendmail", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> sendmail(@RequestBody Email email) {
		JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl();
		javaMailSender.setHost(email.getHost());
		SimpleMailMessage message = new SimpleMailMessage();
		message.setFrom(email.getFrom());
		message.setTo(email.getTo());
		message.setSubject(email.getSubject());
		message.setText(email.getText());
		try{
			javaMailSender.send(message);
			email.setStatus(true);
		}catch(Exception e){
			email.setText(e.getMessage());
			email.setStatus(false);
		}

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}	
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Test</title>
			<screen>
				$ curl -i -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d '{"from":"root@netkiller.cn", "to":"21214094@qq.com","subject":"Hello","text":"Hello world!!!"}' http://172.16.0.20:8080/v1/email/send.json
				HTTP/1.1 200 OK
				Server: Apache-Coyote/1.1
				Content-Type: application/json;charset=UTF-8
				Transfer-Encoding: chunked
				Date: Wed, 10 Aug 2016 06:38:00 GMT

				{"from":"root@netkiller.cn","to":"21214094@qq.com","subject":"Hello","text":"Hello world!!!","status":true}
			</screen>
		</section>
	</section>






	<section id="scheduling">
		<title>Spring boot with Scheduling</title>
		<para>项目中经常会用到计划任务，spring Boot 中通过@EnableScheduling启用计划任务，再通过@Scheduled注解配置计划任务如果运行。</para>
		<section>
			<title>Application.java</title>
			<para>Application.java</para>
			<para>启用计划任务, 在Spring Boot启动类加上注解@EnableScheduling，表示该项目启用计划任务</para>
			<programlisting>
			<![CDATA[
package api;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan({ "api.config", "api.web", "api.rest", "api.service","api.schedule" })
@EnableMongoRepositories
@EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
				]]>
			</programlisting>
			<para>开启计划任务 @EnableScheduling</para>
			<para>确保你的计划任务在 @ComponentScan 包中。</para>
		</section>
		<section>
			<title>Component</title>
			<para>在计划任务方法上加上@Scheduled注解，表示该方法是一个计划任务，项目启动后会去扫描该注解的方法并加入计划任务列表。</para>
			<programlisting>
			<![CDATA[
			
package api.schedule;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class ScheduledTasks {

	private static final Logger log = LoggerFactory.getLogger(ScheduledTasks.class);
	private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");
	public final static long ONE_DAY = 24 * 60 * 60 * 1000;
	public final static long ONE_HOUR = 60 * 60 * 1000;
	
	public ScheduledTasks() {
	// TODO Auto-generated constructor stub
	}
	
	@Scheduled(fixedRate = 5000) //5秒运行一次调度任务
		public void echoCurrentTime() {
		log.info("The time is now {}", dateFormat.format(new Date()));
	}
	
	@Scheduled(fixedRate = ONE_DAY)
		public void scheduledTask() {
		System.out.println("每隔一天执行一次调度任务");
	}
	
	@Scheduled(fixedDelay = ONE_HOUR)
		public void scheduleTask2() {
		System.out.println("运行完后隔一小时就执行任务");
	}
	
	@Scheduled(initialDelay = 1000, fixedRate = 5000)
	public void doSomething() {
		// something that should execute periodically
	}
	
	@Scheduled(cron = "0 0/1 * * * ? ")
		public void ScheduledTask3() {
		System.out.println(" 每隔一分钟执行一次任务");
	}

}
			]]>
			</programlisting>

		</section>
		<section>
			<title>查看日志</title>
			<programlisting>
			<![CDATA[
tail -f spring.log			
			]]>
			</programlisting>
		</section>
		<section>
			<title>计划任务控制开关</title>
			<para>matchIfMissing = true， 如果改属性条目不存在返回 true</para>
			<programlisting>
			<![CDATA[
@ConditionalOnProperty("batch.metrics.export.influxdb.enabled")

# mybean.enabled = true
@ConditionalOnProperty(value='mybean.enabled')
@ConditionalOnProperty(value = "endpoints.hal.enabled", matchIfMissing = true)

# server.host = localhost
@ConditionalOnProperty(name="server.host", havingValue="localhost")
@ConditionalOnExpression("'${server.host}'=='localhost'")

# spring.rabbitmq.dynamic = true
@ConditionalOnProperty(prefix = "spring.rabbitmq", name = "dynamic", matchIfMissing = true)
@ConditionalOnProperty(prefix = "extension.security.cors", name = "enabled", matchIfMissing = false)
@ConditionalOnProperty(prefix = "camunda.bpm.job-execution", name = "enabled", havingValue = "true", matchIfMissing = true)

# spring.social.auto-connection-views = true
@ConditionalOnProperty(prefix = "spring.social.", value = "auto-connection-views")
			]]>
			</programlisting>
			<para>使用案例</para>
			<programlisting>
			<![CDATA[
package mis.schedule;

import java.text.SimpleDateFormat;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@ConditionalOnProperty("mis.schedule.enabled")
@Component
public class ScheduledTasks {
	private static final Logger logger = LoggerFactory.getLogger(ScheduledTasks.class);
	private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-mm-dd HH:mm:ss");
	public final static long ONE_DAY = 24 * 60 * 60 * 1000;
	public final static long ONE_HOUR = 60 * 60 * 1000;
	public final static long ONE_SECOND = 1000;

	public ScheduledTasks() {
		// TODO Auto-generated constructor stub
	}

	@Scheduled(fixedDelay = ONE_SECOND)
	public void scheduleTaskSplitLine() {
		logger.info("==================== {} ====================", dateFormat.format(new Date()));
	}
}
			]]>
			</programlisting>
			<para>application.properties 配置如下</para>
			<screen>
			<![CDATA[
mis.schedule.enabled=true			
			]]>
			</screen>
		</section>

		<section id="scheduled">
			<title>@Scheduled 详解</title>
			<para>@Scheduled参数说明</para>
			<screen>
			<![CDATA[
@Scheduled注解有一些参数，用于配置计划任务执行频率，执行时段等。

cron ：cron表达式，e.g. {@code "0 * * * * ？"}从前到后依次表示秒 分 时 日 月 年
zone：设置时区，指明计划任务运行在哪个时区下，默认为空，采用操作系统默认时区
fixedDelay：同一个计划任务两次执行间隔固定时间，单位毫秒，上次执行结束到下次开始执行的时间，以long类型复制
fixedDelayString：同一个计划任务两次执行间隔固定时间，单位毫秒，上次执行结束到下次开始执行的时间，以String类型赋值
fixedRate：以一个固定频率执行，单位毫秒，表示每隔多久执行一次，以long类型赋值
fixedRateString：以一个固定频率执行，单位毫秒，表示每隔多久执行一次，以String类型赋值
initialDelay：延迟启动计划任务，单位毫秒，表示执行第一次计划任务前先延迟一段时间，以long类型赋值
initialDelayString：延迟启动计划任务，单位毫秒，表示执行第一次计划任务前先延迟一段时间，以String赋值
			]]>
			</screen>
			<para></para>
			<para>cron表达式使用空格分隔的时间元素。</para>
			<screen>
			<![CDATA[
字段   允许值   允许的特殊字符
秒	 	0-59	 	, - * /
分	 	0-59	 	, - * /
小时	 	0-23	 	, - * /
日期	 	1-31	 	, - * ? / L W C
月份	 	1-12 或者 JAN-DEC	 	, - * /
星期	 	1-7 或者 SUN-SAT	 	, - * ? / L C #
年（可选）	 	留空, 1970-2099	 	, - * /		

按顺序依次为

秒（0~59）

分钟（0~59）

小时（0~23）

天（月）（0~31，但是你需要考虑你月的天数）

月（0~11）

天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）

7.年份（1970－2099）


其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置?.

0 0 10,14,16 * * ? 每天上午10点，下午2点，4点
0 0/30 9-17 * * ?   朝九晚五工作时间内每半小时
0 0 12 ? * WED 表示每个星期三中午12点 
"0 0 12 * * ?" 每天中午12点触发 
"0 15 10 ? * *" 每天上午10:15触发 
"0 15 10 * * ?" 每天上午10:15触发 
"0 15 10 * * ? *" 每天上午10:15触发 
"0 15 10 * * ? 2005" 2005年的每天上午10:15触发 
"0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 
"0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 
"0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 
"0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 
"0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 
"0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 
"0 15 10 15 * ?" 每月15日上午10:15触发 
"0 15 10 L * ?" 每月最后一日的上午10:15触发 
"0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 
"0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 
"0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发 

有些子表达式能包含一些范围或列表

例如：子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT”

“*”字符代表所有可能的值

因此，“*”在子表达式（月）里表示每个月的含义，“*”在子表达式（天（星期））表示星期的每一天


“/”字符用来指定数值的增量

例如：在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟

         在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样


“？”字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值

当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？”

 

“L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写

但是它在两个子表达式里的含义是不同的。

在天（月）子表达式中，“L”表示一个月的最后一天

在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT

如果在“L”前有具体的内容，它就具有其他的含义了

例如：“6L”表示这个月的倒数第６天，“ＦＲＩＬ”表示这个月的最一个星期五

注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题

			]]>
			</screen>
			<section>
				<title>每3秒钟一运行一次</title>
				<screen>
				<![CDATA[
@Component
@EnableScheduling
public class MyTask {

    @Scheduled(cron="*/3 * * * * *")
    public void myTaskMethod(){
        //do something
    }
}
				]]>
				</screen>
			</section>
			<section>
				<title>凌晨23点运行</title>
				<programlisting>
				<![CDATA[
	@Scheduled(cron = "0 0 23 * * ?")
	private void cleanNewToday() {
		long begin = System.currentTimeMillis();
        
		redisTemplate.delete("news:today");
    
        long end = System.currentTimeMillis();
		logger.info("Schedule clean redis {} 耗时 {} 秒", "cleanNewFlash()", (end-begin) / 1000 );
	}
				]]>
				</programlisting>
			</section>
		</section>


	</section>



	<section id="hessian">
		<title>Spring boot with Hessian</title>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
		<dependency>
			<groupId>com.caucho</groupId>
			<artifactId>hessian</artifactId>
			<version>4.0.38</version>
		</dependency>			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Application</title>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
//import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
//import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
// @EnableMongoRepositories
// @EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);

	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>HessianServiceExporter</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.HessianProxyFactoryBean;
//import org.springframework.remoting.caucho.HessianProxyFactoryBean;
import org.springframework.remoting.caucho.HessianServiceExporter;

import cn.netkiller.service.HelloWorldService;

@Configuration
public class HessionConfig {
	@Autowired
	private HelloWorldService helloWorldService;

	@Bean(name = "/HelloWorldService")
	public HessianServiceExporter hessianServiceExporter() {
		HessianServiceExporter exporter = new HessianServiceExporter();
		exporter.setService(helloWorldService);
		exporter.setServiceInterface(HelloWorldService.class);
		return exporter;
	}

	@Bean
	public HessianProxyFactoryBean helloClient() {
		HessianProxyFactoryBean factory = new HessianProxyFactoryBean();
		factory.setServiceUrl("http://localhost:7000/HelloWorldService");
		factory.setServiceInterface(HelloWorldService.class);
		return factory;
	}
}		
			]]>
			</programlisting>
		</section>
		<section>
			<title>Service</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.service;

public interface HelloWorldService {
	String sayHello(String name);
}
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
package cn.netkiller.service.impl;

import org.springframework.stereotype.Component;

import cn.netkiller.service.HelloWorldService;

@Component
public class HelloWorldServiceImpl implements HelloWorldService {
	@Override
	public String sayHello(String name) {
		return "Hello World! " + name;
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>RestController</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.rest.hession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import cn.netkiller.service.HelloWorldService;

@RestController
@RequestMapping("/public/hession")
public class TestRestController {
	@Autowired
	HelloWorldService helloWorldService;

	@RequestMapping("/hello")
	public String test() {
		return helloWorldService.sayHello("Spring boot with Hessian.");
	}
}		
			]]>
			</programlisting>
		</section>
	</section>
	&section.boot.queue.xml;

	<section id="git">
		<title>Spring boot with Git version</title>
		<para>Spring boot 每次升级打包发给运维操作，常常运维操作不当致使升级失败，开发怎样确认线上的jar/war包与升级包一致呢？</para>
		<para>请看下面的解决方案</para>
		<section>
			<title>CommonRestController 公共控制器</title>
			<para>所有 RestController将会集成 CommonRestController</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.rest;

import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;

public class CommonRestController {

	@RequestMapping("ping")
	@ResponseStatus(HttpStatus.OK)
	public String welcome() {
		return "PONG";
	}

	@RequestMapping("commit")
	public String commit() {
		return "$Id$";
	}

	@RequestMapping("auth")
	@ResponseStatus(HttpStatus.OK)
	public String auth(@AuthenticationPrincipal final UserDetails user) {
		return String.format("%s: %s %s", user.getUsername(), user.getPassword(), user.getAuthorities());
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>VersionRestController 测试控制器</title>
			<para>我们创建一个RestController并继承CommonRestController用来测试</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.rest;

@RestController
@RequestMapping("/public/version")
public class VersionRestController extends CommonRestController {
	private static final Logger logger = LoggerFactory.getLogger(VersionRestController.class);

	public VersionRestController() {
		// TODO Auto-generated constructor stub
	}

	@RequestMapping("welcome")
	@ResponseStatus(HttpStatus.OK)
	public String welcome() {
		return "Welcome to RestTemplate version 1.0.";
	}

}
			]]>
			</programlisting>
		</section>
		<section>
			<title>创建 .gitattributes 文件</title>
			<programlisting>
			<![CDATA[
# vim .gitattributes
src/main/java/cn/netkiller/api/rest/CommonRestController.java ident
			]]>
			</programlisting>
			<para>使用curl命令调用commit接口可以显示当前war/jar最后一次提交的版本号码（你同样可以使用IE浏览器）</para>
			<programlisting>
			<![CDATA[
curl https://api.netkiller.cn/public/version/commit.json
$Id: 929bc9e4c90b4d68c25dc693618f23b33fd6ba0f $
			]]>
			</programlisting>
		</section>
	</section>

	<section id="data.restful">
		<title>Spring boot with Data restful</title>
		<para>spring-boot-starter-data-rest 能够提供将 Repository, CrudRepository 等接口直接提供给用户访问</para>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-rest</artifactId>
		</dependency>
			]]>
			</programlisting>
		</section>
	</section>
	<section id="SpringBoot.ELK">
		<title>Spring boot with ELK(Elasticsearch + Logstash + Kibana)</title>
		<para>将 Spring boot 日志写入 ELK 有多种实现方式，这里仅提供三种方案：</para>
		<orderedlist>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Tcp/IP -&gt; logstash -&gt; elasticsearch</para>
				这种方式实现非常方便不需要而外包或者软件
			</listitem>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Redis -&gt; logstash -&gt; elasticsearch</para>
				利用 Redis 提供的发布订阅功能将日志投递到 elasticsearch
			</listitem>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Kafka -&gt; logstash -&gt; elasticsearch</para>
				Kafka 方法适合大数据的情况。
			</listitem>
		</orderedlist>
		<section>
			<title>TCP 方案</title>
			<para>logstash 配置</para>
			<programlisting>
			<![CDATA[
input {
  tcp {
    host => "172.16.1.16" 
    port => 9250
    mode => "server"
    tags => ["tags"]
    codec => json_lines  //可能需要更新logstash插件
  }
}

output {
 stdout{codec =>rubydebug}
  elasticsearch {
   hosts => ["localhost:9200"]  //这块配置需要带端口号
    flush_size => 1000

  }
}			
			]]>
			</programlisting>
			<para>Spring boot logback.xml 配置</para>
			<programlisting>
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property resource="properties/logback-variables.properties" /> 

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder charset="UTF-8">
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n
            </pattern>
        </encoder>
    </appender>
    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>172.16.1.16:9250</destination>
        <encoder charset="UTF-8" class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <!--<appender name="async" class="ch.qos.logback.classic.AsyncAppender">-->
        <!--<appender-ref ref="stash" />-->
    <!--</appender>-->
    
    <root level="info">                    <!-- 设置日志级别 -->
        <appender-ref ref="STDOUT" />
        <appender-ref ref="LOGSTASH" />
    </root>
</configuration>			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Redis 方案</title>
			<para>https://github.com/kmtong/logback-redis-appender</para>
			<para>Maven pom.xml 增加 Logback Redis 依赖</para>
			<programlisting>
			<![CDATA[
<!-- https://mvnrepository.com/artifact/com.cwbase/logback-redis-appender -->
<dependency>
    <groupId>com.cwbase</groupId>
    <artifactId>logback-redis-appender</artifactId>
    <version>1.1.5</version>
</dependency>			
			]]>
			</programlisting>
			<para>Spring boot logback.xml 配置</para>
			<programlisting>
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<include resource="org/springframework/boot/logging/logback/defaults.xml" />
	<include resource="org/springframework/boot/logging/logback/file-appender.xml" />
	<property name="type.name" value="test" />
	<appender name="LOGSTASH" class="com.cwbase.logback.RedisAppender">
		<source>spring-application</source>
		<type>${type.name}</type>
		<host>localhost</host>
		<key>logstash:redis</key>
		<tags>test-2</tags>
		<mdc>true</mdc>
		<location>true</location>
		<callerStackIndex>0</callerStackIndex>
		<!--additionalField添加附加字段 用于head插件显示 -->
		<additionalField>
			<key>MyKey</key>
			<value>MyValue</value>
		</additionalField>
		<additionalField>
			<key>MySecondKey</key>
			<value>MyOtherValue</value>
		</additionalField>
	</appender>
	<root level="INFO">
		<appender-ref ref="FILE" />
		<appender-ref ref="LOGSTASH" />
	</root>
</configuration>
			]]>
			</programlisting>
			<para>logstash 配置</para>
			<programlisting>
			<![CDATA[
input {
    redis {
        host => 'localhost'
        data_type => 'list'
        port => "6379"
        key => 'logstash:redis' #自定义
        type => 'redis-input'   #自定义
    }
}
output {
    elasticsearch {
        host => "localhost" 
        codec => "json"
        protocol => "http"
    }
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Kafka 方案</title>
			<programlisting>
			<![CDATA[]]>
			</programlisting>
		</section>
		<section>
			<title>Other</title>
			<programlisting>
			<![CDATA[]]>
			</programlisting>
		</section>
	</section>
	<section id="web3j">
		<title>Springboot with Ethereum (web3j)</title>
		<section>
			<title>Maven</title>
			<screen>
			<![CDATA[
		<dependency>
			<groupId>org.web3j</groupId>
			<artifactId>web3j-spring-boot-starter</artifactId>
			<version>1.6.0</version>
		</dependency>			
			]]>
			</screen>
		</section>
		<section id="web3j.springboot.application.properties">
			<title>application.properties</title>
			<screen>
			<![CDATA[
web3j.client-address=https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d
web3j.admin-client=true			
			]]>
			</screen>
		</section>
		<section>
			<title>TestRestController</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.wallet.restful;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;

@RestController
public class TestRestController {
	private static final Logger logger = LoggerFactory.getLogger(TestRestController.class);

	@Autowired
	private Web3j web3j;

	public TestRestController() {
		// TODO Auto-generated constructor stub
	}

	@GetMapping("/version")
	public String version() throws IOException {
		Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
		String clientVersion = web3ClientVersion.getWeb3ClientVersion();
		logger.info(clientVersion);
		return clientVersion;
	}

}
			
			]]>
			</programlisting>
		</section>
		<section>
			<title>测试</title>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~ % curl http://localhost:8080/version
Geth/v1.8.3-stable/linux-amd64/go1.10
			]]>
			</screen>
		</section>
	</section>
	<section id="enableasync">
		<title>异步执行</title>
		<section id="">
			<title>最简单的配置</title>
			<para></para>
			<programlisting>
			<![CDATA[
@SpringBootApplication
@EnableAsync
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
@Component
public class Task {

    @Async
    public void doTaskOne() throws Exception {
        // 业务逻辑
    }

    @Async
    public void doTaskTwo() throws Exception {
        // 业务逻辑
    }

    @Async
    public void doTaskThree() throws Exception {
        // 业务逻辑
    }

}			
			]]>
			</programlisting>
			<para>设置线程池，并且运行完成后推出</para>
			<programlisting>
			<![CDATA[
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@SpringBootApplication
@EnableAsync
public class Application {

    public static void main(String[] args) {
        // close the application context to shut down the custom ExecutorService
        SpringApplication.run(Application.class, args).close();
    }

    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(2);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("Netkiller -");
        executor.initialize();
        return executor;
    }


}			
			]]>
			</programlisting>
		</section>
		<section>
			<title>异步线程池</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.wallet.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class ExecutorConfig {
	/** Set the ThreadPoolExecutor's core pool size. */
	private int corePoolSize = 10;
	/** Set the ThreadPoolExecutor's maximum pool size. */
	private int maxPoolSize = 200;
	/** Set the capacity for the ThreadPoolExecutor's BlockingQueue. */
	private int queueCapacity = 10;
 
	@Bean
	public Executor OneAsync() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(corePoolSize);
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setThreadNamePrefix("MySimpleExecutor-");
		executor.initialize();
		return executor;
	}
	
	@Bean
	public Executor TwoAsync() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(corePoolSize);
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setThreadNamePrefix("MyExecutor-");
 
		// rejection-policy：当pool已经达到max size的时候，如何处理新任务
		// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行
		executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
		executor.initialize();
		return executor;
	}

}
			
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
@Service
public class DemoAsyncServiceImpl implements DemoAsyncService {
 
	public static Random random =new Random();
 
    @Async("OneAsync")
    public Future<String> doTaskOne() throws Exception {
        System.out.println("开始做任务一");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务一完成");
    }
 
    @Async("TwoAsync")
    public Future<String> doTaskTwo() throws Exception {
        System.out.println("开始做任务二");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务二，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务二完成");
    }
 
    @Async
    public Future<String> doTaskThree() throws Exception {
        System.out.println("开始做任务三");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务三，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务三完成");
    }
	
}
			]]>
			</programlisting>

		</section>
	</section>
	<section id="export.csv">
		<title>Spring boot with export csv.</title>
		<programlisting>
		<![CDATA[
	@GetMapping("/export")
	public void export(HttpServletResponse response) throws IOException {
		response.setContentType("application/csv");
		// response.setContentType("application/csv;charset=gb18030");
		response.setHeader("Content-Disposition", "attachment; filename=\"file.csv\"");

		BufferedWriter writer = new BufferedWriter(response.getWriter());

		// 需要写入 utf8bom 头否则会出现中文乱码
		// byte[] uft8bom = { (byte) 0xef, (byte) 0xbb, (byte) 0xbf };
		String bom = new String(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });
		writer.write(bom);
		writer.write("A,B,C");
		writer.newLine();
		tableRepository.findAll().forEach(table -> {
			try {
				String tmp = String.format("%s,%s,%s", table.getId(), table.getMethod(), table.getMoney());
				writer.write(tmp);
				writer.newLine();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		});

		writer.flush();
		writer.close();
	}		
		]]>
		</programlisting>
	</section>
	&section.boot.swagger2.xml;
	&section.boot.lombok.xml;
	&section.boot.docker.xml;
	&section.boot.command.xml;
	&section.boot.actuator.xml;
	&section.boot.aop.xml;
</chapter>