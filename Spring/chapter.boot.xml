<?xml version="1.0" encoding="UTF-8"?>
<chapter id="index"><?dbhtml dir="boot" ?>
	<title>Spring Boot</title>
	<para>注意以下使用 Spring boot 2</para>
	&section.boot.quickstart.xml;
	<section id="spring-boot-maven-plugin">
		<title>Springboot with Maven</title>
		<para>spring-boot-maven-plugin 插件</para>
		<section>
			<title>resource</title>
			<para>将 resource 添加应用程序</para>
			<screen>
			<![CDATA[
<build>
    <resources>
        <resource>
            <directory>src/main/java/resources</directory>
            <filtering>true</filtering>
            <excludes>
                <exclude>*.jks</exclude>
            </excludes>
        </resource>
    </resources>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <addResources>true</addResources>
            </configuration>
        </plugin>
    </plugins>
</build>		
			]]>
			</screen>
		</section>
		<section>
			<title>Spring Boot maven 插件 build-image</title>
			<para>Spring Boot 构建 Docker 镜像，你不需要写 Dockerfile，plugin 帮你完成。</para>
			<para>只需要简单的执行：</para>
			<screen>
			<![CDATA[
mvn spring-boot:build-image			
			]]>
			</screen>
			<para>执行完成后会看到成功提示信息：</para>
			<screen>
			<![CDATA[
[INFO] Successfully buit image 'docker.io/library/demo:0.0.1-SNAPSHOT'			
			]]>
			</screen>
			<para>运行容器测试：</para>
			<screen>
			<![CDATA[
docker run -p 8000:8080 -t demo:0.0.1-SNAPSHOT			
			]]>
			</screen>
			<para>注意：这里映射的本机端口是8000。</para>
			<screen>
			<![CDATA[
curl http://localhost:8000/
			]]>
			</screen>
		</section>
	</section>

	<section id="SpringApplication">
		<title>SpringApplication</title>
		<programlisting>
		<![CDATA[

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
@ComponentScan({"cn.netkiller.controller"})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
		]]>
		</programlisting><section id="spring.run">
		<title>运行 Spring boot 项目</title>
		<section>
			<title>Maven run</title>
			<programlisting>
			<![CDATA[
$ mvn spring-boot:run
$ mvn -P prod spring-boot:run
			]]>
			</programlisting>
			<para>-P 指定 profile</para>
			<para>打包后，使用jar包运行</para>
			<programlisting>
			<![CDATA[
$ mvn verify
$ mvn package
$ java -jar target/api.netkiller.cn-0.0.1-SNAPSHOT.jar
			]]>
			</programlisting>
		</section>
		<section>
			<title>Linux systemd</title>
			<para>/etc/systemd/system/spring.service</para>
			<screen>
			<![CDATA[
####################################################
# Homepage: http://netkiller.github.io
# Author: netkiller<netkiller@msn.com>
# Script: https://github.com/oscm/shell
# Date: 2015-11-03
####################################################
[Unit]
Description=Spring Boot Application
After=network.target

[Service]
User=www
Group=www
Type=oneshot
WorkingDirectory=/www/netkiller.cn/api.netkiller.cn
ExecStart=/usr/bin/java -jar your_jar_file.jar --spring.config.location=appliction-production.properties --spring.profiles.active=profile
#ExecStop=pkill -9 -f  
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
			]]>
			</screen>
		</section>
		<section>
			<title>传统 init.d 脚本</title>
			<screen>
			<![CDATA[
#!/bin/bash
##############################################
# Author: netkiller<netkiller@msn.com>
# Homepage: http://www.netkiller.cn
# Date: 2017-02-08
# $Author$
# $Id$
##############################################
# chkconfig: 345 100 02
# description: Spring boot application
# processname: springbootd
# File : springbootd
##############################################
BASEDIR="/www/netkiller.cn/api.netkiller.cn"
JAVA_HOME=/srv/java
JAVA_OPTS="-server -Xms2048m -Xmx8192m -Djava.security.egd=file:/dev/./urandom"
PACKAGE="api.netkiller.cn-0.0.2-release.jar"
CONFIG="--spring.config.location=$BASEDIR/application.properties"
USER=www
##############################################
NAME=springbootd
PROG="$JAVA_HOME/bin/java $JAVA_OPTS -jar $BASEDIR/$PACKAGE $CONFIG"
LOGFILE=/var/tmp/$NAME.log
PIDFILE=/var/tmp/$NAME.pid
ACCESS_LOG=/var/tmp/$NAME.access.log
##############################################

function log(){
	echo "$(date -d "today" +"%Y-%m-%d %H:%M:%S") $1	$2" >> $LOGFILE
}

function start(){
	if [ -f "$PIDFILE" ]; then
		echo $PIDFILE
		exit 2
	fi

	su - $USER -c "$PROG & echo \$! > $PIDFILE"
	log info start
}
function stop(){
	[ -f $PIDFILE ] && kill `cat $PIDFILE` && rm -rf $PIDFILE
	log info stop
}
function status(){
	ps aux | grep $PACKAGE | grep -v grep | grep -v status
	log info status
}
function reset(){
	pkill -f $PACKAGE
  	[ -f $PIDFILE ] && rm -rf $PIDFILE
	log info reset
}

case "$1" in
	start)
		start
		;;
	stop)
		stop
		;;
	status)
		status
		;;
	restart)
		stop
		start
		;;
	log)
		tail -f $LOGFILE
		;;
	reset)
		reset
		;;
	*)
		echo $"Usage: $0 {start|stop|status|restart|log|reset}"
esac
exit $?

			]]>
			</screen>
		</section>
		<section id="war">
			<title>编译用于Tomcat的 War</title>
			<programlisting>
			<![CDATA[
package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.web.SpringBootServletInitializer;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@ComponentScan
@EnableAutoConfiguration
public class Application extends SpringBootServletInitializer {

    private static Class<Application> applicationClass = Application.class;
    
    public static void main(String[] args) {
        SpringApplication.run(applicationClass, args);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(applicationClass);
    }
}		
			]]>
			</programlisting>
		</section>

	</section>

		<section id="SpringBootApplication">
			<title>@SpringBootApplication</title>
			<para>@SpringBootApplication 是 @Configuration, @EnableAutoConfiguration 跟 @ComponentScan 的集合。</para>
			<programlisting>
			<![CDATA[
@SpringBootApplication
			]]>
			</programlisting>
			<section>
				<title>排除 @EnableAutoConfiguration 加载项</title>
				<programlisting>
				<![CDATA[
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)				
				]]>
				</programlisting>
			</section>
		</section>
		<section id="EnableAutoConfiguration">
			<title>@EnableAutoConfiguration</title>
			<para>exclude 排除配置，下面例子是排除 DataSource配置</para>
			<programlisting>
			<![CDATA[
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
			]]>
			</programlisting>
		</section>
		<section id="@ComponentScan">
			<title>@ComponentScan</title>
			<para>@ComponentScan 注入会扫描 @Controller 与 @RestController</para>
			<programlisting>
			<![CDATA[
@ComponentScan
@ComponentScan({"cn.netkiller.controller"})
@ComponentScan({"cn.netkiller.controller", "cn.netkiller.rest"})
			]]>
			</programlisting>
		</section>
		<section id="@EntityScan">
			<title>@EntityScan 实体扫描</title>
			<programlisting>
			<![CDATA[
@EntityScan("common.domain")
			]]>
			</programlisting>
		</section>
		<section id="@EnableJpaRepositories">
			<title>@EnableJpaRepositories</title>
			<para>扫描 Jpa 仓库</para>
			<programlisting>
			<![CDATA[
@EnableJpaRepositories("common.domain")			
			]]>
			</programlisting>
		</section>
		<section id="CharacterEncodingFilter">
			<title>CharacterEncodingFilter</title>
			<programlisting>
			<![CDATA[
	public @Bean Filter characterEncodingFilter() {
		CharacterEncodingFilter characterEncodingFilter = new CharacterEncodingFilter();
		characterEncodingFilter.setEncoding("UTF-8");
		characterEncodingFilter.setForceEncoding(true);
		return characterEncodingFilter;
	}			
			]]>
			</programlisting>
		</section>
		<section id="banner">
			<title>隐藏 Banner</title>
			<para>隐藏 Spring Boot Banner</para>
			<screen>
				. ____ _ __ _ _
				/\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \
				( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
				\\/ ___)| |_)| | | | | || (_| | ) ) ) )
				' |____| .__|_| |_|_| |_\__, | / / / /
				=========|_|==============|___/=/_/_/_/
				:: Spring Boot :: (v2.3.1.RELEASE)
			</screen>
			<programlisting>
			<![CDATA[
public static void main(String[] args) {
    SpringApplication app = new SpringApplication(Application.class);
    app.setShowBanner(false);
    app.run(args);
}
			]]>
			</programlisting>
		</section>

		<section id="scan">
			<title>实体与仓库扫描</title>
			<programlisting>
			<![CDATA[
@EntityScan(basePackages = { "cn.netkiller.model" }) 
@EnableJpaRepositories(basePackages = { "cn.netkiller.repository" })			
			]]>
			</programlisting>
		</section>
		<section id="beans">
			<title>列出 Beans</title>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import java.util.Arrays;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
@EnableMongoRepositories
@EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		//SpringApplication.run(Application.class, args);

		ApplicationContext ctx = SpringApplication.run(Application.class, args);

		System.out.println("Let's inspect the beans provided by Spring Boot:");

		String[] beanNames = ctx.getBeanDefinitionNames();
		Arrays.sort(beanNames);
		for (String beanName : beanNames) {
			System.out.println(beanName);
		}

	}
}
			]]>
			</programlisting>
		</section>
		<section id="spring.boot.ports">
			<title>Tomcat 端口</title>
			<programlisting>
		<![CDATA[
@Configuration
public class TomcatConfiguration implements EmbeddedServletContainerCustomizer {

	int ports[] = { 8080, 8081, 8082 };

	@Override
	public void customize(ConfigurableEmbeddedServletContainer configurableEmbeddedServletContainer) {

		if (ports != null) {
			// 判断如果是Tomcat才进行如下配置
			if (configurableEmbeddedServletContainer instanceof TomcatEmbeddedServletContainerFactory) {

				TomcatEmbeddedServletContainerFactory tomcat = (TomcatEmbeddedServletContainerFactory) configurableEmbeddedServletContainer;

				for (int port : ports) {
					// 一个Connecter监听一个端口,指定协议为HTTP/1.1
					Connector httpConnector = new Connector("HTTP/1.1");
					httpConnector.setPort(port);
					tomcat.addAdditionalTomcatConnectors(httpConnector);
				}

			}
		}
	}
}
		]]>
			</programlisting>
		</section>
		<section>
			<title>配置项设定</title>
			<programlisting>
			<![CDATA[
public static void main(String[] args) {
    SpringApplication.run(Backend.class,
        "--spring.application.name=backend",
        "--server.port=9000"
    );
  }			
			]]>
			</programlisting>
		</section>
	</section>
	
	&section.boot.properties.xml;
	&section.boot.logging.xml;

	<section id="jetty">
		<title>Spring boot with Jetty</title>
		<para>使用 Jetty 替代 Tomcat</para>
		<screen>
		<![CDATA[
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <!-- Exclude the Tomcat dependency -->
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<!-- Use Jetty instead -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>		
		]]>
		</screen>
	</section>

	&section.boot.http2.xml;
	&section.boot.template.xml;

	<section id="session">
		<title>Spring boot with Session share</title>
		<section>
			<title>Redis</title>
			<section>
				<title>Maven</title>
				<para>增加下面代码到pom.xml</para>
				<programlisting>
				<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
				]]>
				</programlisting>
				<para>pom.xml 文件</para>
				<programlisting>
				<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>cn.netkiller</groupId>
	<artifactId>deploy</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>deploy.netkiller.cn</name>
	<description>Deploy project for Spring Boot</description>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-actuator</artifactId> </dependency> -->
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> -->
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-redis</artifactId>
		</dependency>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jdbc</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-websocket</artifactId>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>webjars-locator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>sockjs-client</artifactId>
			<version>1.0.2</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>stomp-websocket</artifactId>
			<version>2.3.3</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>bootstrap</artifactId>
			<version>3.3.7</version>
		</dependency>
		<dependency>
			<groupId>org.webjars</groupId>
			<artifactId>jquery</artifactId>
			<version>3.1.0</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.apache.tomcat.embed</groupId>
			<artifactId>tomcat-embed-jasper</artifactId>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>jstl</artifactId>
		</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>

	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

	<repositories>
		<repository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</repository>
		<repository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</repository>
	</repositories>
	<pluginRepositories>
		<pluginRepository>
			<id>spring-snapshots</id>
			<name>Spring Snapshots</name>
			<url>https://repo.spring.io/snapshot</url>
			<snapshots>
				<enabled>true</enabled>
			</snapshots>
		</pluginRepository>
		<pluginRepository>
			<id>spring-milestones</id>
			<name>Spring Milestones</name>
			<url>https://repo.spring.io/milestone</url>
			<snapshots>
				<enabled>false</enabled>
			</snapshots>
		</pluginRepository>
	</pluginRepositories>

</project>
				
				]]>
				</programlisting>
			</section>
			<section>
				<title>application.properties</title>
				<para>spring.session.store-type=redis 将Session 存储在Redis中</para>
				<programlisting>
				<![CDATA[
spring.redis.database=0
spring.redis.host=192.168.4.1
spring.redis.port=6379
#spring.redis.password=
spring.redis.pool.max-active=8
spring.redis.pool.max-wait=30
spring.redis.pool.max-idle=8
spring.redis.pool.min-idle=0
spring.redis.timeout=10

spring.session.store-type=redis
				]]>
				</programlisting>

			</section>
			<section>
				<title>Application</title>
				<programlisting>
				<![CDATA[
package cn.netkiller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
@EnableMongoRepositories
@EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);

	}
}
				]]>
				</programlisting>
				<para>RedisHttpSessionConfig.java</para>
				<programlisting>
				<![CDATA[
package cn.netkiller.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@Configuration
@EnableRedisHttpSession
public class RedisHttpSessionConfig {

	public RedisHttpSessionConfig() {
		// TODO Auto-generated constructor stub
	}

}				
				]]>
				</programlisting>
			</section>

		</section>
		<section>
			<title>测试 Session</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.web;

import java.util.Date;

import javax.servlet.http.HttpSession;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TestController {

	public TestController() {
		// TODO Auto-generated constructor stub
	}

	@RequestMapping("/session/set")
	@ResponseBody
	public String set(HttpSession session) {
		String key = "test";
		session.setAttribute(key, new Date());
		return key;
	}

	@RequestMapping("/session/get")
	@ResponseBody
	public String get(HttpSession session) {
		String value = (String) session.getAttribute("test").toString();
		return value;
	}

}
			]]>
			</programlisting>
			<para>keys spring:session:* 查看 Session Key</para>
			<screen>
			<![CDATA[			
$ telnet 192.168.4.1 6379
Connecting to 192.168.4.1:6379...
Connection established.
To escape to local shell, press 'Ctrl+Alt+]'.
keys spring:session:*
*7
$68
spring:session:sessions:expires:a510f46f-0a2f-4649-af05-34bd750562c1
$40
spring:session:expirations:1476100200000
$40
spring:session:expirations:1476098400000
$60
spring:session:sessions:f6494a2f-591e-42ba-b381-ce2596f4046d
$60
spring:session:sessions:a510f46f-0a2f-4649-af05-34bd750562c1
$112
spring:session:index:org.springframework.session.FindByIndexNameSessionRepository.PRINCIPAL_NAME_INDEX_NAME:user
$60
spring:session:sessions:627018c8-243e-43ac-87b9-fc07f130c899
				]]>
			</screen>
		</section>
		<section>
			<title>JDBC</title>
			<programlisting>
			<![CDATA[
spring.session.store-type=jdbc
spring.session.jdbc.table-name=SESSIONS			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Springboot 2.1</title>
			<screen>
			<![CDATA[
<dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-redis</artifactId>  
</dependency>  
<dependency>  
        <groupId>org.springframework.session</groupId>  
        <artifactId>spring-session-data-redis</artifactId>  
</dependency>  
			]]>
			</screen>
			<para>开启Redis共享SESSION @EnableRedisHttpSession </para>
			<screen>
			<![CDATA[
package cn.netkiller.oauth2;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;

@SpringBootApplication
@EnableAutoConfiguration
@EnableRedisHttpSession 
public class Application {
	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}
}
			
			]]>
			</screen>
			<para>application.properties中配置redis服务器</para>
			<screen>
			<![CDATA[
spring.redis.host=localhost  
spring.redis.port=6379 			
			]]>
			</screen>
		</section>
	</section>

	<section id="cache">
		<title>Spring boot with Caching</title>
		<section>
			<title>maven</title>
			<programlisting>
				<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
		</dependency>			
				]]>
			</programlisting>
		</section>
		<section id="">
			<title>启用 Cache</title>
			<para>添加 @EnableCaching </para>
			<screen>
			<![CDATA[
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableCaching
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}			
			]]>
			</screen>
		</section>

		<section>
			<title>测试 Controller</title>
			<para>缓存返回结果</para>
			<programlisting>
				<![CDATA[
	@Cacheable("cacheable")
	@RequestMapping("/test/cacheable")
	@ResponseBody
	public String cacheable() {
		Date date = new Date();
		String message = date.toString();
		return message;
	}
				]]>
			</programlisting>
			<para>5秒钟清楚一次缓存</para>
			<programlisting>
				<![CDATA[
	@Scheduled(fixedDelay = 5000)
	@CacheEvict(allEntries = true, value = "cacheable")	
	public void expire() {
		Date date = new Date();
		String message = date.toString();
		System.out.println(message);
	}
				]]>
			</programlisting>
		</section>
		<section>
			<title>@Cacheable 的用法</title>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#id")
public User find(Integer id) {

   return null;

}			
			]]>
			</programlisting>
			<para>引用对象</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#user.id")
public User find(User user) {

   returnnull;

}			
			]]>
			</programlisting>
			<para>条件判断</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="messagecache", key="#id", condition="id < 10")
public String getMessage(int id){

	return "hello"+id;

}

@Cacheable(value="test",condition="#userName.length()>2")
@Cacheable(value={"users"}, key="#user.id", condition="#user.id%2==0")
			]]>
			</programlisting>
			<para>#p0 参数索引，p0表示第一个参数</para>
			<programlisting>
			<![CDATA[
@Cacheable(value="users", key="#p0")
public User find(Integer id) {

   return null;

}

@Cacheable(value="users", key="#p0.id")
public User find(User user) {

   return null;

}
			]]>
			</programlisting>
			<para>@Cacheable 如果没有任何参数将会自动生成 key ，前提是必须设置 @CacheConfig(cacheNames = "test")</para>
			<programlisting>
			<![CDATA[
	@GetMapping("/cache/auto")
	@Cacheable()
	public Attribute auto() {
		Attribute attribute = new Attribute();
		attribute.setName("sdfsdf");
		return attribute;
	}			
			]]>
			</programlisting>
			<screen>
			<![CDATA[
127.0.0.1:6379> keys *
1) "test::SimpleKey []"			
			]]>
			</screen>
		</section>
		<section id="">
			<title>@CachePut 用法</title>
			<para>@CachePut 每次都会执行方法，都会将结果存入指定key的缓存中，@CachePut 不会判断是否 key 已经存在，二是始终覆盖。</para>
			<programlisting>
			<![CDATA[
@CachePut("users")
public User find(Integer id) {

   return null;

}
			]]>
			</programlisting>
		</section>
		<section id="">
			<title>解决Expire 和 TTL 过期时间</title>
			<para>Springboot 1.x</para>
			<programlisting>
			<![CDATA[
	@Bean
	public CacheManager cacheManager(RedisTemplate redisTemplate) {
		RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);
		cacheManager.setDefaultExpiration(60);	//缓存默认 60 秒
		Map<String, Long> expiresMap = new HashMap<>();
		expiresMap.put("Product", 5L);  //设置 key = Product 时 5秒缓存。你可以添加很多规则。 
		cacheManager.setExpires(expiresMap);
		return cacheManager;
	}			
			]]>
			</programlisting>
			<para>Springboot 2.x</para>
			<programlisting>
			<![CDATA[
package api.config;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import org.springframework.cache.CacheManager;
import org.springframework.cache.interceptor.KeyGenerator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.cache.RedisCacheWriter;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;

@Configuration
public class CachingConfigurer {

	public CachingConfigurer() {
		// TODO Auto-generated constructor stub
	}

	@Bean
	public KeyGenerator simpleKeyGenerator() {
		return (o, method, objects) -> {
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.append(o.getClass().getSimpleName());
			stringBuilder.append(".");
			stringBuilder.append(method.getName());
			stringBuilder.append("[");
			for (Object obj : objects) {
				stringBuilder.append(obj.toString());
			}
			stringBuilder.append("]");

			return stringBuilder.toString();
		};
	}

	@Bean
	public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
		return new RedisCacheManager(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory), 
		this.redisCacheConfiguration(600), 	// 默认配置
		this.initialCacheConfigurations());	// 指定key过期时间配置
	}
               
	private Map<String, RedisCacheConfiguration> initialCacheConfigurations() {
		Map<String, RedisCacheConfiguration> redisCacheConfigurationMap = new HashMap<>();
		redisCacheConfigurationMap.put("UserInfoList", this.redisCacheConfiguration(3000));
		redisCacheConfigurationMap.put("UserInfoListAnother", this.redisCacheConfiguration(18000));

		return redisCacheConfigurationMap;
	}

	private RedisCacheConfiguration redisCacheConfiguration(Integer seconds) {
		Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
		ObjectMapper om = new ObjectMapper();
		om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
		jackson2JsonRedisSerializer.setObjectMapper(om);

		RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
		redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)).entryTtl(Duration.ofSeconds(seconds));

		return redisCacheConfiguration;
	}

}

			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
	@Cacheable(value = "DefaultKey", keyGenerator = "simpleKeyGenerator") // 600秒，使用默认策略
	@Cacheable(value = "UserInfoList", keyGenerator = "simpleKeyGenerator") // 3000秒
    @Cacheable(value = "UserInfoListAnother", keyGenerator = "simpleKeyGenerator") // 18000秒
    
			]]>
			</programlisting>
			<screen>
			<![CDATA[
127.0.0.1:6379> keys *
1) "test2::SimpleKey []"

127.0.0.1:6379> ttl "test2::SimpleKey []"
(integer) 584
			
			]]>
			</screen>
		</section>
		<section>
			<title>SpEL表达式</title>
			<programlisting>
			<![CDATA[
	@GetMapping("/cache/expire")
	@Cacheable("test1#${select.cache.timeout:1000}")
	public String expire() {
		return "Test";
	}
	
	@GetMapping("/cache/expire")
	@Cacheable("test1#${select.cache.timeout:1000}#${select.cache.refresh:600}")
	public String expire() {
		return "Test";
	}
			]]>
			</programlisting>
		</section>
	</section>
	<section id="email">
		<title>Spring boot with Email</title>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-mail</artifactId>
</dependency>
			]]>
			</programlisting>
			<example>
				<title>Spring boot with Email (pom.xml)</title>
				<programlisting>
				<![CDATA[
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>netkiller.cn</groupId>
	<artifactId>api.netkiller.cn</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>api.netkiller.cn</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<java.version>1.8</java.version>
	</properties>

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.3.1.RELEASE</version>
	</parent>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-security</artifactId> </dependency> -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-jdbc</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-mongodb</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-oracle</artifactId>
			<version>1.0.0.RELEASE</version>
		</dependency>

		<dependency>
			<groupId>com.oracle</groupId>
			<artifactId>ojdbc6</artifactId>
			<!-- <version>12.1.0.1</version> -->
			<version>11.2.0.3</version>
			<scope>system</scope>
			<systemPath>${basedir}/lib/ojdbc6.jar</systemPath>
		</dependency>

		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>

		<dependency>
			<groupId>com.google.code.gson</groupId>
			<artifactId>gson</artifactId>
			<scope>compile</scope>
		</dependency>
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<sourceDirectory>src</sourceDirectory>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
			<plugin>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.3</version>
				<configuration>
					<source />
					<target />
				</configuration>
			</plugin>
			<plugin>
				<artifactId>maven-war-plugin</artifactId>
				<version>2.6</version>
				<configuration>
					<warSourceDirectory>WebContent</warSourceDirectory>
					<failOnMissingWebXml>false</failOnMissingWebXml>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>

				]]>
				</programlisting>
			</example>
		</section>
		<section>
			<title>Resource</title>
			<para>application.properties</para>
			<para>Postfix / Exam4 / Sendmail 邮件服务器配置</para>
			<programlisting>
			<![CDATA[
spring.mail.host=smtp.163.com    
			]]>
			</programlisting>
			<para>SMTP 配置</para>
			<programlisting>
			<![CDATA[
spring.mail.host=smtp.163.com
spring.mail.username=openunix@163.com
spring.mail.password=your_password
spring.mail.properties.mail.smtp.auth=true  
#spring.mail.properties.mail.smtp.starttls.enable=true  
#spring.mail.properties.mail.smtp.starttls.required=true  
			]]>
			</programlisting>
		</section>
		<section>
			<title>POJO</title>
			<programlisting>
			<![CDATA[
package api.pojo;

public class Email {
	public String from;
	public String to;
	public String subject;
	public String text;
	public boolean status;
	
	public String getFrom() {
		return from;
	}
	public void setFrom(String from) {
		this.from = from;
	}
	public String getTo() {
		return to;
	}
	public void setTo(String to) {
		this.to = to;
	}
	public String getSubject() {
		return subject;
	}
	public void setSubject(String subject) {
		this.subject = subject;
	}
	public String getText() {
		return text;
	}
	public void setText(String text) {
		this.text = text;
	}
	
	public boolean isStatus() {
		return status;
	}
	public void setStatus(boolean status) {
		this.status = status;
	}
	
	@Override
	public String toString() {
		return "Email [from=" + from + ", to=" + to + ", subject=" + subject + ", text=" + text + "]";
	}
	public Email() {

	}
	public Email(String from, String to, String subject, String text) {
		super();
		this.from = from;
		this.to = to;
		this.subject = subject;
		this.text = text;
	}
	
}

			]]>
			</programlisting>
		</section>
		<section>
			<title>RestController</title>
			<programlisting>
			<![CDATA[
package api.rest;

import java.io.File;

import javax.mail.internet.MimeMessage;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

import api.pojo.Email;

@RestController
@RequestMapping("/v1/email")
public class EmailRestController extends CommonRestController {

	@Autowired
	private JavaMailSender javaMailSender;

	@RequestMapping("version")
	@ResponseStatus(HttpStatus.OK)
	public String version() {
		return "[OK] Welcome to withdraw Restful version 1.0";
	}

	@RequestMapping(value = "send", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> sendSimpleMail(@RequestBody Email email) {
		SimpleMailMessage message = new SimpleMailMessage();
		message.setFrom(email.getFrom());
		message.setTo(email.getTo());
		message.setSubject(email.getSubject());
		message.setText(email.getText());
		javaMailSender.send(message);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}

	@RequestMapping(value = "attachments", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> attachments(@RequestBody Email email) throws Exception {

		MimeMessage mimeMessage = javaMailSender.createMimeMessage();

		MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);
		mimeMessageHelper.setFrom(email.getFrom());
		mimeMessageHelper.setTo(email.getTo());
		mimeMessageHelper.setSubject(email.getSubject());
		mimeMessageHelper.setText("<html><body><img src=\"cid:banner\" >" + email.getText() + "</body></html>", true);

		FileSystemResource file = new FileSystemResource(new File("banner.jpg"));
		mimeMessageHelper.addInline("banner", file);

		FileSystemResource fileSystemResource = new FileSystemResource(new File("Attachment.jpg"));
		mimeMessageHelper.addAttachment("Attachment.jpg", fileSystemResource);

		javaMailSender.send(mimeMessage);
		email.setStatus(true);

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}
	
	// 如果你不想使用 application.properties 中的 spring.mail.host 配置，想自行配置SMTP主机可以参考下面例子
	@RequestMapping(value = "sendmail", method = RequestMethod.POST, produces = { "application/xml", "application/json" })
	public ResponseEntity<Email> sendmail(@RequestBody Email email) {
		JavaMailSenderImpl javaMailSender = new JavaMailSenderImpl();
		javaMailSender.setHost(email.getHost());
		SimpleMailMessage message = new SimpleMailMessage();
		message.setFrom(email.getFrom());
		message.setTo(email.getTo());
		message.setSubject(email.getSubject());
		message.setText(email.getText());
		try{
			javaMailSender.send(message);
			email.setStatus(true);
		}catch(Exception e){
			email.setText(e.getMessage());
			email.setStatus(false);
		}

		return new ResponseEntity<Email>(email, HttpStatus.OK);
	}	
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Test</title>
			<screen>
			<![CDATA[
$ curl -i -H "Accept: application/json" -H "Content-Type: application/json" -X POST -d '{"from":"root@netkiller.cn", "to":"21214094@qq.com","subject":"Hello","text":"Hello world!!!"}' http://172.16.0.20:8080/v1/email/send.json
HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
Date: Wed, 10 Aug 2016 06:38:00 GMT

{"from":"root@netkiller.cn","to":"21214094@qq.com","subject":"Hello","text":"Hello world!!!","status":true}
			]]>
			</screen>
		</section>
	</section>

	<section id="hessian">
		<title>Spring boot with Hessian</title>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
		<dependency>
			<groupId>com.caucho</groupId>
			<artifactId>hessian</artifactId>
			<version>4.0.38</version>
		</dependency>			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Application</title>
			<programlisting>
			<![CDATA[
package cn.netkiller;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
//import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
//import org.springframework.data.mongodb.repository.config.EnableMongoRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableAutoConfiguration
@ComponentScan
// @EnableMongoRepositories
// @EnableJpaRepositories
@EnableScheduling
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);

	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>HessianServiceExporter</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.remoting.caucho.HessianProxyFactoryBean;
//import org.springframework.remoting.caucho.HessianProxyFactoryBean;
import org.springframework.remoting.caucho.HessianServiceExporter;

import cn.netkiller.service.HelloWorldService;

@Configuration
public class HessionConfig {
	@Autowired
	private HelloWorldService helloWorldService;

	@Bean(name = "/HelloWorldService")
	public HessianServiceExporter hessianServiceExporter() {
		HessianServiceExporter exporter = new HessianServiceExporter();
		exporter.setService(helloWorldService);
		exporter.setServiceInterface(HelloWorldService.class);
		return exporter;
	}

	@Bean
	public HessianProxyFactoryBean helloClient() {
		HessianProxyFactoryBean factory = new HessianProxyFactoryBean();
		factory.setServiceUrl("http://localhost:7000/HelloWorldService");
		factory.setServiceInterface(HelloWorldService.class);
		return factory;
	}
}		
			]]>
			</programlisting>
		</section>
		<section>
			<title>Service</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.service;

public interface HelloWorldService {
	String sayHello(String name);
}
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
package cn.netkiller.service.impl;

import org.springframework.stereotype.Component;

import cn.netkiller.service.HelloWorldService;

@Component
public class HelloWorldServiceImpl implements HelloWorldService {
	@Override
	public String sayHello(String name) {
		return "Hello World! " + name;
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>RestController</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.rest.hession;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import cn.netkiller.service.HelloWorldService;

@RestController
@RequestMapping("/public/hession")
public class TestRestController {
	@Autowired
	HelloWorldService helloWorldService;

	@RequestMapping("/hello")
	public String test() {
		return helloWorldService.sayHello("Spring boot with Hessian.");
	}
}		
			]]>
			</programlisting>
		</section>
	</section>

	<section id="git">
		<title>Spring boot with Git version</title>
		<para>Spring boot 每次升级打包发给运维操作，常常运维操作不当致使升级失败，开发怎样确认线上的jar/war包与升级包一致呢？</para>
		<para>请看下面的解决方案</para>
		<section>
			<title>CommonRestController 公共控制器</title>
			<para>所有 RestController将会集成 CommonRestController</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.rest;

import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;

public class CommonRestController {

	@RequestMapping("ping")
	@ResponseStatus(HttpStatus.OK)
	public String welcome() {
		return "PONG";
	}

	@RequestMapping("commit")
	public String commit() {
		return "$Id$";
	}

	@RequestMapping("auth")
	@ResponseStatus(HttpStatus.OK)
	public String auth(@AuthenticationPrincipal final UserDetails user) {
		return String.format("%s: %s %s", user.getUsername(), user.getPassword(), user.getAuthorities());
	}
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>VersionRestController 测试控制器</title>
			<para>我们创建一个RestController并继承CommonRestController用来测试</para>
			<programlisting>
			<![CDATA[
package cn.netkiller.api.rest;

@RestController
@RequestMapping("/public/version")
public class VersionRestController extends CommonRestController {
	private static final Logger logger = LoggerFactory.getLogger(VersionRestController.class);

	public VersionRestController() {
		// TODO Auto-generated constructor stub
	}

	@RequestMapping("welcome")
	@ResponseStatus(HttpStatus.OK)
	public String welcome() {
		return "Welcome to RestTemplate version 1.0.";
	}

}
			]]>
			</programlisting>
		</section>
		<section>
			<title>创建 .gitattributes 文件</title>
			<programlisting>
			<![CDATA[
# vim .gitattributes
src/main/java/cn/netkiller/api/rest/CommonRestController.java ident
			]]>
			</programlisting>
			<para>使用curl命令调用commit接口可以显示当前war/jar最后一次提交的版本号码（你同样可以使用IE浏览器）</para>
			<programlisting>
			<![CDATA[
curl https://api.netkiller.cn/public/version/commit.json
$Id: 929bc9e4c90b4d68c25dc693618f23b33fd6ba0f $
			]]>
			</programlisting>
		</section>
	</section>

	<section id="data.restful">
		<title>Spring boot with Data restful</title>
		<para>spring-boot-starter-data-rest 能够提供将 Repository, CrudRepository 等接口直接提供给用户访问</para>
		<section>
			<title>Maven</title>
			<programlisting>
			<![CDATA[
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-rest</artifactId>
		</dependency>
			]]>
			</programlisting>
		</section>
	</section>
	<section id="SpringBoot.ELK">
		<title>Spring boot with ELK(Elasticsearch + Logstash + Kibana)</title>
		<para>将 Spring boot 日志写入 ELK 有多种实现方式，这里仅提供三种方案：</para>
		<orderedlist>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Tcp/IP -&gt; logstash -&gt; elasticsearch</para>
				这种方式实现非常方便不需要而外包或者软件
			</listitem>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Redis -&gt; logstash -&gt; elasticsearch</para>
				利用 Redis 提供的发布订阅功能将日志投递到 elasticsearch
			</listitem>
			<listitem>
				<para>Spring boot -&gt; logback -&gt; Kafka -&gt; logstash -&gt; elasticsearch</para>
				Kafka 方法适合大数据的情况。
			</listitem>
		</orderedlist>
		<section>
			<title>TCP 方案</title>
			<para>logstash 配置</para>
			<programlisting>
			<![CDATA[
input {
  tcp {
    host => "172.16.1.16" 
    port => 9250
    mode => "server"
    tags => ["tags"]
    codec => json_lines  //可能需要更新logstash插件
  }
}

output {
 stdout{codec =>rubydebug}
  elasticsearch {
   hosts => ["localhost:9200"]  //这块配置需要带端口号
    flush_size => 1000

  }
}			
			]]>
			</programlisting>
			<para>Spring boot logback.xml 配置</para>
			<programlisting>
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <property resource="properties/logback-variables.properties" /> 

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder charset="UTF-8">
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n
            </pattern>
        </encoder>
    </appender>
    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>172.16.1.16:9250</destination>
        <encoder charset="UTF-8" class="net.logstash.logback.encoder.LogstashEncoder" />
    </appender>

    <!--<appender name="async" class="ch.qos.logback.classic.AsyncAppender">-->
        <!--<appender-ref ref="stash" />-->
    <!--</appender>-->
    
    <root level="info">                    <!-- 设置日志级别 -->
        <appender-ref ref="STDOUT" />
        <appender-ref ref="LOGSTASH" />
    </root>
</configuration>			
			]]>
			</programlisting>
		</section>
		<section>
			<title>Redis 方案</title>
			<para>https://github.com/kmtong/logback-redis-appender</para>
			<para>Maven pom.xml 增加 Logback Redis 依赖</para>
			<programlisting>
			<![CDATA[
<!-- https://mvnrepository.com/artifact/com.cwbase/logback-redis-appender -->
<dependency>
    <groupId>com.cwbase</groupId>
    <artifactId>logback-redis-appender</artifactId>
    <version>1.1.5</version>
</dependency>			
			]]>
			</programlisting>
			<para>Spring boot logback.xml 配置</para>
			<programlisting>
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
	<include resource="org/springframework/boot/logging/logback/defaults.xml" />
	<include resource="org/springframework/boot/logging/logback/file-appender.xml" />
	<property name="type.name" value="test" />
	<appender name="LOGSTASH" class="com.cwbase.logback.RedisAppender">
		<source>spring-application</source>
		<type>${type.name}</type>
		<host>localhost</host>
		<key>logstash:redis</key>
		<tags>test-2</tags>
		<mdc>true</mdc>
		<location>true</location>
		<callerStackIndex>0</callerStackIndex>
		<!--additionalField添加附加字段 用于head插件显示 -->
		<additionalField>
			<key>MyKey</key>
			<value>MyValue</value>
		</additionalField>
		<additionalField>
			<key>MySecondKey</key>
			<value>MyOtherValue</value>
		</additionalField>
	</appender>
	<root level="INFO">
		<appender-ref ref="FILE" />
		<appender-ref ref="LOGSTASH" />
	</root>
</configuration>
			]]>
			</programlisting>
			<para>logstash 配置</para>
			<programlisting>
			<![CDATA[
input {
    redis {
        host => 'localhost'
        data_type => 'list'
        port => "6379"
        key => 'logstash:redis' #自定义
        type => 'redis-input'   #自定义
    }
}
output {
    elasticsearch {
        host => "localhost" 
        codec => "json"
        protocol => "http"
    }
}
			]]>
			</programlisting>
		</section>
		<section>
			<title>Kafka 方案</title>
			<programlisting>
			<![CDATA[]]>
			</programlisting>
		</section>
		<section>
			<title>Other</title>
			<programlisting>
			<![CDATA[]]>
			</programlisting>
		</section>
	</section>
	<section id="web3j">
		<title>Springboot with Ethereum (web3j)</title>
		<section>
			<title>Maven</title>
			<screen>
			<![CDATA[
		<dependency>
			<groupId>org.web3j</groupId>
			<artifactId>web3j-spring-boot-starter</artifactId>
			<version>1.6.0</version>
		</dependency>			
			]]>
			</screen>
		</section>
		<section id="web3j.springboot.application.properties">
			<title>application.properties</title>
			<screen>
			<![CDATA[
web3j.client-address=https://ropsten.infura.io/CsS9shwaAab0z7B4LP2d
web3j.admin-client=true			
			]]>
			</screen>
		</section>
		<section>
			<title>TestRestController</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.wallet.restful;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;

@RestController
public class TestRestController {
	private static final Logger logger = LoggerFactory.getLogger(TestRestController.class);

	@Autowired
	private Web3j web3j;

	public TestRestController() {
		// TODO Auto-generated constructor stub
	}

	@GetMapping("/version")
	public String version() throws IOException {
		Web3ClientVersion web3ClientVersion = web3j.web3ClientVersion().send();
		String clientVersion = web3ClientVersion.getWeb3ClientVersion();
		logger.info(clientVersion);
		return clientVersion;
	}

}
			
			]]>
			</programlisting>
		</section>
		<section>
			<title>测试</title>
			<screen>
			<![CDATA[
neo@MacBook-Pro ~ % curl http://localhost:8080/version
Geth/v1.8.3-stable/linux-amd64/go1.10
			]]>
			</screen>
		</section>
	</section>
	<section id="enableasync">
		<title>Spring boot with Async</title>
		<para>异步执行</para>
		<section>
			<title>最简单的配置</title>
			<para></para>
			<programlisting>
			<![CDATA[
@SpringBootApplication
@EnableAsync
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
			]]>
			</programlisting>
			<para></para>
			<programlisting>
			<![CDATA[
@Component
public class Task {

    @Async
    public void doTaskOne() throws Exception {
        // 业务逻辑
    }

    @Async
    public void doTaskTwo() throws Exception {
        // 业务逻辑
    }

    @Async
    public void doTaskThree() throws Exception {
        // 业务逻辑
    }

}			
			]]>
			</programlisting>
			<para>设置线程池，并且运行完成后推出</para>
			<programlisting>
			<![CDATA[
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;

@SpringBootApplication
@EnableAsync
public class Application {

    public static void main(String[] args) {
        // close the application context to shut down the custom ExecutorService
        SpringApplication.run(Application.class, args).close();
    }

    @Bean
    public Executor asyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(2);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("Netkiller -");
        executor.initialize();
        return executor;
    }


}			
			]]>
			</programlisting>
		</section>
		<section>
			<title>异步线程池</title>
			<programlisting>
			<![CDATA[
package cn.netkiller.wallet.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;

@Configuration
@EnableAsync
public class ExecutorConfig {
	/** Set the ThreadPoolExecutor's core pool size. */
	private int corePoolSize = 10;
	/** Set the ThreadPoolExecutor's maximum pool size. */
	private int maxPoolSize = 200;
	/** Set the capacity for the ThreadPoolExecutor's BlockingQueue. */
	private int queueCapacity = 10;
 
	@Bean
	public Executor OneAsync() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(corePoolSize);
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setThreadNamePrefix("MySimpleExecutor-");
		executor.initialize();
		return executor;
	}
	
	@Bean
	public Executor TwoAsync() {
		ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
		executor.setCorePoolSize(corePoolSize);
		executor.setMaxPoolSize(maxPoolSize);
		executor.setQueueCapacity(queueCapacity);
		executor.setThreadNamePrefix("MyExecutor-");
 
		// rejection-policy：当pool已经达到max size的时候，如何处理新任务
		// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行
		executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
		executor.initialize();
		return executor;
	}

}
			
			]]>
			</programlisting>

			<programlisting>
			<![CDATA[
@Service
public class DemoAsyncServiceImpl implements DemoAsyncService {
 
	public static Random random =new Random();
 
    @Async("OneAsync")
    public Future<String> doTaskOne() throws Exception {
        System.out.println("开始做任务一");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务一，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务一完成");
    }
 
    @Async("TwoAsync")
    public Future<String> doTaskTwo() throws Exception {
        System.out.println("开始做任务二");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务二，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务二完成");
    }
 
    @Async
    public Future<String> doTaskThree() throws Exception {
        System.out.println("开始做任务三");
        long start = System.currentTimeMillis();
        Thread.sleep(random.nextInt(10000));
        long end = System.currentTimeMillis();
        System.out.println("完成任务三，耗时：" + (end - start) + "毫秒");
        return new AsyncResult<>("任务三完成");
    }
	
}
			]]>
			</programlisting>

		</section>
	</section>
	<section id="export.csv">
		<title>Spring boot with csv</title>
		<para>下面是一个导出 CSV 文件的例子</para>
		<programlisting>
		<![CDATA[
	@GetMapping("/export")
	public void export(HttpServletResponse response) throws IOException {
		response.setContentType("application/csv");
		// response.setContentType("application/csv;charset=gb18030");
		response.setHeader("Content-Disposition", "attachment; filename=\"file.csv\"");

		BufferedWriter writer = new BufferedWriter(response.getWriter());

		// 需要写入 utf8bom 头否则会出现中文乱码
		// byte[] uft8bom = { (byte) 0xef, (byte) 0xbb, (byte) 0xbf };
		String bom = new String(new byte[] { (byte) 0xEF, (byte) 0xBB, (byte) 0xBF });
		writer.write(bom);
		writer.write("A,B,C");
		writer.newLine();
		tableRepository.findAll().forEach(table -> {
			try {
				String tmp = String.format("%s,%s,%s", table.getId(), table.getMethod(), table.getMoney());
				writer.write(tmp);
				writer.newLine();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		});

		writer.flush();
		writer.close();
	}		
		]]>
		</programlisting>
	</section>
	&section.boot.datasource.xml;
	&section.boot.queue.xml;
	&section.boot.schedule.xml;
	&section.boot.swagger2.xml;
	&section.boot.lombok.xml;
	&section.boot.docker.xml;
	&section.boot.command.xml;
	&section.boot.actuator.xml;
	&section.boot.rest.xml;
	&section.boot.test.xml;
	&section.boot.aop.xml;	
	&section.boot.starter.xml;
	&section.boot.monitor.xml;
</chapter>
